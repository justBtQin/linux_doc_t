# 31 进程内代理

传统的调试模型在概念上是低速的，但工作良好，因为大多数错误可以在调试模式执行中重现。然而，随着多核或众核处理器正在成为主流，多线程程序变得越来越流行，应该会有越来越多的错误仅在正常模式执行中才会显现出来，例如线程竞争，因为调试器对程序时间的干扰可能会掩盖这些错误。另一方面，在某些应用中，调试器中断程序执行的时间足够长以让开发人员了解其行为的任何有用信息是不可行的。如果程序的正确性取决于其实时行为，调试器引入的延迟可能会导致程序失败，即使代码本身是正确的。能够在不中断程序的情况下观察程序的行为是很有用的。

因此，传统的调试模型对于重现某些错误来说过于侵入性。为了减少对程序的干扰，我们可以减少调试器执行的操作数量。进程内代理是一个共享库，与 inferior 在同一进程中运行，并且能够自己执行一些调试操作。结果，调试器仅在必要时才参与，并且调试性能可以相应地提高。请注意，对程序的干扰可以减少，但不能完全消除，因为进程内代理仍将停止或减慢程序。

进程内代理可以在执行调试操作期间解释和执行代理表达式（见附录 F [代理表达式]，第 849 页）。代理表达式可用于不同的目的，例如在跟踪点收集数据，以及在断点中进行条件评估。

您可以使用以下命令控制是否使用进程内代理作为调试的辅助工具：

```
set agent on
	导致进程内代理代表调试器执行一些操作。进程内代理将执行用户请求的哪些操作取决于其能力。例如，如果您请求在进程内代理中评估断点条件，并且进程内代理也具有此能力，那么断点条件将在进程内代理中进行评估。

set agent off
	禁用进程内代理执行调试操作。所有操作将由 gdb 执行。

show agent
	显示进程内代理执行调试操作的当前设置。
```

## 31.1 进程内代理协议

进程内代理能够与 gdb 和 GDBserver 进行通信（见第 31 章[进程内代理]，第 707 页）。本节记录了 gdb 或 GDBserver 与 IPA 之间用于通信的协议。一般来说，gdb 或 GDBserver 向进程内代理发送命令（见第 31.1.2 节[IPA 协议命令]，第 709 页）和数据，然后进程内代理以命令的返回结果或其他信息进行回复。发送给进程内代理的数据由基本数据类型组成，如 4 字节或 8 字节类型，以及复合类型，称为对象（见第 31.1.1 节[IPA 协议对象]，第 708 页）。

### 31.1.1 IPA 协议对象

发送给代理以及从代理接收的命令可能包含一些称为对象的复杂数据类型。

在进程内的代理与 gdb 或 GDBserver 在同一台机器上运行，因此它不必像远程协议（参见附录 E [远程协议]，第 775 页）那样处理两端之间的大量差异。然而，在两个进程的两端仍然存在一些差异：

1. 字大小。在某些 64 位机器上，gdb 或 GDBserver 可以编译为 64 位可执行文件，而进程内代理是 32 位的。

2. ABI。一些机器可能有多种类型的 ABI，gdb 或 GDBserver 是用一种编译的，而进程内代理是用另一种编译的。

以下是 IPA 协议对象：

1. 代理表达式对象。它表示一个代理表达式（参见附录 F [代理表达式]，第 849 页）。

2. 跟踪点动作对象。它表示一个跟踪点动作（参见第 13.1.6 节 [跟踪点动作列表]，第 208 页），用于收集寄存器、内存、静态跟踪数据和评估表达式。

3. 跟踪点对象。它表示一个跟踪点（参见第 13 章 [跟踪点]，第 203 页）。

下表描述了每个 IPA 协议对象的重要属性：

| 名称 | 大小 | 描述 |
| ---- | ---- | ---- |
| `agent expression object` | - | - |
| `length` | 4 | 字节码的长度 |
| `byte code` | length | 字节码的内容 |
| `tracepoint action for collecting memory` | - | - |
| `'M'` | 1 | 跟踪点操作的类型 |
| `addr` | 8 | 如果 `basereg` 为 `-1`，`addr` 是要收集的最低字节的地址，否则 `addr` 是用于内存收集的 `basereg` 的偏移量。 |
| `len` | 8 | 要收集的内存长度 |
| `basereg` | 4 | 包含收集起始内存地址的寄存器编号。 |
| `tracepoint action for collecting registers` | - | - |
| `'R'` | 1 | 跟踪点操作的类型 |
| `tracepoint action for collecting static trace data` | - | - |
| `'L'` | 1 | 跟踪点操作的类型 |
| `tracepoint action for expression evaluation` | - | - |
| `'X'` | 1 | 跟踪点操作的类型 |
| `agent expression tracepoint object` | length of | [agent expression object], page 708 |
| `number` | 4 | 跟踪点的编号 |
| `address` | 8 | 插入跟踪点的地址 |
| `type` | 4 | 跟踪点的类型 |
| `enabled` | 1 | 跟踪点的启用或禁用 |
| `step_count` | 8 | 步骤计数 |
| `pass_count` | 8 | 通过计数 |
| `numactions` | 4 | 跟踪点操作的数量 |
| `hit count` | 8 | 命中计数 |
| `trace frame usage` | 8 | 跟踪帧使用情况 |
| `compiled_cond` | 8 | 编译条件 |
| `orig_size` | 8 | 原始大小 |
| `condition` | 4 如果条件为 `NULL`，否则为 NULL `[agent expression object]` 的长度，第 708 页  | 如果条件为 `NULL`，否则为 NULL `[agent expression object]` 的长度，第 708 页 |
| `actions` | variable  | numactions number of [tracepoint action object], page 708 |

### 31.1.2 IPA协议命令

每个命令中的空格是分隔符，以便于阅读此命令规范。它们在实际命令中并不存在。

```
`FastTrace:tracepoint_object gdb_jump_pad_head`
	安装一个由跟踪点对象描述的新快速跟踪点（见[跟踪点对象]，第 708 页）。gdb 跳转填充头，8 字节长，是跳转填充的头部，最终用于跳转到 IPA 中的数据收集例程。
	
	回复：`OK target_address gdb_jump_pad_head fjump_size fjump`
			目标地址是下级中的跟踪点地址。gdb 跳转填充头是更新后的跳转填充头。目标地址和 gdb 跳转填充头均为 8 字节长。fjump 包含跳转到跳转填充入口的指令序列。fjump 大小，4 字节长，是 fjump 的大小。

`close`
	关闭进程内代理。当 gdb 或 GDBserver 即将终止下级时发送此命令。

`qTfSTM`
	见[qTfSTM]，第 824 页。

`qTsSTM`
	见[qTsSTM]，第 824 页。

`qTSTMat`
	见[qTSTMat]，第 824 页。

`probe_marker_at:address`
	请求进程内代理在地址处探测标记。
	回复：

`unprobe_marker_at:address`
	请求进程内代理在地址处取消探测标记。	
```