# 6 反向运行程序

当您调试程序时，经常会发现自己走得太远，而某些感兴趣的事件已经发生。如果目标环境支持，gdb 可以允许您通过反向运行程序来“倒带”。

支持反向执行的目标环境应该能够“撤销”程序正常执行时发生的机器状态变化。变量、寄存器等应恢复到其先前的值。显然，这需要目标环境具备高度的复杂性；并非所有目标环境都支持反向执行。

当程序反向执行时，最近执行的指令会以相反的顺序“未执行”。程序计数器反向运行，遵循之前执行的线程的逆序。当每条指令“未执行”时，该指令更改的内存和/或寄存器的值将恢复到先前的状态。在反向执行一段源代码后，该代码的所有副作用都应“撤销”，所有变量都应恢复到之前的值。

在某些平台上，gdb 通过 `record` 或 `record btrace` 命令内置支持反向执行。请参见第 7 章 [进程记录和重放]，第 103 页。

一些远程目标，通常是完整的系统模拟器，直接支持反向执行，无需任何特殊命令。

如果您在支持反向执行的目标环境中进行调试，gdb 提供了以下命令：

## `reverse-continue [ignore-count]`
## `rc [ignore-count]`

从程序上次停止的点开始反向执行。反向执行会像正常执行一样在断点和同步异常（信号）处停止。异步信号的行为取决于目标环境。

## `reverse-step [count]`

反向运行程序，直到控制到达不同的源代码行的开头；然后停止，并将控制权返回给 gdb。

与 `step` 命令一样，`reverse-step` 只会在源代码行的开头停止。它“未执行”先前执行的源代码行。如果先前的源代码行包括对可调试函数的调用，`reverse-step` 将反向步入被调用的函数，在被调用函数的最后一个语句（通常是返回语句）的开头停止。

同样，与 `step` 命令一样，如果调用了不可调试的函数，`reverse-step` 将反向运行它们而不停止。

## `reverse-stepi [count]`

反向执行一条机器指令。请注意，要反向执行的指令不是程序计数器指向的指令，而是在此之前执行的指令。例如，如果最后一条指令是跳转，`reverse-stepi` 将带您从跳转的目的地返回到跳转指令本身。

## `reverse-next [count]`

反向运行到当前（最内层）栈帧中执行的前一行的开头。如果该行包含函数调用，它们将在不停止的情况下“未执行”。从函数的第一行开始，`reverse-next` 将带您返回到调用该函数的位置，即在函数被调用之前，就像普通的 `next` 命令会将您从函数的最后一行带回其返回给调用者一样。

## `reverse-nexti [count]`

与 `nexti` 类似，`reverse-nexti` 反向执行一条指令，不同之处在于被调用的函数是“原子地未执行”。也就是说，如果先前执行的指令是从另一个函数返回，`reverse-nexti` 将继续反向执行，直到到达（从当前栈帧）对该函数的调用。

## `reverse-finish`

正如 `finish` 命令会带您到当前函数返回的点，`reverse-finish` 会带您到它被调用的点。您不是在当前函数调用的末尾结束，而是在开头结束。

## `set exec-direction`

设置目标执行的方向。

## `set exec-direction reverse`

gdb 将反向执行所有执行命令，直到 `exec-direction` 模式更改为“forward”。受影响的命令包括 `step`、`stepi`、`next`、`nexti`、`continue` 和 `finish`。`return` 命令不能在反向模式下使用。

## `set exec-direction forward`

gdb 将以正常方式执行所有执行命令。这是默认设置。