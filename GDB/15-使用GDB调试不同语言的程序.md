# 15 使用 gdb 调试不同语言的程序

虽然编程语言通常有共同的方面，但它们很少以相同的方式表达。例如，在 ANSI C 中，解引用指针 `p` 是通过 `*p` 完成的，但在 Modula-2 中，是通过 `p^` 完成的。值的表示（和显示）方式也可能不同。C 中的十六进制数显示为 `0x1ae`，而在 Modula-2 中显示为 `1AEH` 。

对于某些语言，gdb 内置了特定于语言的信息，允许您以程序的原生语言表达上述操作，并允许 gdb 以与程序原生语言的语法一致的方式输出值。您用于构建表达式的语言称为工作语言。

## 15.1 在源语言之间切换

有两种控制工作语言的方法 - 要么让 gdb 自动设置，要么手动选择。您可以使用 `set language` 命令实现这两个目的。

启动时，gdb 默认自动设置语言。工作语言用于确定如何解释您输入的表达式、如何打印值等。

除了工作语言外，gdb 所知的每个源文件都有其自己的工作语言。对于某些目标文件格式，编译器可能会指示特定源文件的语言。然而，大多数时候 gdb 从文件的名称推断语言。源文件的语言控制是否对 C++ 名称进行反混淆 - 这样回溯可以为每个帧以其自身的语言适当显示。

在 gdb 内部无法设置源文件的语言，但您可以设置与文件名扩展名相关的语言。请参见第 15.2 节[显示语言]，第 229 页。

这在您使用诸如 cfront 或 f2c 之类的程序时最常见，这些程序生成 C 代码但本身是用另一种语言编写的。在这种情况下，让程序在其 C 输出中使用 `#line` 指令；这样 gdb 将知道原始程序源代码的正确语言，并将显示该源代码，而不是生成的 C 代码。

### 15.1.1 文件名扩展名和语言列表

如果源文件名以下列扩展名之一结尾，则 gdb 推断其语言为所示的语言。
```
	.ada
	.ads
	.adb
	.a            Ada source file.
	.c            C source file
	.C
	.cc
	.cp
	.cpp
	.cxx
	.c++          C++ source file
	.d            D source file
	.m            Objective-C source file
	.f
	.F            Fortran source file
	.mod          Modula-2 source file
	.s
	.S            汇编源文件。实际上其行为几乎与 C 相同，但 gdb 在单步执行时不会跳过函数序言。
```
此外，您可以设置与文件名扩展名相关的语言。请参见第 15.2 节[显示语言]，第 229 页。

### 15.1.2 设置工作语言

如果允许 gdb 自动设置语言，则调试会话和程序中的表达式将以相同的方式解释。

如果愿意，您可以手动设置语言。为此，请发出命令 `set language lang`，其中 `lang` 是语言的名称，例如 `c` 或 `modula-2`。要获取支持的语言列表，请输入 `set language` 。

手动设置语言会阻止 gdb 自动更新工作语言。如果在工作语言与源语言不同的情况下尝试调试程序，并且表达式对两种语言都可接受 - 但含义不同，这可能会导致混淆。例如，如果当前源文件是用 C 编写的，而 gdb 正在解析 Modula-2，如下命令：

```
print a = b + c
```

可能不会产生您预期的效果。在 C 中，这意味着将 `b` 和 `c` 相加并将结果放入 `a` 中。打印的结果将是 `a` 的值。在 Modula-2 中，这意味着将 `a` 与 `b + c` 的结果进行比较，产生一个布尔值。

### 15.1.3 让 gdb 推断源语言

要让 gdb 自动设置工作语言，请使用 `set language local` 或 `set language auto` 。然后 gdb 会推断工作语言。也就是说，当您的程序在一个帧中停止（通常是遇到断点）时，gdb 将工作语言设置为该帧中函数记录的语言。如果一个帧的语言未知（即，如果与该帧对应的函数或块是在没有被识别的扩展名的源文件中定义的），则当前工作语言不会更改，并且 gdb 会发出警告。

对于大多数完全用一种源语言编写的程序，这似乎没有必要。然而，用一种源语言编写的程序模块和库可以被用不同源语言编写的主程序使用。在这种情况下使用 `set language auto` 可以使您不必手动设置工作语言。

默认情况下启用警告，但可以通过以下设置进行控制：

```
set warn-language-frame-mismatch [on|off]
	启用或禁用当当前语言设置为与当前帧不匹配的值时发出的警告。

show warn-language-frame-mismatch
	显示是否将发出帧不匹配的警告。
```


## 15.2 显示语言

以下命令有助于您了解当前的工作语言，以及源文件所使用的语言。
```
show language
	显示当前的工作语言。这是您可以在诸如 `print` 等命令中使用的语言，用于构建和计算可能涉及程序中变量的表达式。

info frame
	显示此帧的源语言。如果您使用此帧中的标识符，该语言将成为工作语言。请参见第 8.4 节[关于帧的信息]，第 119 页，以确定此处列出的其他信息。

info source
	显示此源文件的源语言。请参见第 16 章[检查符号表]，第 263 页，以确定此处列出的其他信息。
```
在不寻常的情况下，您可能有源文件的扩展名不在标准列表中。然后，您可以显式设置与语言相关联的扩展名：
```
set extension-language ext language
	告诉 gdb 具有扩展名 `ext` 的源文件应假定为使用 `language` 源语言编写。

info extensions
	列出所有文件名扩展名和相关联的语言。
```

## 15.3 类型和范围检查

某些语言旨在通过一系列编译时和运行时检查来防止您犯看似常见的错误。这些包括检查函数和操作符的参数类型，并确保在运行时捕获数学溢出。

这些检查有助于在编译后确保程序的正确性，消除类型不匹配，并在程序运行时对范围错误进行主动检查。

默认情况下，gdb 根据当前源语言的规则检查这些错误。尽管 gdb 不检查程序中的语句，但它可以检查直接输入到 gdb 中通过 `print` 命令进行求值的表达式等。

### 15.3.1 类型检查概述

一些语言，如 C 和 C++，是强类型的，这意味着操作符和函数的参数必须是正确的类型，否则会发生错误。这些检查可防止类型不匹配错误在运行时造成任何问题。例如：

```c
int klass::my_method(char *b) { return b? 1 : 2; }
(gdb) print obj.my_method (0)
$1 = 2
```

但是

```
(gdb) print obj.my_method (0x1234)
Cannot resolve method klass::my_method to any overloaded instance
```

第二个示例失败，因为在 C++ 中，整数常量 `0x1234` 与指针参数类型不兼容。

对于在 gdb 命令中使用的表达式，您可以告诉 gdb 不执行严格的类型检查，或将任何不匹配视为错误并放弃表达式；当类型检查被禁用时，gdb 可以成功地计算像上面第二个示例这样的表达式。

即使类型检查关闭，也可能有其他与类型相关的原因导致 gdb 无法计算表达式。例如，gdb 不知道如何将一个 `int` 和一个 `struct foo` 相加。这些特定的类型错误与使用的语言无关，通常源于无论如何都没有意义计算的表达式。

gdb 提供了一些用于控制类型检查的附加命令：
```
set check type on
set check type off
	打开或关闭严格的类型检查。如果在类型检查打开时计算表达式时发生任何类型不匹配，gdb 会打印消息并中止表达式的计算。

show check type
	显示类型检查的当前设置以及 gdb 是否执行严格的类型检查规则。
```
### 15.3.2 范围检查概述

在某些语言（如 Modula-2）中，超过类型的边界是错误的；这通过运行时检查来强制执行。这种范围检查旨在通过确保计算不会溢出或数组元素访问的索引不会超过数组的边界来确保程序的正确性。

对于在 gdb 命令中使用的表达式，您可以告诉 gdb 以以下三种方式之一处理范围错误：忽略它们，始终将它们视为错误并放弃表达式，或发出警告但仍计算表达式。

范围错误可能由数值溢出、超过数组索引边界或输入不属于任何类型的常量引起。然而，某些语言不将溢出视为错误。在许多 C 实现中，数学溢出会导致结果“回绕”到较低的值 - 例如，如果 `m` 是最大整数值，`s` 是最小整数值，那么
```
m + 1 ⇒ s
```
这也是特定于个别语言的，在某些情况下特定于个别编译器或机器。有关特定语言的更多详细信息，请参见第 15.4 节[支持的语言]，第 231 页。

gdb 提供了一些用于控制范围检查器的附加命令：
```
set check range auto
	根据当前工作语言打开或关闭范围检查。有关每种语言的默认设置，请参见第 15.4 节[支持的语言]，第 231 页。

set check range on
set check range off
	打开或关闭范围检查，覆盖当前工作语言的默认设置。如果设置与语言默认设置不匹配，则会发出警告。如果发生范围错误且范围检查已打开，则会打印消息并中止表达式的计算。

set check range warn
	当 gdb 范围检查器检测到范围错误时输出消息，但仍尝试计算表达式。由于其他原因（例如访问进程不拥有的内存），计算表达式可能仍然不可能（这是许多 Unix 系统的典型示例）。

show check range
	显示范围检查器的当前设置，以及它是否由 gdb 自动设置。
```

## 15.4 支持的语言

gdb 支持 C、C++、D、Go、Objective-C、Fortran、OpenCL C、Pascal、Rust、汇编、Modula-2 和 Ada。无论您使用何种语言，某些 gdb 功能都可以在表达式中使用：gdb 的 `@` 和 `::` 运算符，以及 `{type}addr` 构造（请参见第 10.1 节[表达式]，第 145 页）可以与任何支持的语言的构造一起使用。

以下各节详细说明了 gdb 对每种源语言的支持程度。这些部分并非语言教程或参考，而仅作为 gdb 表达式解析器接受的内容以及不同语言的输入和输出格式的参考指南。关于这些语言中的每一种都有很多优秀的书籍；请参考这些书籍以获取语言参考或教程。

### 15.4.1 C 和 C++

由于 C 和 C++ 密切相关，gdb 的许多功能适用于这两种语言。只要是这种情况，我们就一起讨论这些语言。

C++ 的调试功能由 C++ 编译器和 gdb 共同实现。因此，要有效地调试 C++ 代码，必须使用支持的 C++ 编译器（如 gnu g++ 或 HP ANSI C++ 编译器（aCC））编译 C++ 程序。

#### 15.4.1.1 C 和 C++ 运算符

运算符必须针对特定类型的值进行定义。例如，`+` 定义在数字上，但不在结构体上。运算符通常针对一组类型进行定义。

对于 C 和 C++，以下定义成立：

• 整数类型包括具有任何存储类说明符的 `int`；`char`；`enum`；对于 C++，还有 `bool`。

• 浮点类型包括 `float`、`double` 和（如果目标平台支持）`long double`。

• 指针类型包括所有定义为 `(type *)` 的类型。

• 标量类型包括以上所有类型。

以下运算符受支持。它们按优先级升序排列在此列出：
```
,               逗号或序列运算符。逗号分隔列表中的表达式从左到右求值，整个表达式的结果是最后求值的表达式。
=               赋值。赋值表达式的值是所赋的值。定义在标量类型上。
op=             用于形式为 `a op= b` 的表达式，并转换为 `a = a op b`。`op=` 和 `=` 具有相同的优先级。运算符 `op` 可以是 `|`、`^`、`&`、`<<`、`>>`、`+`、`-`、`*`、`/`、`%` 中的任何一个。
?:              三元运算符。`a? b : c` 可以被认为是：如果 `a` 为真则为 `b`，否则为 `c`。参数 `a` 应为整数类型。
||              逻辑或。定义在整数类型上。	                  
&&              逻辑与。定义在整数类型上。	                  
|               按位或。定义在整数类型上。	                  
^               按位异或。定义在整数类型上。	                  
&               按位与。定义在整数类型上。
==,!=           相等和不相等。定义在标量类型上。这些表达式的值为 0 表示假，非 0 表示真。
<,>,<=,>=       小于、大于、小于等于、大于等于。定义在标量类型上。这些表达式的值为 0 表示假，非 0 表示真。
<<,>>           左移和右移。定义在整数类型上。
@               gdb 的“人工数组”运算符（请参见第 10.1 节[表达式]，第 145 页）。		              
+,-             加法和减法。定义在整数类型、浮点类型和指针类型上。
*,/,%           乘法、除法和取模。乘法和除法定义在整数和浮点类型上。取模定义在整数类型上。
++,--           递增和递减。当出现在变量之前时，在表达式中使用变量之前执行操作；当出现在变量之后时，在操作发生之前使用变量的值。
*               指针解引用。定义在指针类型上。与 ++ 具有相同的优先级。	                  
&               地址运算符。定义在变量上。与 ++ 具有相同的优先级。
                对于调试 C++，gdb 实现了 & 的一种超出 C++ 语言本身允许的用法：您可以使用 &(&ref) 来检查 C++ 引用变量（使用 &ref 声明）的存储地址。
-               负号。定义在整数和浮点类型上。与 ++ 具有相同的优先级。	                  
!               逻辑非。定义在整数类型上。与 ++ 具有相同的优先级。	                  
~               按位取反运算符。定义在整数类型上。与 ++ 具有相同的优先级。
.,->            结构体成员和指向结构体的成员。为了方便，gdb 将两者视为等效，根据存储的类型信息决定是否解引用指针。定义在 struct 和 union 数据上。
.*,->*          指向成员的指针的解引用。
[]              数组索引。a[i] 定义为 *(a + i)。与 -> 具有相同的优先级。	                  
()              函数参数列表。与 -> 具有相同的优先级。	                  
::              C++ 作用域解析运算符。定义在 struct、union 和 class 类型上。	                  
::              双冒号也表示 gdb 作用域运算符（请参见第 10.1 节[表达式]，第 145 页）。与上面的 :: 具有相同的优先级。
```
如果在用户代码中重新定义了运算符，gdb 通常会尝试调用重新定义的版本，而不是使用运算符的预定义含义。

#### 15.4.1.2 C 和 C++ 常量

gdb 允许您以以下方式表示 C 和 C++ 的常量：
```
• 整数常量是数字序列。八进制常量由前导的 0（即零）指定，十六进制常量由前导的 0x 或 0X 指定。常量也可以以字母 l 结尾，指定该常量应被视为长值。
• 浮点常量是数字序列，后跟小数点，再后跟数字序列，并且可以选择后跟指数。指数的形式为：e[[+]|-]nnn，其中 nnn 是另一个数字序列。对于正指数，+ 是可选的。浮点常量也可以以字母 f 或 F 结尾，指定该常量应被视为 float 类型（而不是默认的 double 类型）；或者以字母 l 或 L 结尾，指定为 long double 常量。
• 枚举常量由枚举标识符或其整数等效值组成。
• 字符常量是由单引号（'）括起来的单个字符，或一个数字 - 对应字符的序数值（通常是其 ASCII 值）。在引号内，单个字符可以由字母或转义序列表示，转义序列的形式为 \nnn，其中 nnn 是字符序数值的八进制表示；或者形式为 \x，其中 x 是预定义的特殊字符 - 例如，\n 表示换行符。宽字符常量可以通过在字符常量前加上 L 来编写，如在 C 中。例如，L'x' 是 'x' 的宽形式。计算此常量的值时使用目标宽字符集（请参见第 10.21 节[字符集]，第 187 页）。
• 字符串常量是由双引号（"）括起来的字符常量序列。可以出现任何有效的字符常量（如上所述）。字符串内的双引号必须前面有反斜杠，因此例如 “a\"b'c” 是五个字符的字符串。宽字符串常量可以通过在字符串常量前加上 L 来编写，如在 C 中。计算此常量的值时使用目标宽字符集（请参见第 10.21 节[字符集]，第 187 页）。
• 指针常量是整数值。您还可以使用 C 运算符 & 编写指向常量的指针。
• 数组常量是由大括号 { 和 } 括起来的逗号分隔的列表；例如，{1, 2, 3} 是一个整数的三元数组，{{1, 2}, {3, 4}, {5, 6}} 是一个三行两列的数组，{&"hi", &"there", &"fred"} 是一个指针的三元数组。
```
#### 15.4.1.3 C++ 表达式

gdb 表达式处理可以解释大多数 C++ 表达式。

警告：只有使用正确的编译器和正确的调试格式，gdb 才能调试 C++ 代码。目前，在使用 gcc 可能的最新版本编译 C++ 代码时，gdb 效果最佳。首选 DWARF 调试格式；在大多数流行平台上，gcc 默认使用此格式。其他编译器和/或调试格式在使用 gdb 调试 C++ 代码时可能效果不佳或根本无法工作。请参见第 4.1 节[编译]，第 33 页。
```
1.  允许成员函数调用；您可以使用类似于 count = aml->GetOriginal(x, y) 的表达式。
2.  当成员函数处于活动状态（在选定的栈帧中）时，您的表达式具有与成员函数相同的命名空间；也就是说，gdb 按照与 C++ 相同的规则允许对类实例指针 this 的隐式引用。gdb 也尊重当前作用域中的 using 声明。
3.  您可以调用重载函数；gdb 会在一定限制下将函数调用解析到正确的定义。gdb 不执行涉及用户定义类型转换、对构造函数的调用或程序中不存在的模板实例化的重载解析。它也无法处理省略号参数列表或默认参数。它执行整数转换和提升、浮点提升、算术转换、指针转换、类对象到基类的转换以及函数或数组到指针等标准转换；它要求函数参数的数量完全匹配。
	除非您指定了 set overload-resolution off，否则始终执行重载解析。请参见第 15.4.1.7 节[C++ 的 gdb 特性]，第 235 页。
	为了使用显式函数签名调用重载函数，您必须指定 set overload-resolution off，例如 p 'foo(char,int)'('x', 13) 。
	gdb 的命令完成功能可以简化此操作；请参见第 3.3 节[命令完成]，第 24 页。
4.  gdb 理解声明为 C++ 左值或右值引用的变量；您可以在表达式中使用它们，就像在 C++ 源代码中一样 - 它们会自动解引用。
	在 gdb 显示帧时显示的参数列表中，引用变量的值不会显示（与其他变量不同）；这避免了混乱，因为引用通常用于大型结构。除非您指定了 set print address off，否则始终显示引用变量的地址。
5.  gdb 支持 C++ 名称解析运算符 :: - 您的表达式可以像在程序中的表达式一样使用它。由于一个作用域可能在另一个作用域中定义，因此如果需要，您可以多次使用 ::，例如在表达式 scope1::scope2::name 中。
	gdb 还允许在 C 和 C++ 调试中通过引用源文件来解析名称作用域（请参见第 10.3 节[程序变量]，第 147 页）。
6.  gdb 执行依赖于参数的查找，遵循 C++ 规范。
```

#### 15.4.1.4 C 和 C++ 默认值

如果允许 gdb 自动设置范围检查，当工作语言更改为 C 或 C++ 时，它默认关闭。无论您还是 gdb 选择工作语言，都会发生这种情况。

如果允许 gdb 自动设置语言，它会识别名称以 `.c`、`.C` 或 `.cc` 等结尾的源文件，当 gdb 进入从这些文件之一编译的代码时，它会将工作语言设置为 C 或 C++。有关更多详细信息，请参见第 15.1.3 节[让 gdb 推断源语言]，第 228 页。

#### 15.4.1.5 C 和 C++ 类型和范围检查

默认情况下，当 gdb 解析 C 或 C++ 表达式时，使用严格的类型检查。但是，如果关闭类型检查，gdb 将允许某些非标准转换，例如将整数常量提升为指针。

如果打开范围检查，则对数学运算进行检查。不检查数组索引，因为它们经常用于索引本身不是数组的指针。

#### 15.4.1.6 gdb 和 C

`set print union` 和 `show print union` 命令适用于联合类型。当设置为 `on` 时，结构体或类内部的任何联合也会被打印。否则，它显示为 `{...}` 。

`@` 运算符有助于调试使用指针和内存分配函数形成的动态数组。请参见第 10.1 节[表达式]，第 145 页。

#### 15.4.1.7 C++ 的 gdb 特性

一些 gdb 命令在 C++ 中特别有用，有些则专门为 C++ 设计。以下是总结：

```
breakpoint menus
	当您希望在名称重载的函数中设置断点时，gdb 能够显示可能的断点位置菜单，以帮助您指定要的函数定义。请参见第 10.2 节[模糊表达式]，第 146 页。

rbreak regex
	使用正则表达式设置断点对于在非特殊类的重载函数上设置断点很有帮助。请参见第 5.1.1 节[设置断点]，第 58 页。

catch throw
catch rethrow
catch catch
	使用这些命令调试 C++ 异常处理。请参见第 5.1.3 节[设置捕获点]，第 69 页。

ptype typename
	打印 `typename` 类型的继承关系以及其他信息。请参见第 16 章[检查符号表]，第 263 页。

info vtbl expression
	info vtbl 命令可用于显示由表达式计算的对象的虚方法表。这为每个虚表显示一个条目；当使用多重继承时可能有多个虚表。

demangle name
	对 `name` 进行反混淆。有关 `demangle` 命令的更完整描述，请参见第 16 章[符号]，第 263 页。

set print demangle
show print demangle
set print asm-demangle
show print asm-demangle
	控制 C++ 符号在显示为 C++ 源代码和显示反汇编时是否以其源形式显示。请参见第 10.9 节[打印设置]，第 157 页。

set print object
show print object
	选择是打印对象的派生（实际）类型还是声明类型。请参见第 10.9 节[打印设置]，第 157 页。

set print vtbl
show print vtbl
	控制打印虚函数表的格式。请参见第 10.9 节[打印设置]，第 157 页。（`vtbl` 命令在使用 HP ANSI C++ 编译器（aCC）编译的程序上不起作用。）

set overload-resolution on
	启用 C++ 表达式求值的重载解析。默认是启用的。对于重载函数，gdb 计算参数并使用标准 C++ 转换规则搜索与参数类型匹配的函数（有关详细信息，请参见第 15.4.1.3 节[C++ 表达式]，第 234 页）。如果找不到匹配项，它会发出消息。

set overload-resolution off
	禁用 C++ 表达式求值的重载解析。对于非类成员函数的重载函数，gdb 选择符号表中找到的指定名称的第一个函数，无论其参数类型是否正确。对于类成员函数的重载函数，gdb 搜索签名与参数类型完全匹配的函数。

show overload-resolution
	显示重载解析的当前设置。
```

**重载符号名称**

您可以使用与在 C++ 中声明此类符号相同的符号来指定重载符号的特定定义：`type symbol(types)` 而不仅仅是 `symbol` 。您还可以使用 gdb 命令行的单词完成功能列出可用选项或为您完成类型列表。有关如何执行此操作的详细信息，请参见第 3.3 节[命令完成]，第 24 页。

**模板函数中的断点**

与处理重载符号类似，当 gdb 遇到包含 C++ 模板的符号时，它将忽略模板参数列表。这允许在模板函数族或参数包含模板类型的函数上设置断点。

可以使用 `-qualified` 标志覆盖此行为，导致 gdb 搜索特定的函数或类型。

gdb 命令行的单词完成功能也理解模板参数，并可用于为您列出可用选项或完成模板参数列表。有关如何执行此操作的详细信息，请参见第 3.3 节[命令完成]，第 24 页。

**具有 ABI 标签的函数中的断点**

GNU C++ 编译器引入了 ABI“标签”的概念，它对应于类型、函数或变量的 ABI 的更改，否则这些更改不会反映在混淆的名称中。有关更多详细信息，请参见 https://developers.redhat.com/blog/2015/02/05/gcc5-and-the-c11-abi/ 。

ABI 标签在 C++ 反混淆名称中可见。例如，一个返回 `std::string` 的函数：

```cpp
std::string function(int);
```

当为 C++11 ABI 编译时，用 `cxx11` ABI 标签标记，gdb 显示该符号如下：

```
function[abi:cxx11](int)
```

您可以像没有标签一样简单地在这样的函数上设置断点。例如：

```
(gdb) b function(int)
Breakpoint 2 at 0x40060d: file main.cc, line 10.
(gdb) info breakpoints
Num Type Disp Enb Address What
1 breakpoint keep y 0x0040060d in function[abi:cxx11](int)
at main.cc:10
```

在极少数需要在不同的 ABI 标签之间进行区分的情况下，您可以通过在函数名称中包含 ABI 标签来实现，例如：

```
(gdb) b ambiguous[abi:other_tag](int)
```

#### 15.4.1.8 十进制浮点数格式

gdb 可以检查、设置和使用十进制浮点数格式的数字进行计算，在 C 语言中，这对应于支持十进制浮点运算扩展所指定的 `_Decimal32`、`_Decimal64` 和 `_Decimal128` 类型。

根据架构的不同，有两种编码在使用：对于 x86 和 x86-64 是 BID（Binary Integer Decimal），对于 PowerPC 和 S/390 是 DPD（Densely Packed Decimal）。gdb 将为配置的目标使用适当的编码。

由于 `libdecnumber`（gdb 用于操作十进制浮点数的库）的限制，无法将大于 32 位的整数（例如使用强制转换）转换为十进制浮点数。

此外，为了模拟 gdb 在二进制浮点计算中的行为，十进制浮点数运算中的错误检查忽略下溢、上溢和除以零异常。

在 PowerPC 架构中，gdb 提供了一组伪寄存器来检查存储在浮点寄存器中的 `_Decimal128` 值。有关更多详细信息，请参见第 21.4.6 节[PowerPC]，第 361 页。

### 15.4.2 D

gdb 可用于调试用 D 编写并用 GDC、LDC 或 DMD 编译器编译的程序。目前 gdb 仅支持一个 D 特定的功能 - 动态数组。

### 15.4.3 Go

gdb 可用于调试用 Go 编写并用 gccgo 或 6g 编译器编译的程序。以下是 Go 特定功能和限制的总结：

**当前 Go 包**

在指定全局变量和函数时，不需要指定当前包的名称。

例如，给定程序：

```go
package main

var myglob = "Shall we?"

func main() {
    //...
}
```

当在 `main` 函数内停止时，以下两种方式都有效：

```
(gdb) p myglob
(gdb) p main.myglob
```

**内置 Go 类型**

gdb 识别字符串类型，并将其作为字符串打印。

**内置 Go 函数**

gdb 表达式解析器识别 `unsafe.Sizeof` 函数并在内部处理它。

**Go 表达式的限制**

除了 `&^` 之外，所有 Go 运算符都受支持。Go 的 `_`（“空白标识符”）不受支持。指针的自动解引用不受支持。

### 15.4.4 Objective-C

本节提供了有关一些命令和命令选项的信息，这些命令和选项对于调试 Objective-C 代码很有用。另请参见第 16 章[符号]，第 263 页，以及第 16 章[符号]，第 263 页，以获取更多特定于 Objective-C 支持的命令。

#### 15.4.4.1 命令中的方法名称

以下命令已扩展为接受 Objective-C 方法名称作为行规范：

• `clear`

• `break`

• `info line`

• `jump`

• `list`

一个完全限定的 Objective-C 方法名称指定为：

`-[Class methodName]`

其中减号用于表示实例方法，加号（未显示）用于表示类方法。类名 `Class` 和方法名 `methodName` 括在方括号中，类似于在 Objective-C 源代码中指定消息的方式。例如，要在当前正在调试的程序中的 `Fruit` 类的 `create` 实例方法处设置断点，请输入：

```
break -[Fruit create]
```

要在 `initialize` 类方法周围列出十个程序行，请输入：

```
list +[NSText initialize]
```

在当前版本的 gdb 中，加号或减号是必需的。在未来版本的 gdb 中，加号或减号将是可选的，但您可以使用它来缩小搜索范围。也可以只指定方法名称：

```
break create
```

您必须指定完整的方法名称，包括任何冒号。如果您的程序的源文件包含多个 `create` 方法，您将获得一个实现该方法的类的编号列表。通过编号指示您的选择，或者输入 `0` 退出，如果没有适用的。

另一个示例，要清除在 `NSWindow` 类的 `makeKeyAndOrderFront:` 方法处建立的断点，请输入：

```
clear -[NSWindow makeKeyAndOrderFront:]
```

#### 15.4.4.2 Objective-C 的打印命令

`print` 命令也已扩展为接受方法。例如：

```
print -[object hash]
```

这将告诉 gdb 向 `object` 发送 `hash` 消息并打印结果。此外，还添加了一个额外的命令 `print-object` 或简称 `po`，用于打印对象的描述。然而，此命令可能仅适用于某些定义了特定挂钩函数 `_NSPrintForDebugger` 的 Objective-C 库。

### 15.4.5 OpenCL C

本节提供有关 gdb 的 OpenCL C 支持的信息。

#### 15.4.5.1 OpenCL C 数据类型

gdb 支持 OpenCL 1.1 指定的内置标量和向量数据类型。此外，gdb 还知道 `cl_khr_fp16` 和 `cl_khr_fp64` OpenCL 扩展的半精度和双精度浮点数据类型。

#### 15.4.5.2 OpenCL C 表达式

gdb 支持对向量组件的访问，包括在可能的情况下作为左值的访问。由于 OpenCL C 基于 C99，gdb 支持的大多数 C 表达式也可以使用。

#### 15.4.5.3 OpenCL C 运算符

gdb 支持 OpenCL 1.1 为标量和向量数据类型指定的运算符。

### 15.4.6 Fortran

gdb 可用于调试用 Fortran 编写的程序。请注意，并非所有 Fortran 语言功能都可用。

一些 Fortran 编译器（其中包括 gnu Fortran 77 和 Fortran 95 编译器）会在变量和函数的名称后附加一个下划线。当调试由这些编译器编译的程序时，您需要使用带有尾随下划线的变量和函数。

Fortran 符号通常不区分大小写，因此 gdb 默认对 Fortran 符号进行不区分大小写的匹配。您可以使用 `set case-insensitive` 命令更改此设置，有关详细信息，请参见第 16 章[符号]，第 263 页。

#### 15.4.6.1 Fortran 类型

在 Fortran 中，原始数据类型具有相关联的 `KIND` 类型参数，写为 `‘type*kindparam’`、`‘type(kind=kindparam)’` 或在 gdb 专用的方言中 `‘type_kindparam’`。一个具体的例子是 `‘Real*4’`、`‘Real(kind=4)’` 和 `‘Real_4’`。类型的 `KIND` 可以通过使用内在函数 `KIND` 来获取，有关详细信息，请参见第 15.4.6.3 节[Fortran 内在函数]，第 241 页。

通常，`KIND` 类型参数的实际实现是编译器特定的。在 gdb 中，`KIND` 参数是根据其在 gnu gfortran 编译器中的使用来实现的。在这里，给定类型的 `KIND` 参数指定其在内存中的大小 - Fortran 的 `Integer*4` 或 `Integer(kind=4)` 将是一个占用 4 字节内存的整数类型。

此规则的一个例外是 `Complex` 类型，其类型的 `KIND` 不指定其整个大小，而是它所组成的两个 `Real` 的大小。因此，`Complex*4` 将由两个 `Real*4` 组成，并占用 8 字节的内存。

对于每种类型，也有与其相关联的默认 `KIND`，例如，在 gdb 中 `Integer` 内部将是 `Integer*4`（请参见下面的默认类型表）。默认类型与 gnu 编译器中的相同，但请注意，gnu 编译器的默认类型实际上可以通过编译器标志（如 `-fdefault-integer-8` 和 `-fdefault-real-8`）进行更改。

并非每个 `KIND` 参数对每种类型都有效，在 gdb 中，以下类型 `KIND` 可用。

`Integer`：`Integer*1`、`Integer*2`、`Integer*4`、`Integer*8`，并且 `Integer = Integer*4`。

`Logical`：`Logical*1`、`Logical*2`、`Logical*4`、`Logical*8`，并且 `Logical = Logical*4`。

`Real`：`Real*4`、`Real*8`、`Real*16`，并且 `Real = Real*4`。

`Complex`：`Complex*4`、`Complex*8`、`Complex*16`，并且 `Complex = Complex*4`。

#### 15.4.6.2 Fortran 运算符和表达式

运算符必须针对特定类型的值进行定义。例如，`+` 定义在数字上，但不在字符或其他非算术类型上。运算符通常针对一组类型进行定义。

** 指数运算符。它将第一个操作数提升到第二个操作数的幂次。

`:` 范围运算符。通常以 `array(low:high)` 的形式使用，表示数组的一部分。

`%` 访问组件运算符。通常用于访问派生类型中的元素。也适用于联合。由于联合不是常规 Fortran 的一部分，这只能在访问使用 gdbarch 定义的联合类型的寄存器时发生。

`::` 作用域运算符。通常用于访问模块中的变量或在模块中的子程序或其他子程序（内部子程序）上设置断点。

#### 15.4.6.3 Fortran 内在函数

Fortran 提供了大量的内在过程。gdb 实现了这些过程及其重载的不完整子集。其中一些过程接受可选的 `KIND` 参数，有关详细信息，请参见第 15.4.6.1 节[Fortran 类型]，第 240 页。
```
ABS(a)                             计算其参数 `a` 的绝对值。目前不支持复数参数。
ALLOCATE(array)                    返回 `array` 是否已分配。
ASSOCIATED(pointer [, target])     返回指针 `pointer` 的关联状态，或者如果存在 `target`，则返回 `pointer` 是否与 `target` 相关联。
CEILING(a [, kind])                计算大于或等于 `a` 的最小整数。可选参数 `kind` 指定返回类型 `Integer(kind)` 的 `KIND`。
CMPLX(x [, y [, kind]])            返回一个复数，其中 `x` 转换为实部。如果存在 `y`，则将其转换为虚部。如果 `y` 不存在，则虚部设置为 `0.0`，除非 `x` 本身是复数类型。可选参数 `kind` 指定返回类型 `Complex(kind)` 的 `KIND`。
FLOOR(a [, kind])                  计算小于或等于 `a` 的最大整数。可选参数 `kind` 指定返回类型 `Integer(kind)` 的 `KIND`。
KIND(a)                            返回参数 `a` 的 `KIND` 值，请参见第 15.4.6.1 节[Fortran 类型]，第 240 页。
LBOUND(array [, dim [, kind]])     返回数组的下限，或者如果存在 `dim`，则返回沿 `dim` 维度的单个下限。可选参数 `kind` 指定返回类型 `Integer(kind)` 的 `KIND`。
LOC(x)                             返回 `x` 的地址作为整数。
MOD(a, p)                          计算 `a` 除以 `p` 的余数。
MODULO(a, p)                       计算 `a` 对 `p` 取模。
RANK(a)                            返回标量或数组 `a` 的秩（标量的秩为 0）。
SHAPE(a)                           返回标量或数组 `a` 的形状（标量的形状为 `()`）。
SIZE(array[, dim [, kind]])        返回数组沿指定维度 `dim` 的范围，或者如果 `dim` 不存在，则返回数组中的元素总数。可选参数 `kind` 指定返回类型 `Integer(kind)` 的 `KIND`。
UBOUND(array [, dim [, kind]])     返回数组的上限，或者如果存在 `dim`，则返回沿 `dim` 维度的单个上限。可选参数 `kind` 指定返回类型 `Integer(kind)` 的 `KIND`。
```

#### 15.4.6.4 特殊的 Fortran 命令

gdb 有一些命令支持 Fortran 特定的功能，例如显示公共块。
```
info common [common-name]
	此命令打印名为 `common-name` 的 Fortran `COMMON` 块中包含的值。如果没有参数，则打印当前程序位置可见的所有 `COMMON` 块的名称。

set fortran repack-array-slices [on|off]
show fortran repack-array-slices
	从数组中获取切片时，Fortran 编译器可以选择生成就地描述切片的数组描述符，或者可以重新打包切片，将切片的元素复制到新的内存区域。
	当此设置为 `on` 时，gdb 在某些情况下也会重新打包数组切片。当此设置为 `off` 时，gdb 将为切片创建就地引用原始数据的数组描述符。
	如果切片的数据在原始数组中是连续的，gdb 永远不会重新打包数组切片。如果切片的数据在原始字符串中是非连续的，gdb 总是会重新打包字符串切片，因为 gdb 不支持打印非连续字符串。
	此设置的默认值为 `off` 。
```

### 15.4.7 Pascal

调试使用集合、子范围、文件变量或嵌套函数的 Pascal 程序目前不起作用。gdb 不支持使用 Pascal 语法输入表达式、打印值或类似功能。

特定于 Pascal 的命令 `set print pascal_static-members` 控制是否显示 Pascal 对象的静态成员。请参见第 10.9 节[打印设置]，第 157 页。

### 15.4.8 Rust

gdb 支持 Rust 编程语言（https://www.rust-lang.org/）。类型和值打印以及表达式解析相当完整。然而，有一些特性和漏洞需要注意。
```
•   行规范（请参见第 9.2 节[位置规范]，第 126 页）从不相对于当前的 crate。相反，它们的行为就好像有一个全局的 crate 命名空间，有点类似于 `extern crate` 的行为。
	也就是说，如果 gdb 在 crate `A`、模块 `B` 中的函数中的断点处停止，那么 `break B::f` 将尝试在名为 `B` 的 crate 中设置一个名为 `f` 的函数的断点。
	由于这种方法，行规范也不能使用 `self::` 或 `super::` 来引用项目。
• 	因为 gdb 在表达式中实现了 Rust 名称查找语义，有时它会将当前的 crate 前置到名称上。例如，如果 gdb 在 crate `K` 的断点处停止，那么 `print ::x::y` 将尝试查找符号 `K::x::y` 。
	然而，由于在调试时能够引用其他 crate 很有用，gdb 提供了 `extern` 扩展来规避此问题。要使用扩展，只需在路径表达式前加上 `extern` 以引用否则不可用的“全局”范围。
	在上述示例中，如果您想引用 crate `x` 中的符号 `y` ，您将使用 `print extern x::y` 。
•   Rust 表达式求值器不支持“语句式”表达式，如 `if` 或 `match`，或 lambda 表达式。
•   元组表达式未实现。
•   Rust 表达式求值器当前未实现 `Drop` 特征。求值器可能创建的对象永远不会被销毁。
•   gdb 不为泛型实现类型推断。为了调用泛型函数或以其他方式引用泛型项目，您必须手动指定类型参数。
•   gdb 当前使用 C++ 的反混淆器来处理 Rust。在大多数情况下，这不会导致任何问题。然而，在表达式上下文中，完成泛型函数名称将给出语法无效的结果。这是因为 Rust 要求在函数名称与其泛型参数之间使用 `::` 运算符。例如，gdb 可能提供类似于 `crate::f<u32>` 的完成，而解析器需要 `crate::f::<u32>` 。
•   截至本文撰写时，Rust 编译器（版本 1.8）在其生成的调试信息中有一些漏洞。这些漏洞阻止了 gdb 实现某些功能：
	• 不能通过 trait 进行方法调用。
	• 运算符重载未实现。
	• 在单态化函数中调试时，不能使用泛型类型名称。
	• 类型 `Self` 不可用。
	• `use` 语句不可用，因此某些名称可能在 crate 中不可用。
```
### 15.4.9 Modula-2

对 gdb 进行的支持 Modula-2 的扩展仅支持来自 gnu Modula-2 编译器（目前正在开发中）的输出。目前不支持其他 Modula-2 编译器，尝试调试由它们生成的可执行文件很可能会出错，因为 gdb 读取可执行文件的符号表。

#### 15.4.9.1 运算符

运算符必须针对特定类型的值进行定义。例如，`+` 定义在数字上，但不在结构体上。运算符通常针对一组类型进行定义。对于 Modula-2，以下定义成立：

• 整数类型包括 `INTEGER`、`CARDINAL` 及其子范围。

• 字符类型包括 `CHAR` 及其子范围。

• 浮点类型包括 `REAL` 。

• 指针类型包括声明为 `POINTER TO type` 的任何类型。

• 标量类型包括以上所有类型。

• 集合类型包括 `SET` 和 `BITSET` 类型。

• 布尔类型包括 `BOOLEAN` 。

以下运算符受支持，并按优先级升序排列：
```
,           函数参数或数组索引分隔符。
:=          赋值。`var := value` 的值为 `value` 。
<,>         小于、大于，适用于整数、浮点或枚举类型。
<=,>=       小于等于、大于等于，适用于整数、浮点和枚举类型，或集合类型上的集合包含。与 `<` 具有相同的优先级。
=,<>,#      相等和两种表示不等的方式，适用于标量类型。与 `<` 具有相同的优先级。在 gdb 脚本中，由于 `#` 与脚本注释字符冲突，因此对于不等，仅提供 `<>` 。
IN          集合成员资格。定义在集合类型及其成员的类型上。与 `<` 具有相同的优先级。
OR          布尔析取。定义在布尔类型上。
AND,&       布尔合取。定义在布尔类型上。
@           gdb 的“人工数组”运算符（请参见第 10.1 节[表达式]，第 145 页）。
+,-         整数和浮点类型的加法和减法，或集合类型的并集和差集。
*           整数和浮点类型的乘法，或集合类型的交集。
/           浮点类型的除法，或集合类型的对称差集。与 `*` 具有相同的优先级。
DIV,MOD     整数除法和余数。定义在整数类型上。与 `*` 具有相同的优先级。
-           负号。定义在 `INTEGER` 和 `REAL` 数据上。
^           指针解引用。定义在指针类型上。
NOT         布尔否定。定义在布尔类型上。与 `^` 具有相同的优先级。
.           记录字段选择器。定义在 `RECORD` 数据上。与 `^` 具有相同的优先级。
[]          数组索引。定义在 `ARRAY` 数据上。与 `^` 具有相同的优先级。
()          过程参数列表。定义在 `PROCEDURE` 对象上。与 `^` 具有相同的优先级。
::,.        gdb 和 Modula-2 作用域运算符。
```
警告：集合表达式及其操作尚未得到支持，因此 gdb 将对集合上使用运算符 `IN` ，或对集合使用运算符 `+`、`-`、`*`、`/`、`=`、`<>`、`#`、`<=` 和 `>=` 视为错误。

#### 15.4.9.2 内置函数和过程

Modula-2 还提供了几个内置过程和函数。在描述这些时，使用了以下元变量：

`a` 表示 `ARRAY` 变量。

`c` 表示 `CHAR` 常量或变量。

`i` 表示整数类型的变量或常量。

`m` 表示属于集合的标识符。通常与元变量 `s` 在同一函数中使用。`s` 的类型应为 `SET OF mtype`（其中 `mtype` 是 `m` 的类型）。

`n` 表示整数或浮点类型的变量或常量。

`r` 表示浮点类型的变量或常量。

`t` 表示类型。

`v` 表示变量。

`x` 表示多种类型之一的变量或常量。有关详细信息，请参阅函数的解释。

所有 Modula-2 内置过程也返回下面描述的结果。

`ABS(n)`：返回 `n` 的绝对值。

`ADR(n)`：返回 `n` 的内存地址。

`CAP(c)`：如果 `c` 是小写字母，返回其大写等效字符，否则返回其参数。

`CHR(i)`：返回序数值为 `i` 的字符。

`DEC(v)`：将变量 `v` 的值减 1。返回新值。

`DEC(v, i)`：将变量 `v` 的值减 `i`。返回新值。

`EXCL(m, s)`：从集合 `s` 中移除元素 `m`。返回新集合。

`FLOAT(i)`：返回整数 `i` 的浮点等效值。

`HIGH(a)`：返回 `a` 的最后一个成员的索引。

`INC(v)`：将变量 `v` 的值增 1。返回新值。

`INC(v, i)`：将变量 `v` 的值增 `i`。返回新值。

`INCL(m, s)`：如果元素 `m` 不在集合 `s` 中，则将其添加到集合中。返回新集合。

`MAX(t)`：返回类型 `t` 的最大值。

`MIN(t)`：返回类型 `t` 的最小值。

`ODD(i)`：如果 `i` 是奇数，返回布尔值 `TRUE`。

`ORD(x)`：返回其参数的序数值。例如，字符的序数值是其 ASCII 值（在支持 ASCII 字符集的机器上）。参数 `x` 必须是有序类型，包括整数、字符和枚举类型。

`SIZE(x)`：返回其参数的大小。参数 `x` 可以是变量或类型。

`TRUNC(r)`：返回 `r` 的整数部分。

`TSIZE(x)`：返回其参数的大小。参数 `x` 可以是变量或类型。

`VAL(t, i)`：返回类型 `t` 中序数值为 `i` 的成员。

警告：集合及其操作尚未得到支持，因此 gdb 将对使用过程 `INCL` 和 `EXCL` 的操作视为错误。

#### 15.4.9.3 常量

gdb 允许您以以下方式表示 Modula-2 的常量：

• 整数常量只是数字序列。在表达式中使用时，常量被解释为与表达式的其余部分类型兼容。十六进制整数以尾随的 `H` 指定，八进制整数以尾随的 `B` 指定。

• 浮点常量表现为数字序列，后跟小数点和另一个数字序列。然后可以指定可选的指数，形式为 `E[+|-]nnn`，其中 `[+|-]nnn` 是所需的指数。浮点常量的所有数字都必须是有效的十进制（基数 10）数字。

• 字符常量由一对相同的引号（单引号 `'` 或双引号 `"`）括起来的单个字符组成。它们也可以通过其序数值（通常是其 ASCII 值）后跟 `C` 来表示。

• 字符串常量由一对相同的引号（单引号 `'` 或双引号 `"`）括起来的字符序列组成。也允许使用 C 风格的转义序列。有关转义序列的简要说明，请参见第 15.4.1.2 节[C 和 C++ 常量]，第 233 页。

• 枚举常量由枚举标识符组成。

• 布尔常量由标识符 `TRUE` 和 `FALSE` 组成。

• 指针常量仅由整数值组成。

• 集合常量尚未得到支持。

#### 15.4.9.4 Modula-2 类型

目前，gdb 可以用 Modula-2 语法打印以下数据类型：数组类型、记录类型、集合类型、指针类型、过程类型、枚举类型、子范围类型和基本类型。您还可以打印使用这些类型声明的变量的内容。本节提供了一些简单的源代码示例以及示例的 gdb 会话。

第一个示例包含以下代码段：

```modula-2
VAR
    s: SET OF CHAR;
    r: [20..40];
```

并且您可以请求 gdb 查询 `r` 和 `s` 的类型和值。

```
(gdb) print s
{’A’..’C’, ’Z’}
(gdb) ptype s
SET OF CHAR
(gdb) print r
21
(gdb) ptype r
[20..40]
```

同样，如果您的源代码将 `s` 声明为：

```modula-2
VAR
    s: SET ['A'..'Z'];
```

那么您可以通过以下方式查询 `s` 的类型：

```
(gdb) ptype s
type = SET ['A'..'Z']
```

请注意，目前您无法使用调试器以交互方式操作集合表达式。

以下示例展示了如何在 Modula-2 中声明数组以及如何与 gdb 交互以打印其类型和内容：

```modula-2
VAR
    s: ARRAY [-10..10] OF CHAR;

(gdb) ptype s
ARRAY [-10..10] OF CHAR
```

请注意，数组处理尚未完成，尽管类型打印正确，但表达式处理仍然假设所有数组的下限为 0，而不是上述示例中的 -10。

这里有更多与类型相关的 Modula-2 示例：

```modula-2
TYPE
    colour = (blue, red, yellow, green);
    t = [blue..yellow];
VAR
    s: t;
BEGIN
    s := blue;
```

gdb 交互显示了如何查询变量的数据类型和值。

```
(gdb) print s
$1 = blue
(gdb) ptype t
type = [blue..yellow]
```

在这个示例中，声明了一个 Modula-2 数组并显示了其内容。请注意，内容的书写方式与它们的 C 对应项相同。

```modula-2
VAR
    s: ARRAY [1..5] OF CARDINAL;
BEGIN
    s[1] := 1;
```

```
(gdb) print s
$1 = {1, 0, 0, 0, 0}
(gdb) ptype s
type = ARRAY [1..5] OF CARDINAL
```

Modula-2 语言与 gdb 的接口也理解指针类型，如这个示例所示：

```modula-2
VAR
    s: POINTER TO ARRAY [1..5] OF CARDINAL;
BEGIN
    NEW(s);
    s^[1] := 1;
```

并且您可以请求 gdb 描述 `s` 的类型。

```
(gdb) ptype s
type = POINTER TO ARRAY [1..5] OF CARDINAL
```

gdb 处理复合类型，如我们在这个示例中看到的。这里我们结合了数组类型、记录类型、指针类型和子范围类型：

```modula-2
TYPE
    foo = RECORD
        f1: CARDINAL;
        f2: CHAR;
        f3: myarray;
    END;
    myarray = ARRAY myrange OF CARDINAL;
    myrange = [-2..2];
VAR
    s: POINTER TO ARRAY myrange OF foo;
```

并且您可以要求 gdb 描述 `s` 的类型，如下所示。

```
(gdb) ptype s
type = POINTER TO ARRAY [-2..2] OF foo = RECORD
    f1 : CARDINAL;
    f2 : CHAR;
    f3 : ARRAY [-2..2] OF CARDINAL;
END
```

#### 15.4.9.5 Modula-2 默认值

如果由 gdb 自动设置类型和范围检查，当工作语言更改为 Modula-2 时，它们都默认为开启。无论您还是 gdb 选择工作语言，都会发生这种情况。

如果允许 gdb 自动设置语言，那么进入名称以 `.mod` 结尾的文件编译的代码会将工作语言设置为 Modula-2。有关更多详细信息，请参见第 15.1.3 节[让 gdb 推断源语言]，第 228 页。

#### 15.4.9.6 与标准 Modula-2 的偏差

为了使 Modula-2 程序更易于调试，进行了一些更改。这主要是通过放宽其类型严格性来实现的：

• 与标准 Modula-2 不同，指针常量可以由整数形成。这允许您在调试期间修改指针变量。（在标准 Modula-2 中，指针变量中包含的实际地址对您是隐藏的；它只能通过直接赋值给另一个指针变量或返回指针的表达式来修改。）

• C 转义序列可以在字符串和字符中用于表示不可打印字符。gdb 打印出嵌入了这些转义序列的字符串。单个不可打印字符使用 `CHR(nnn)` 格式打印。

• 赋值运算符 `(:=)` 返回其右侧参数的值。

• 所有内置过程既修改又返回其参数。

#### 15.4.9.7 Modula-2 类型和范围检查

警告：在本版本中，gdb 尚未执行类型或范围检查。

gdb 认为两个 Modula-2 变量类型等效，如果：

• 它们是通过 `TYPE t1 = t2` 语句声明为等效的类型。

• 它们在同一行上声明。（注意：这对于 gnu Modula-2 编译器是正确的，但对于其他编译器可能不正确。）

只要启用了类型检查，任何尝试组合类型不等效的变量都是错误的。

范围检查在所有数学运算、赋值、数组索引边界以及所有内置函数和过程上进行。

#### 15.4.9.8 作用域运算符 `::` 和 `.`

Modula-2 作用域运算符 `.` 和 gdb 作用域运算符 `::` 之间有一些细微的差别。两者具有相似的语法：
```
module. id
scope :: id
```
其中 `scope` 是模块或过程的名称，`module` 是模块的名称，`id` 是程序中任何声明的标识符，但不是另一个模块。

使用 `::` 运算符使 gdb 在由 `scope` 指定的作用域中搜索标识符 `id`。如果在指定的作用域中未找到，则 gdb 搜索包含指定作用域的所有作用域。

使用 `.` 运算符使 gdb 在当前作用域中搜索从由 `module` 指定的定义模块导入的由 `id` 指定的标识符。使用此运算符，如果标识符 `id` 未从定义模块 `module` 导入，或者 `id` 不是模块中的标识符，则会出错。

#### 15.4.9.9 gdb 和 Modula-2

一些 gdb 命令在调试 Modula-2 程序时用处不大。`set print` 和 `show print` 的五个子命令专门适用于 C 和 C++：`vtbl`、`demangle`、`asm-demangle`、`object` 和 `union`。前四个适用于 C++，最后一个适用于 C 的联合类型，在 Modula-2 中没有直接的类似物。

`@` 运算符（请参见第 10.1 节[表达式]，第 145 页），虽然可用于任何语言，但对 Modula-2 没有用处。其目的是帮助调试动态数组，这在 Modula-2 中无法像在 C 或 C++ 中那样创建。但是，由于地址可以由整数常量指定，因此构造 `{type}adrexp` 仍然有用。

在 gdb 脚本中，Modula-2 中的不等运算符 `#` 被解释为注释的开始。请使用 `<>` 代替。

### 15.4.10 Ada

对 gdb 进行的 Ada 扩展仅支持 gnu Ada（GNAT）编译器的输出。目前不支持其他 Ada 编译器，尝试调试由它们生成的可执行文件很可能会很困难。

### 15.4.10.1 介绍

gdb 的 Ada 模式支持相当大的 Ada 表达式语法子集，并带有一些扩展。这个子集设计背后的理念是：

• gdb 应该提供基本的字面量和对算术、解引用、字段选择、索引和子程序调用操作的访问，将更复杂的计算留给程序中编写的子程序（因此可以从 gdb 调用）。

• 类型安全和严格遵守 Ada 语言限制对 gdb 用户不是特别重要。

• 简洁对 gdb 用户很重要。

因此，为了简洁起见，调试器的行为就好像用户编写的包中声明的所有名称都是直接可见的，即使根据 Ada 规则它们不可见，从而无需使用其包完全限定大多数名称，无论上下文如何。如果这导致歧义，gdb 会询问用户的意图。

如果调试器检测到 Ada 主程序，它将以 Ada 模式启动。对于其他语言，当在从 Ada 源文件翻译的程序中停止时，它将进入 Ada 模式。

在 Ada 模式下，可以使用 `--` 进行注释。这主要用于记录命令文件。标准的 gdb 注释（`#`）在 Ada 模式下仍然在一行的开头起作用，但在中间不起作用（以允许基于的字面量）。

#### 15.4.10.2 Ada 中的省略

以下是该子集中的显著省略：

• 仅支持属性的子集：

 - `'First`、`'Last` 和 `'Length` 在数组对象上（不在类型和子类型上）。

 - `'Min` 和 `'Max`。

 - `'Pos` 和 `'Val`。

 - `'Tag`。

 - `'Range` 在数组对象上（不在子类型上），但仅作为成员资格（`in`）运算符的右操作数。

 - `'Access`、`'Unchecked_Access` 和 `'Unrestricted_Access`（GNAT 扩展）。

 - `'Address`。

 - `'Size` 可用于对象（不是类型）。

 - `'Object_Size` 可用，但不适用于不定类型。

• `Characters.Latin_1` 中的名称不可用。

• 数组上的相等性测试（`=` 和 `/=`）测试表示的按位相等性。它们通常对于字符串和元素具有整数或枚举类型的数组正确工作。对于元素具有用户定义相等性的数组、实数（特别是 IEEE 兼容的浮点数，因为有负零和 NaN）的数组以及元素包含未使用且值不确定的位的数组，它们可能无法正常工作。

• 其他按组件的数组操作（`and`、`or`、`xor`、`not` 和除相等性之外的关系测试）未实现。

• 对数组和记录聚合的支持有限。它们仅允许在赋值的右侧，如以下示例：

```
(gdb) set An_Array := (1, 2, 3, 4, 5, 6)
(gdb) set An_Array := (1, others => 0)
(gdb) set An_Array := (0|4 => 1, 1..3 => 2, 5 => 6)
(gdb) set A_2D_Array := ((1, 2, 3), (4, 5, 6), (7, 8, 9))
(gdb) set A_Record := (1, "Peter", True);
(gdb) set A_Record := (Name => "Peter", Id => 1, Alive => True)
```

通过分配聚合来更改判别式的值，如果该判别式在记录中使用，则效果未定义。但是，您可以首先通过直接赋值给它们来修改判别式（这在 Ada 中通常是不允许的），然后执行聚合赋值。例如，给定一个变量 `A_Rec` 声明为具有如下类型：

```ada
type Rec (Len : Small_Integer := 0) is record
    Id : Integer;
    Vals : IntArray (1.. Len);
end record;
```

您可以通过两次赋值来分配具有不同 `Vals` 大小的值：

```
(gdb) set A_Rec.Len := 4
(gdb) set A_Rec := (Id => 42, Vals => (1, 2, 3, 4))
```

正如这个例子也说明的，gdb 对于通常关于聚合的规则非常宽松。您可以省略数组或记录聚合的某些组件（例如上面分配给 `A_Rec` 的赋值中的 `Len` 组件）；它们在赋值时将保留其原始值。您可以自由地将动态值用作组件关联中的索引。您甚至可以使用重叠或冗余的组件关联，尽管在这种情况下哪些组件值被分配是未定义的。

• 对调度子程序的调用未实现。

• 重载算法比真正的 Ada 限制更多（即，选择性更低）。它仅有限地使用子表达式出现的上下文来解析其含义，并且在允许类型匹配的规则上要宽松得多。因此，某些函数调用将是模糊的，用户将被要求选择正确的解析。

• `new` 运算符未实现。

• 入口调用未实现。

• 除了打印，对本机 VAX 浮点格式的算术运算不支持。

• 不可能对打包数组进行切片。

• 名称 `True` 和 `False`，当不是限定名称的一部分时，无论上下文如何，都被解释为好像隐式地以 `Standard` 为前缀。如果您的程序在包或过程中重新定义了这些名称（这最多是一种可疑的做法），您将必须使用完全限定的名称来访问它们的新定义。

• 基于的实数字面量未实现。

#### 15.4.10.3 Ada 的添加

正如对其他语言所做的那样，gdb 对 Ada 进行了某些通用扩展（请参见第 10.1 节[表达式]，第 145 页）：

• 如果表达式 `E` 是驻留在内存中的变量（通常是局部变量或数组元素），并且 `N` 是正整数，则 `E@N` 以数组形式显示 `E` 以及在内存中跟随其后的 `N - 1` 个相邻变量的值。在 Ada 中，此运算符通常不是必需的，因为它的主要用途是显示数组的部分，而在 Ada 中切片通常可以做到这一点。但是，在调试某些调试信息已被优化掉的程序时偶尔会有用。

• `B::var` 表示“在函数或文件 `B` 中出现的名为 `var` 的变量”。当 `B` 是文件名时，通常必须将其用单引号括起来。

• 表达式 `{type} addr` 表示“出现在地址 `addr` 的类型为 `type` 的变量”。

• 以 `$` 开头的名称是便利变量（请参见第 10.12 节[便利变量]，第 171 页）或机器寄存器（请参见第 10.14 节[寄存器]，第 179 页）。

此外，gdb 还提供了一些特定于 Ada 的其他快捷方式和直接添加：

• 赋值语句被允许作为表达式，返回其右侧操作数作为其值。因此，您可以输入：

```
(gdb) set x := y + 3
(gdb) print A(tmp := y + 1)
```

• 分号被允许作为“运算符”，返回其右侧操作数的值。这允许，例如，复杂的条件断点：

```
(gdb) break f
(gdb) condition 1 (report(i); k += 1; A(k) > 100)
```

• 对基于的实数字面量的扩展可用于指定浮点文字的确切字节内容。在基数之后，可以使用 0 到 2 个 `l` 字符，后跟一个 `f`。`l` 字符的数量控制生成的实型常量的宽度：0 表示使用 `Float`，1 表示 `Long_Float`，2 表示 `Long_Long_Float`。

```
(gdb) print 16f#41b80000#
$1 = 23.0
```

• 而不是使用连接和符号字符名称将特殊字符引入字符串，可以使用特殊的括号表示法，这也用于打印字符串。字符串或字符文字中形式为 `["XX"]` 的字符序列表示十六进制编码为 `XX` 的（单个）字符。字符序列 `["""]` 也表示字符串中的单引号。例如：

```ada
"One line.["0a"]Next line.["0a"]"
```

包含每个句点后一个 ASCII 换行符（`Ada.Characters.Latin_1.LF`）。

• 作为 `'Pos`、`'Min` 和 `'Max` 前缀的子类型是可选的（并且在任何情况下都被忽略）。例如，编写以下内容是有效的：

```
(gdb) print ’max(x, y)
```

• 打印数组时，如果数组的下限为 1，gdb 使用位置表示法，否则使用修改后的命名表示法。例如，下限为 3 的三个整数的一维数组可能打印为：

```
(3 => 10, 17, 1)
```

也就是说，与有效的 Ada 相反，只有第一个组件具有 `=>` 子句。

• 您可以在表达式中使用属性名称的任何唯一的多字符子序列来缩写属性（精确匹配优先）。例如，您可以使用 `a’len`、`a’gth` 或 `a’lh` 代替 `a’length`。

• 由于 Ada 不区分大小写，调试器通常将您键入的标识符映射为小写。GNAT 编译器对其某些内部标识符使用大写字符，这些通常对用户没有兴趣。对于您实际上必须查看它们的极少数情况，将它们括在尖括号中以避免小写映射。例如：

```
(gdb) print <JMPBUF_SAVE>[0]
```

• 打印类范围类型的对象或取消对类范围值的引用将显示对象的特定类型的所有组件（如其运行时标记所示）。同样，对此类值的组件选择将在对象的特定类型上操作。

#### 15.4.10.4 Ada 的重载支持

调试器支持有限的重载。给定一个子程序调用，其中函数符号有多个定义，它将使用实际参数的数量和有关其类型的一些信息来尝试缩小定义集。它还非常有限地使用上下文，在 `call` 命令的上下文中更喜欢过程而不是函数，在其他地方更喜欢函数而不是过程。

如果在缩小之后，匹配的定义集仍然包含多个定义，gdb 将显示一个菜单以查询应该使用哪一个，例如：

```
(gdb) print f(1)
Multiple matches for f
[0] cancel
[1] foo.f (integer) return boolean at foo.adb:23
[2] foo.f (foo.new_integer) return boolean at foo.adb:28
>
```

在这种情况下，只需选择一个菜单项，要么取消表达式求值（输入 0 并按 `RET`），要么使用特定实例继续求值（输入相应的数字并按 `RET`）。

以下是几个在这种情况下自定义 gdb 行为的命令：
```
set ada print-signatures
	控制在重载选择菜单中是否显示参数类型和返回类型。默认情况下是开启的。请参见第 15.4.10.4 节[Ada 的重载支持]，第 253 页。

show ada print-signatures
	显示在重载选择菜单中显示参数类型和返回类型的当前设置。请参见第 15.4.10.4 节[Ada 的重载支持]，第 253 页。
```
#### 15.4.10.5 在最开始停止

有时需要在细化期间以及在到达主过程之前调试程序。正如 Ada 参考手册中所定义的，细化代码是从名为 `adainit` 的过程中调用的。要运行您的程序直到细化开始，只需使用以下两个命令：`tbreak adainit` 和 `run`。

#### 15.4.10.6 Ada 异常

提供了一个命令来列出所有 Ada 异常：
```
info exceptions
info exceptions regexp
	info exceptions 命令允许您列出正在调试的程序中定义的所有 Ada 异常及其地址。使用正则表达式 `regexp` 作为参数时，仅列出名称与 `regexp` 匹配的异常。
```
下面是一个小示例，首先不带参数，然后传递一个正则表达式作为参数来展示如何使用该命令。

```
(gdb) info exceptions
All defined Ada exceptions:
constraint_error: 0x613da0
program_error: 0x613d20
storage_error: 0x613ce0
tasking_error: 0x613ca0
const.aint_global_e: 0x613b00

(gdb) info exceptions const.aint
All Ada exceptions matching regular expression "const.aint":
constraint_error: 0x613da0
const.aint_global_e: 0x613b00
```

还可以要求 gdb 在引发异常时停止程序的执行。有关更多详细信息，请参见第 5.1.3 节[设置捕获点]，第 69 页。

#### 15.4.10.7 Ada 任务的扩展

对 Ada 任务的支持类似于对线程的支持（请参见第 4.10 节[线程]，第 47 页）。gdb 提供了以下与任务相关的命令：
```
info tasks
	此命令显示当前 Ada 任务的列表，如下例所示：
		(gdb) info tasks
		  ID    TID     P-ID Pri State                   Name
		  1     8088000 0    15  Child Activation Wait   main_task
		  2     80a4000 1    15  Accept Statement        b
		  3     809a800 1    15  Child Activation Wait   a
		* 4     80ae800 3    15  Runnable                c

	在此列表中，最后一个任务前的星号表示它是当前正在检查的任务。
		ID    代表 gdb 的内部任务编号。
		TID   Ada 任务 ID。
		P-ID  父任务的 ID（gdb 的内部任务编号）。
		Pri   任务的基本优先级。
		State 任务的当前状态。
			Unactivated                 任务已创建但尚未激活。它不能正在执行。
			Runnable                    任务没有因 Ada 已知的任何原因被阻塞。（但它可能正在等待互斥锁。）从概念上讲，它在正常模式下“正在执行”。
			Terminated                  就 ARM 9.3（5）的意义而言，任务已终止。任何等待终止替代的相关任务都已被唤醒并自行终止。
			Child Activation Wait       任务正在等待创建的任务完成激活。
			Accept or Select Term       任务正在等待接受或选择性等待语句。
			Waiting on entry call       任务正在等待入口调用。
			Async Select Wait           任务正在等待启动异步选择语句的可中止部分。
			Delay Sleep                 任务正在等待只有延迟替代项打开的选择语句。
			Child Termination Wait      任务在完成自身内部的主任务后正在睡眠，并正在等待依赖该主任务的任务终止或等待终止阶段。
			Wait Child in Term Alt      任务正在睡眠等待终止替代上的任务完成终止。
			Asynchronous Hold           任务已被 `Ada.Asynchronous_Task_Control.Hold_Task` 持有。
			Activating                  任务已创建并正在变为可运行。
			Selective Wait              任务正在选择性等待语句中等待。
			Accepting RV with taskno    任务正在接受与任务 `taskno` 的会合。
			Waiting on RV with taskno   任务正在等待与任务 `taskno` 的会合。
		Name  程序中任务的名称。

info task taskno
	此命令显示指定任务的详细信息，如下例所示：
		(gdb) info tasks
		  ID    TID      P-ID Pri State                    Name
		  1     8077880  0    15  Child Activation Wait    main_task
		* 2     807c468  1    15  Runnable                 task_1

		(gdb) info task 2
		Ada Task: 0x807c468
		Name: "task_1"
		Thread: 0
		LWP: 0x1fac
		Parent: 1 ("main_task")
		Base Priority: 15
		State: Runnable

task
	此命令打印当前任务的 ID 和名称。
		(gdb) info tasks
		  ID TID     P-ID Pri State                      Name
		  1  8077870 0    15  Child Activation Wait      main_task
		* 2  807c458 1    15  Runnable                   some_task
		(gdb) task
		[Current task is 2 "some_task"]

task taskno
	此命令类似于 `thread thread-id` 命令（请参见第 4.10 节[线程]，第 47 页）。它将调试的上下文从当前任务切换到给定任务。
		(gdb) info tasks
		  ID TID     P-ID Pri State                       Name
		  1  8077870 0    5   Child Activation Wait       main_task
		* 2  807c458 1    5   Runnable                    some_task
		(gdb) task 1
		[Switching to task 1 "main_task"]
		#0 0x8067726 in pthread_cond_wait ()
		(gdb) bt
		#0 0x8067726 in pthread_cond_wait ()
		#1 0x8056714 in system.os_interface.pthread_cond_wait ()
		#2 0x805cb63 in system.task_primitives.operations.sleep ()
		#3 0x806153e in system.tasking.stages.activate_tasks ()
		#4 0x804aacc in un () at un.adb:5

task apply [task-id-list | all] [flag]... command
	`task apply` 命令是 `thread apply` 的 Ada 任务类似物（请参见第 4.10 节[线程]，第 47 页）。它允许您将指定的命令应用于一个或多个任务。使用任务 ID 的列表指定您希望受影响的任务，或者指定 `all` 以应用于所有任务。
	标志参数控制生成的输出以及将命令应用于任务时引发的错误的处理方式。标志必须以直接后跟一个字母 `qcs` 中的一个的 `-` 开头。如果提供了多个标志，它们必须单独给出，例如 `-c -q`。
	默认情况下，gdb 在命令生成的输出之前显示一些任务信息，并且在执行命令期间引发的错误将中止 `task apply`。以下标志可用于微调此行为：
		-c     `-c` 标志（表示“继续”）会导致显示命令中的任何错误，然后 `task apply` 的执行继续。
		-s     `-s` 标志（表示“静默”）会导致静默忽略命令生成的任何错误或空输出。也就是说，执行继续，但不打印任务信息和错误。
		-q     `-q` 标志（“安静”）禁用打印任务信息。
	`-c` 和 `-s` 标志不能一起使用。

break locspec task taskno
break locspec task taskno if ...
	这些命令类似于 `break... thread...` 命令（请参见第 5.5 节[线程停止]，第 92 页）。有关 `locspec` 的各种形式，请参见第 9.2 节[位置规范]，第 126 页。
	使用带有断点命令的限定符 `task taskno` 来指定您仅希望当特定的 Ada 任务到达此断点时 gdb 停止程序。`taskno` 是 gdb 分配的数字任务标识符之一，显示在 `info tasks` 显示的第一列中。
	如果在设置断点时未指定 `task taskno`，则断点适用于程序的所有任务。
	您也可以在条件断点上使用任务限定符；在这种情况下，将 `task taskno` 放在断点条件之前（在 `if` 之前）。
	例如：
		(gdb) info tasks
		  ID   TID        P-ID Pri  State                      Name
		  1    140022020  0    15   Child Activation Wait      main_task
		  2    140045060  1    15   Accept/Select Wait         t2
		  3    140044840  1    15   Runnable                   t1
		* 4    140056040  1    15   Runnable                   t3

		(gdb) b 15 task 2
		Breakpoint 5 at 0x120044cb0: file test_task_debug.adb, line 15.

		(gdb) cont
		Continuing.
		task # 1 running
		task # 2 running
		Breakpoint 5, test_task_debug () at test_task_debug.adb:15
		15 flush;

		(gdb) info tasks
		  ID  TID       P-ID Pri State                   Name
		  1   140022020 0    15  Child Activation Wait   main_task
		* 2   140045060 1    15  Runnable                t2
		  3   140044840 1    15  Runnable                t1
		  4   140056040 1    15  Delay Sleep             t3
```

#### 15.4.10.8 调试核心文件时的任务支持

在检查核心文件（与调试实时程序相反）时，任务支持可能受到限制甚至不可用，具体取决于所使用的平台。例如，在 x86-linux 上，任务列表可用，但不支持任务切换。

在某些平台上，调试器需要执行一些内存写入操作才能提供 Ada 任务支持。在检查核心文件时，这意味着必须使用命令 `"set write on"`（请参见第 17.6 节[修补]，第 285 页）以读写权限打开核心文件。在这种情况下，在使用 gdb 检查之前，您应该对核心文件进行备份。

#### 15.4.10.9 使用 Ravenscar 配置文件时的任务支持

Ravenscar 配置文件是 Ada 任务功能的子集，专门为具有安全关键实时要求的系统设计。
```
set ravenscar task-switching on
	在调试使用 Ravenscar 配置文件的程序时允许任务切换。这是默认设置。

set ravenscar task-switching off
	在调试使用 Ravenscar 配置文件的程序时关闭任务切换。这主要是为了在 gdb 或 Ravenscar 运行时中存在阻止 gdb 正常工作的错误时禁用添加 Ravenscar 配置文件支持的代码。要生效，此命令应在程序启动之前运行。

show ravenscar task-switching
	显示在使用 Ravenscar 配置文件的程序中是否可以在任务之间切换。
```
当启用 Ravenscar 任务切换时，gdb 会将 Ravenscar 任务宣布为线程：

```
(gdb) continue
[New Ravenscar Thread 0x2b8f0]
```

Ravenscar 任务和底层的 CPU 线程都将出现在 `info threads` 的输出中：
```
(gdb) info threads
  Id  Target   Id                  Frame
  1   Thread   1 (CPU#0 [running]) simple () at simple.adb:10
  2   Thread   2 (CPU#1 [running]) 0x0000000000003d34 in __gnat_initialize_cpu_devices ()
  3   Thread   3 (CPU#2 [running]) 0x0000000000003d28 in __gnat_initialize_cpu_devices ()
  4   Thread   4 (CPU#3 [halted ]) 0x000000000000c6ec in system.task_primitives.operations.idle ()
* 5   Ravenscar Thread 0x2b8f0 simple () at simple.adb:10
  6   Ravenscar Thread 0x2f150 0x000000000000c6ec in system.task_primitives.operations.idle ()
```
gdb 中 Ravenscar 支持的一个已知限制是目前无法单步调试运行时初始化序列。如果需要调试此代码，应使用 `set ravenscar task-switching off`。

#### 15.4.10.10 Ada 源字符集

GNAT 编译器支持源文件的多种字符集。请参见 gnat_ugn 中的“字符集控制”部分。gdb 也包括对此的支持。
```
set ada source-charset charset
	为 Ada 设置源字符集。字符集必须得到 GNAT 的支持。由于此设置会影响对来自程序调试信息中的符号的解码，因此应尽早设置。默认是 ISO-8859-1，因为这也是 GNAT 的默认值。

show ada source-charset
	显示当前 Ada 的源字符集。
```
#### 15.4.10.11 Ada 模式的已知特性

除了前面列出的省略（请参见第 15.4.10.2 节[Ada 的省略]，第 251 页），我们还知道 gdb 中 Ada 模式的几个问题和限制，其中一些将在调试器和 GNU Ada 编译器的未来计划发布中得到修复。

• 编译器选择不作为存储对象实现的静态常量对调试器不可见。

• 函数参数列表中的命名参数关联被忽略（参数列表被视为位置参数）。

• 许多有用的库包目前对调试器不可见。

• 定点算术、转换、输入和输出使用浮点算术进行，并且可能给出仅近似于主机上的结果。

• GNAT 编译器从不为 Ada 语言定义的任何标准符号生成前缀 `Standard`。gdb 知道这一点：当您使用它时，它会从名称中剥离前缀，并且永远不会在本地符号中查找您如此限定的名称，也不会与其他包或子程序中的符号匹配。如果您在程序中的任何地方（除了参数和局部变量）定义了简单名称与 `Standard` 中名称匹配的实体，GNAT 在此处缺乏限定可能会导致混淆。发生这种情况时，您通常可以通过明确使用包 `Standard` 限定有问题的名称来解决混淆。

较旧版本的编译器有时会生成错误的调试信息，导致调试器错误地打印受影响实体的值。在某些情况下，调试器能够自动解决问题。在其他情况下，调试器能够解决问题，但必须专门启用解决方法。
```
set ada trust-PAD-over-XVS on
	配置 GDB 在计算 Ada 实体的值时严格遵循 GNAT 编码，特别是涉及 `PAD` 和 `PAD___XVS` 类型时（有关 GNAT 编译器使用的编码的完整描述，请参见 GCC 源中的 ada/exp_dbug.ads）。这是默认设置。

set ada trust-PAD-over-XVS off
	这与 GNAT 编译器使用的编码有关。如果 gdb 有时为某些实体打印错误的值，将 `ada trust-PAD-over-XVS` 更改为 `off` 会激活一个解决方法，可能会解决问题。将 `ada trust-PAD-over-XVS` 设置为 `off` 始终是安全的，但这会导致轻微的性能损失，因此除非必要，建议将此设置保留为 `on`。
```
在内部，调试器还依赖编译器遵循一些称为“GNAT 编码”的约定，所有这些都在 GCC 源中的 gcc/ada/exp_dbug.ads 中有记录。此编码描述了应为某些类型生成调试信息的方式。特别是，此约定使用描述性类型，这些是纯粹为帮助调试器而生成的人工类型。

这些编码是在使用的调试信息格式不足以描述 Ada 中可用的一些更复杂类型时定义的。由于 DWARF 允许我们表达几乎所有 Ada 特性，长期目标是慢慢用其纯 DWARF 等效项替换这些描述性类型。为了促进这种过渡，提供了一个新的维护选项来强制调试器忽略这些描述性类型。它允许用户快速评估 gdb 在没有它们的情况下的工作情况。
```
maintenance ada set ignore-descriptive-types [on|off]
	控制调试器是否应忽略描述性类型。默认是不忽略描述性类型（`off`）。

maintenance ada show ignore-descriptive-types
	显示 gdb 是否忽略描述性类型。
```

## 15.5 不受支持的语言

除了其他完全支持的编程语言之外，gdb 还提供了一种伪语言，称为 `minimal`。它并不代表一种真正的编程语言，而是提供了一组接近 C 或汇编语言所提供的功能。这应该允许在调试使用当前不受 gdb 支持的语言的应用程序时执行大多数简单操作。

如果语言设置为 `auto`，如果当前帧对应于不受支持的语言，gdb 将自动选择此语言。
