# 5 停止和继续

使用调试器的主要目的是您可以在程序终止之前停止它；或者，如果您的程序遇到问题，您可以进行调查并找出原因。

在 gdb 内部，您的程序可能由于多种原因而停止，例如信号、断点或在诸如 `step` 之类的 gdb 命令后到达新行。然后，您可以检查和更改变量、设置新断点或删除旧断点，然后继续执行。通常，gdb 显示的消息会充分解释您程序的状态 - 但您也可以随时显式请求此信息。

`info program` 显示有关您程序状态的信息：它是否正在运行、它是什么进程以及它停止的原因。

## 5.1 断点、监视点和捕获点

断点使您的程序在到达程序中的某个特定点时停止。对于每个断点，您可以添加条件以更精细地控制程序是否停止。您可以使用 `break` 命令及其变体（请参阅第 5.1.1 节[设置断点]，第 58 页）设置断点，通过行号、函数名或程序中的精确地址指定程序应停止的位置。

在某些系统上，您可以在可执行文件运行之前在共享库中设置断点。

监视点是一种特殊的断点，当表达式的值发生更改时停止您的程序。表达式可以是变量的值，也可以涉及由运算符组合的一个或多个变量的值，例如 `a + b` 。这有时称为数据断点。您必须使用不同的命令来设置监视点（请参阅第 5.1.2 节[设置监视点]，第 66 页），但除此之外，您可以像管理任何其他断点一样管理监视点：您使用相同的命令启用、禁用和删除断点和监视点。

您可以安排在 gdb 在断点处停止时自动显示来自您程序的值。请参阅第 10.8 节[自动显示]，第 155 页。

捕获点是另一种特殊的断点，当某种事件发生时（例如抛出 C++ 异常或加载库）停止您的程序。与监视点一样，您使用不同的命令来设置捕获点（请参阅第 5.1.3 节[设置捕获点]，第 69 页），但除此之外，您可以像管理任何其他断点一样管理捕获点。（要在程序收到信号时停止，请使用 `handle` 命令；请参阅第 5.4 节[信号]，第 89 页。）

当您创建断点、监视点或捕获点时，gdb 会为每个点分配一个编号；这些编号是从 1 开始的连续整数。在许多用于控制断点各种功能的命令中，您使用断点编号来表示要更改的断点。每个断点都可以启用或禁用；如果禁用，在您再次启用它之前，它对您的程序没有影响。

某些 gdb 命令接受要操作的断点的以空格分隔的列表。列表元素可以是单个断点编号，如 `'5'` ，也可以是这样编号的范围，如 `'5-7'` 。当向命令提供断点列表时，该列表中的所有断点都将被操作。
### 5.1.1 设置断点

断点使用 `break` 命令（缩写为 `b` ）进行设置。调试器便利变量 `'$bpnum'` 记录您最近设置的断点的编号：

```
(gdb) b main
Breakpoint 1 at 0x11c6: file zeoes.c, line 24.
(gdb) p $bpnum
$1 = 1
```

一个断点可能映射到多个代码位置，例如内联函数、Ada 泛型、C++ 模板或重载的函数名。gdb 然后在断点命令的输出中指示代码位置的数量：

```
(gdb) b some_func
Breakpoint 2 at 0x1179: some_func. (3 locations)
(gdb) p $bpnum
$2 = 2
```

当您的程序在断点处停止时，便利变量 `'$_hit_bpnum'` 和 `'$_hit_locno'` 分别设置为遇到的断点的编号和断点的代码位置编号：

```
Thread 1 "zeoes" hit Breakpoint 2.1, some_func () at zeoes.c:8
8 printf("some func\n");
(gdb) p $_hit_bpnum
$5 = 2
(gdb) p $_hit_locno
$6 = 1
```

请注意，`'$_hit_bpnum'` 和 `'$bpnum'` 不等价：`'$_hit_bpnum'` 设置为最后遇到的断点编号，而 `'$bpnum'` 设置为最后设置的断点编号。

如果遇到的断点只有一个代码位置，`'$_hit_locno'` 设置为 1：

```
Breakpoint 1, main (argc=1, argv=0x7fffffffe018) at zeoes.c:24
24 if (argc > 1)
(gdb) p $_hit_bpnum
$3 = 1
(gdb) p $_hit_locno
$4 = 1
```

`'$_hit_bpnum'` 和 `'$_hit_locno'` 变量通常可以在断点命令列表中使用。（请参阅第 5.1.7 节[断点命令列表]，第 77 页）。例如，作为断点命令列表的一部分，您可以使用 `disable $_hit_bpnum` 完全禁用遇到的断点，或者使用 `disable $_hit_bpnum.$_hit_locno` 禁用特定遇到的断点位置。如果断点只有一个位置，`'$_hit_locno'` 设置为 1，并且命令 `disable $_hit_bpnum` 和 `disable $_hit_bpnum.$_hit_locno` 都禁用断点。

您还可以定义别名以轻松禁用最后遇到的位置或最后遇到的断点：

```
(gdb) alias lld = disable $_hit_bpnum.$_hit_locno
(gdb) alias lbd = disable $_hit_bpnum
```

`break locspec` 在解析给定的 `locspec` 得到的程序中的所有代码位置设置断点。`locspec` 可以指定函数名、行号、指令的地址等等。有关 `locspec` 的各种形式，请参阅第 9.2 节[位置规范]，第 126 页。断点将在程序执行任何断点代码位置的指令之前停止程序。

当使用允许符号重载的源语言（例如 C++）时，函数名可能引用多个符号，从而有多个断点位置。有关这种情况的讨论，请参阅第 10.2 节[歧义表达式]，第 146 页。

还可以插入一个断点，只有当特定线程（请参阅第 5.5.4 节[特定于线程的断点]，第 96 页）、特定下级（请参阅第 4.9.1 节[特定于下级的断点]，第 46 页）或特定任务（请参阅第 15.4.10.7 节[Ada 任务]，第 255 页）命中该断点时，程序才会停止。

`break` 当没有任何参数调用时，`break` 在所选栈帧中要执行的下一条指令处设置断点（请参阅第 8 章[检查栈]，第 113 页）。在除最内层之外的任何选定帧中，这会使您的程序在控制返回到该帧时立即停止。这类似于在所选帧内部的帧中使用 `finish` 命令的效果 - 除了 `finish` 不会留下活动断点。如果在最内层帧中使用没有参数的 `break` ，gdb 会在下一次到达当前位置时停止；这在循环内部可能很有用。

gdb 在恢复执行时通常会忽略断点，直到至少执行了一条指令。如果它不这样做，您将无法在不禁用断点的情况下越过断点。此规则适用于程序停止时断点是否已经存在。

`break... if cond` 设置带有条件 `cond` 的断点；每次到达断点时都会计算表达式 `cond` ，并且仅当值不为零（即 `cond` 计算为 `true` ）时才停止。`'...'` 代表上述描述的可能参数之一（或没有参数），指定断点的位置。有关断点条件的更多信息，请参阅第 5.1.6 节[断点条件]，第 76 页。

断点可能映射到多个位置。如果断点条件 `cond` 在某些但不是所有位置无效，则条件无效的位置将被禁用。例如，gdb 报告以下情况，其中三个位置中的两个被禁用。

```
(gdb) break func if a == 10
warning: failed to validate condition at location 0x11ce, disabling:
No symbol "a" in current context.
warning: failed to validate condition at location 0x11b6, disabling:
No symbol "a" in current context.
Breakpoint 1 at 0x11b6: func. (3 locations)
```

由于条件而被禁用的位置在 `info breakpoints` 命令的输出中用大写的 `N` 表示：

```
(gdb) info breakpoints
Num Type Disp Enb Address What
1 breakpoint keep y <MULTIPLE>
stop only if a == 10
1.1 N* 0x00000000000011b6 in...
1.2 y 0x00000000000011c2 in...
1.3 N* 0x00000000000011ce in...
(*): Breakpoint condition is invalid at this location.
```

如果断点条件 `cond` 在断点的所有位置的上下文中都无效，gdb 拒绝定义断点。例如，如果变量 `foo` 是未定义的变量：

```
(gdb) break func if foo
No symbol "foo" in current context.
```

`break... -force-condition if cond` 在某些情况下，条件 `cond` 在当前所有位置都无效，但用户知道它在未来的位置将有效；例如，由于库加载。在这种情况下，通过在 `if` 之前使用 `-force-condition` 关键字，可以强制 gdb 使用给定的条件表达式定义断点，而不是拒绝它。

```
(gdb) break func -force-condition if foo
warning: failed to validate condition at location 1, disabling:
No symbol "foo" in current context.
warning: failed to validate condition at location 2, disabling:
No symbol "foo" in current context.
warning: failed to validate condition at location 3, disabling:
No symbol "foo" in current context.
Breakpoint 1 at 0x1158: test.c:18. (3 locations)
```

这会导致所有原本要插入断点的当前位置被禁用，如上面的示例所示。但是，如果存在条件有效的位置，`-force-condition` 关键字没有效果。

`tbreak args` 
设置仅启用一次停止的断点。`args` 与 `break` 命令相同，断点的设置方式相同，但程序在第一次在此处停止后，断点会自动删除。请参阅第 5.1.5 节[禁用断点]，第 74 页。

`hbreak args`
设置硬件辅助断点。`args`与`break`命令相同，断点的设置方式相同，但该断点需要硬件支持，并且某些目标硬件可能不具备此支持。

其主要目的是用于EPROM/ROM代码调试，这样您可以在指令处设置断点而无需更改指令。这可以与SPARClite DSU和大多数基于x86的目标提供的新陷阱生成一起使用。当程序访问分配给调试寄存器的某些数据或指令地址时，这些目标会生成陷阱。但是，硬件断点寄存器能够设置的断点数量有限。

例如，在DSU上，一次只能设置两个数据断点，如果使用超过两个，gdb将拒绝此命令。在设置新的硬件断点之前，请删除或禁用未使用的硬件断点（请参阅第 5.1.5 节[禁用断点]，第 74 页）。请参阅第 5.1.6 节[断点条件]，第 76 页。

对于远程目标，您可以限制 gdb 将使用的硬件断点数量，请参阅[设置远程硬件断点限制]，第 327 页。

`thbreak args`
设置仅启用一次停止的硬件辅助断点。`args`与`hbreak`命令相同，断点的设置方式相同。但是，与`tbreak`命令一样，程序第一次在此处停止后，断点会自动删除。同样，与`hbreak`命令一样，该断点需要硬件支持，并且某些目标硬件可能不具备此支持。请参阅第 5.1.5 节[禁用断点]，第 74 页。另请参阅第 5.1.6 节[断点条件]，第 76 页。

`rbreak regex`
根据正则表达式`regex`在所有匹配的函数上设置断点。此命令在所有匹配项上设置无条件断点，并打印它设置的所有断点的列表。一旦设置了这些断点，它们就像使用`break`命令设置的断点一样处理。您可以删除、禁用它们，或以与任何其他断点相同的方式使其成为条件断点。

在使用不同语言的程序中，gdb根据`'set language'`值选择打印它设置的所有断点的列表的语法：使用`'set language auto'`（请参阅第 15.1.3 节[自动设置语言]，第 228 页）意味着使用断点函数的语言，其他值意味着使用手动指定的语言（请参阅第 15.1.2 节[手动设置语言]，第 228 页）。

正则表达式的语法是与诸如`grep`之类的工具使用的标准语法相同。请注意，这与 shell 使用的语法不同，因此例如`foo*`匹配所有包含`fo`后跟零个或多个`o`的函数。

您提供的正则表达式前后有隐式的`.*`，因此要仅匹配以`foo`开头的函数，请使用`^foo`。

在调试 C++程序时，`rbreak`对于在不是任何特殊类成员的重载函数上设置断点很有用。

`rbreak`命令可用于在程序中的所有函数上设置断点，如下所示：

```
(gdb) rbreak.
```

`rbreak file:regex`
如果`rbreak`带有文件名限定，则将搜索匹配给定正则表达式的函数限制在指定文件中。例如，这可用于在给定文件中的每个函数上设置断点：

```
(gdb) rbreak file.c:.
```

分隔文件名限定和正则表达式的冒号可以可选地被空格包围。

`info breakpoints [list...]`
`info break [list...]`
打印所有设置且未删除的断点、监视点、跟踪点和捕获点的表格。可选参数`n`表示仅打印指定的断点（或监视点或跟踪点或捕获点）的信息。对于每个断点，将打印以下列：
- 断点编号
- 类型 断点、监视点、跟踪点或捕获点。
- 处置 断点被命中时是否被标记为禁用或删除。
- 启用或禁用 启用的断点用`y`标记。`n`标记未启用的断点。
- 地址 程序中断点所在的位置，作为内存地址。对于地址尚未可知的挂起断点，此字段将包含`<PENDING>`。在加载具有断点所引用的符号或行的共享库之前，此类断点不会触发。有关详细信息，请参阅下文。具有多个位置的断点此字段将包含`<MULTIPLE>` - 有关详细信息，请参阅下文。
- 什么 程序源代码中断点所在的位置，作为文件和行号。对于挂起断点，传递给断点命令的原始字符串将被列出，因为在将来加载适当的共享库之前无法解析。

如果断点是有条件的，则有两种评估模式：“主机”和“目标”。如果模式是“主机”，则由gdb在主机端评估断点条件。如果是“目标”，则条件由目标评估。

`info break`命令在受影响的断点的下一行显示条件，以及条件评估模式（在括号之间）。断点命令（如果有）在那之后列出。挂起断点允许为其指定条件。在加载允许挂起断点解析为有效位置的共享库之前，不会解析条件的有效性。

`info break`以断点编号`n`作为参数时仅列出该断点。便利变量`$_`和`x`命令的默认检查地址设置为最后列出的断点的地址（请参阅第 10.6 节[检查内存]，第 152 页）。

`info break`显示断点被命中的次数。这与`ignore`命令结合使用时特别有用。您可以忽略大量的断点命中，查看断点信息以查看断点被命中的次数，然后再次运行，忽略比该次数少一次。这将使您快速到达该断点的最后一次命中。

对于启用计数（xref）大于 1 的断点，`info break`还会显示该计数。

gdb 允许您在程序的同一位置设置任意数量的断点。这并非愚蠢或无意义。当断点是有条件的时，这甚至是有用的（请参阅第 5.1.6 节[断点条件]，第 76 页）。

在您的程序中，单个逻辑断点可能会设置在多个代码位置。有关示例，请参阅第 9.2 节[位置规范]，第 126 页。

具有多个代码位置的断点在断点表中使用多行显示 - 一个标题行，然后是每个代码位置的一行。标题行在地址列中具有`<MULTIPLE>` 。每个代码位置行包含其实际地址、源文件、源行和函数。代码位置的编号列的形式为断点编号.位置编号。

例如：

```
Num Type Disp Enb Address What
1 breakpoint keep y <MULTIPLE>
stop only if i==1
breakpoint already hit 1 time
1.1 y 0x080486a2 in void foo<int>() at t.cc:8
1.2 y 0x080486ca in void foo<double>() at t.cc:8
```

您不能从断点中删除单个位置。但是，每个位置都可以通过将断点编号.位置编号作为参数传递给 `enable` 和 `disable` 命令来单独启用或禁用。还可以使用断点编号和两个位置编号（按升序，用连字符分隔）来启用和禁用一系列位置编号位置，例如断点编号.位置编号 1 - 位置编号 2，在这种情况下，gdb 会对范围内的所有位置（包括）进行操作。

禁用或启用父断点（请参阅第 5.1.5 节[禁用]，第 74 页）会影响属于该断点的所有位置。

当父断点被禁用时启用的位置不会触发中断，在 `Enb` 列中用 `y-` 表示。例如：

```
(gdb) info breakpoints
Num Type Disp Enb Address What
1 breakpoint keep n <MULTIPLE>
1.1 y- 0x00000000000011b6 in...
1.2 y- 0x00000000000011c2 in...
1.3 n 0x00000000000011ce in...
```

在共享库中设置断点是很常见的。在程序执行期间，共享库可以显式地加载和卸载，并且可能会多次进行。

为了支持这种用例，gdb 会在加载或卸载任何共享库时更新断点位置。通常，您会在调试会话开始时在共享库中设置断点，此时库尚未加载，并且库中的符号不可用。当您尝试设置断点时，gdb 会询问您是否要设置所谓的挂起断点 - 地址尚未解析的断点。

程序运行后，每当加载新的共享库时，gdb 会重新评估所有断点。当新加载的共享库包含某些挂起断点所引用的符号或行时，该断点将被解析并成为普通断点。当库卸载时，所有引用其符号或源行的断点再次变为挂起状态。

这种逻辑也适用于具有多个位置的断点。例如，如果您在 C++ 模板函数中有一个断点，并且新加载的共享库具有该模板的实例化，则会为断点的位置列表添加一个新位置。

除了地址未解析之外，挂起断点与常规断点没有区别。您可以设置条件或命令，启用和禁用它们，并执行其他断点操作。

gdb 提供了一些其他命令来控制当 `'break'` 命令无法将位置规范解析为程序中的任何代码位置时会发生什么（请参阅第 9.2 节[位置规范]，第 126 页）：

`set breakpoint pending auto` 这是默认行为。当 gdb 无法解析位置规范时，它会询问您是否应创建挂起断点。

`set breakpoint pending on` 这表示当 gdb 无法解析位置规范时，它应在未经确认的情况下创建挂起断点。

`set breakpoint pending off` 这表示不应创建挂起断点。如果 gdb 无法解析位置规范，它会因错误而中止断点创建。此设置不会影响之前创建的任何挂起断点。

`show breakpoint pending` 显示创建挂起断点的当前行为设置。

上述设置仅影响 `break` 命令及其变体。一旦设置了断点，它将在加载和卸载共享库时自动更新。

对于某些目标，gdb 可以根据断点地址是只读还是读写来自动决定应使用硬件还是软件断点。这适用于使用 `break` 命令设置的断点以及诸如 `next` 和 `finish` 等命令设置的内部断点。对于使用 `hbreak` 设置的断点，gdb 将始终使用硬件断点。

您可以使用以下命令控制此自动行为：

`set breakpoint auto-hw on` 这是默认行为。当 gdb 设置断点时，它将尝试使用目标内存映射来决定应使用软件还是硬件断点。

`set breakpoint auto-hw off` 这表示 gdb 不应自动选择断点类型。如果目标提供内存映射，gdb 在尝试在只读地址设置软件断点时会发出警告。

gdb 通常通过在断点地址处用特殊指令替换程序代码来实现断点，当执行该指令时，将控制权交给调试器。默认情况下，只有在程序恢复时才会修改程序代码。程序一停止，gdb 就会恢复原始指令。这种行为可防止 gdb 突然断开连接时在目标中留下插入的断点。但是，对于远程目标速度较慢的情况，插入和删除断点可能会降低性能。此行为可以通过以下命令控制：

`set breakpoint always-inserted off` 所有断点（包括用户新添加的）仅在目标恢复时才插入目标。目标停止时，所有断点都从目标中删除。这是默认模式。

`set breakpoint always-inserted on` 导致所有断点始终插入目标。如果用户添加新断点或更改现有断点，目标中的断点会立即更新。只有在删除断点本身时，才会从目标中删除断点。

gdb 通过在断点中断时评估这些条件来处理条件断点。如果条件为真，则正在调试的进程停止，否则进程继续。

如果目标支持在其端评估条件，gdb 可能会将断点及其条件下载到目标。

此功能可以通过以下命令控制：

`set breakpoint condition-evaluation host` 此选项命令 gdb 在主机端评估断点条件。无条件断点被发送到目标，目标反过来接收触发并将其报告回 GDB 以进行条件评估。这是标准评估模式。

`set breakpoint condition-evaluation target` 此选项命令 gdb 在插入时将断点条件下载到目标。目标负责评估条件表达式，并在条件为真时将断点停止事件报告回 gdb。由于目标端评估的限制，某些条件无法在那里评估，例如，依赖于主机才知道的本地数据的条件。示例包括涉及便利变量的条件表达式、代理表达式解析器无法处理的复杂类型以及太长而无法发送到目标的表达式，特别是当目标是远程系统时。在这些情况下，条件将由 gdb 评估。

`set breakpoint condition-evaluation auto` 这是默认模式。如果目标支持在其端评估断点条件，gdb 将把断点条件下载到目标（适用前面提到的限制）。如果目标不支持断点条件评估，则 gdb 将回退到在主机端评估所有这些条件。

gdb 本身有时会在您的程序中设置断点以用于特殊目的，例如正确处理 `longjmp` （在 C 程序中）。这些内部断点被分配负数，从 `-1` 开始；`'info breakpoints'` 不会显示它们。您可以使用 gdb 维护命令 `'maint info breakpoints'` 查看这些断点（请参阅[`maint info breakpoints`]，第 757 页）。

### 5.1.2 设置监视点

您可以使用监视点在表达式的值发生变化时停止执行，而无需预测可能发生这种情况的特定位置。（这有时称为数据断点。）表达式可以像单个变量的值一样简单，也可以像由运算符组合的多个变量一样复杂。示例包括：
• 对单个变量值的引用。
• 转换为适当数据类型的地址。例如，`*(int *)0x12345678` 将监视指定地址的 4 字节区域（假设 `int` 占用 4 个字节）。
• 任意复杂的表达式，例如 `a*b + c/d` 。表达式可以使用程序原生语言中有效的任何运算符（请参阅第 15 章[语言]，第 227 页）。

您可以在表达式无法求值时设置监视点。例如，您可以在 `global_ptr` 初始化之前设置对 `*global_ptr` 的监视点。当您的程序设置 `global_ptr` 并且表达式产生有效值时，gdb 将停止。如果表达式通过更改变量以外的方式变得有效（例如，如果 `*global_ptr` 指向的内存由于 `malloc` 调用而变得可读），gdb 可能要等到表达式下一次更改时才会停止。

根据您的系统，监视点可以在软件或硬件中实现。

gdb 通过单步执行您的程序并每次测试变量的值来进行软件监视点，这比正常执行慢数百倍。（但这仍然可能是值得的，以捕获您不知道程序的哪一部分是罪魁祸首的错误。）

在某些系统上，例如大多数 PowerPC 或基于 x86 的目标，gdb 包括对硬件监视点的支持，这不会减慢您的程序的运行速度。

`watch [-l|-location] expr [thread thread-id] [mask maskvalue] [task task-id]`
为表达式设置监视点。当程序写入表达式 `expr` 并且其值发生变化时，gdb 将中断。此命令的最简单（也是最常用）用法是监视单个变量的值：

```
(gdb) watch foo
```

如果命令包含 `[thread thread-id]` 参数，只有当由 `thread-id` 标识的线程更改 `expr` 的值时，gdb 才会中断。如果任何其他线程更改 `expr` 的值，gdb 不会中断。请注意，以这种方式限制在单个线程的监视点仅适用于硬件监视点。

类似地，如果给出了任务参数，则监视点将特定于指定的 Ada 任务（请参阅第 15.4.10.7 节[Ada 任务]，第 255 页）。

通常，监视点尊重 `expr` 中变量的作用域（见下文）。

`-location` 参数告诉 gdb 改为监视 `expr` 引用的内存。在这种情况下，gdb 将求值 `expr`，获取结果的地址，并监视该地址的内存。结果的类型用于确定监视的内存大小。如果表达式的结果没有地址，则 gdb 将打印错误。

`[mask maskvalue]` 参数允许创建掩码监视点，如果当前体系结构支持此功能（例如，PowerPC 嵌入式体系结构，请参阅第 21.3.8 节[PowerPC 嵌入式]，第 352 页）。掩码监视点除了要监视的地址外还指定一个掩码。掩码指定在将下级访问的地址与监视点地址进行匹配时应忽略地址的某些位（在掩码中重置的位）。因此，掩码监视点同时监视多个地址 - 那些未掩码位与监视点地址的未掩码位相同的地址。掩码参数意味着 `-location` 。示例：

```
(gdb) watch foo mask 0xffff00ff
(gdb) watch *0xdeadbeef mask 0xffffff00
```

`rwatch [-l|-location] expr [thread thread-id] [mask maskvalue]`
设置当程序读取 `expr` 的值时将中断的监视点。

`awatch [-l|-location] expr [thread thread-id] [mask maskvalue]`
设置当程序读取或写入 `expr` 时将中断的监视点。

`info watchpoints [list...]`
此命令使用与 `info break`（请参阅第 5.1.1 节[设置断点]，第 58 页）相同的格式打印监视点列表。

如果您监视数字输入地址的更改，则需要对其进行解引用，因为地址本身只是一个永远不会更改的常量数字。gdb 拒绝创建监视永远不变值的监视点：

```
(gdb) watch 0x600850
Cannot watch constant value 0x600850.
(gdb) watch *(int *) 0x600850
Watchpoint 1: *(int *) 6293584
```

gdb 尽可能设置硬件监视点。硬件监视点执行速度非常快，调试器在发生更改的确切指令处报告值的更改。

如果 gdb 无法设置硬件监视点，它将设置软件监视点，其执行速度较慢，并在更改发生后的下一个语句（而不是指令）处报告值的更改。

您可以使用 `set can-use-hw-watchpoints 0` 命令强制 gdb 仅使用软件监视点。将此变量设置为零，gdb 永远不会尝试使用硬件监视点，即使底层系统支持它们。（请注意，在将 `can-use-hw-watchpoints` 设置为零之前设置的硬件辅助监视点仍将使用监视表达式值的硬件机制。）

`set can-use-hw-watchpoints`
设置是否使用硬件监视点。

`show can-use-hw-watchpoints`
显示使用硬件监视点的当前模式。

对于远程目标，您可以限制 gdb 将使用的硬件监视点数量，请参阅[设置远程硬件断点限制]，第 327 页。

当您发出 `watch` 命令时，如果能够设置硬件监视点，gdb 会报告

```
Hardware watchpoint num: expr
```

目前，`awatch` 和 `rwatch` 命令只能设置硬件监视点，因为如果不检查执行的每个指令，就无法检测到不更改监视表达式值的数据访问，而 gdb 目前不这样做。如果 gdb 发现无法使用 `awatch` 或 `rwatch` 命令设置硬件断点，它将打印如下消息：

```
Expression cannot be implemented with read/access watchpoint.
```

有时，gdb 无法设置硬件监视点，因为监视表达式的数据类型比目标机器上的硬件监视点所能处理的更宽。例如，某些系统只能监视最多 4 字节宽的区域；在这样的系统上，您不能为产生双精度浮点数（通常为 8 字节宽）的表达式设置硬件监视点。作为一种解决方法，可能可以将大区域分解为一系列较小的区域，并使用单独的监视点来监视它们。

如果您设置了太多的硬件监视点，gdb 在恢复程序执行时可能无法插入所有监视点。由于在程序即将恢复之前，活动监视点的精确数量是未知的，gdb 在您设置监视点时可能无法警告您，并且仅在程序恢复时打印警告：

```
Hardware watchpoint num: Could not insert watchpoint
```

如果发生这种情况，请删除或禁用一些监视点。

监视引用许多变量的复杂表达式也可能耗尽硬件辅助监视点可用的资源。这是因为 gdb 需要使用单独分配的资源监视表达式中的每个变量。

如果您使用 `print` 或 `call` 交互式地调用函数，您设置的任何监视点将处于非活动状态，直到 gdb 到达另一种断点或调用完成。

gdb 会在局部（自动）变量或涉及此类变量的表达式超出作用域时自动删除监视这些变量的监视点，也就是说，当执行离开定义这些变量的块时。特别是，当被调试的程序终止时，所有局部变量都超出作用域，因此只有监视全局变量的监视点仍然设置。如果您重新运行程序，则需要再次设置所有此类监视点。一种方法是在 `main` 函数的入口处设置一个代码断点，当它中断时，设置所有监视点。

在多线程程序中，监视点将检测来自每个线程的对监视表达式的更改。

警告：在多线程程序中，软件监视点的用处有限。如果 gdb 创建了一个软件监视点，它只能在单个线程中监视表达式的值。如果您确信表达式只能由于当前线程的活动而更改（并且如果您还确信没有其他线程可以变为当前线程），那么您可以像往常一样使用软件监视点。但是，gdb 可能不会注意到非当前线程的活动更改了表达式。（相比之下，硬件监视点在所有线程中监视表达式。）

请参阅[设置远程硬件监视点限制]，第 327 页。

### 5.1.3 设置捕获点

您可以使用捕获点来使调试器在某些程序事件发生时停止，例如 C++ 异常或共享库的加载。使用 `catch` 命令来设置捕获点。

`catch event`
当 `event` 发生时停止。`event` 可以是以下任何一种：
- `throw [regexp]`
- `rethrow [regexp]`
- `catch [regexp]`
C++ 异常的抛出、重新抛出或捕获。
如果提供了 `regexp`，则仅捕获类型与正则表达式匹配的异常。

在某些系统上，与异常相关的捕获点处可用便利变量 `$_exception`。这保存了正在抛出的异常。

gdb 中的 C++ 异常处理目前存在一些限制：
• 对这些命令的支持取决于系统。
目前，仅支持使用 `'gnu-v3'` C++ ABI（请参阅第 22.7 节[ABI]，第 375 页）的系统。
• 正则表达式功能和 `$_exception` 便利变量依赖于 `libstdc++` 中某些 SDT 探测的存在。如果这些探测不存在，则无法使用这些功能。这些探测在 GCC 4.8 版本中首次可用，但您的 GCC 中是否存在它们还取决于它的构建方式。
• `$_exception` 便利变量仅在设置异常相关捕获点的指令处有效。
• 当与异常相关的捕获点命中时，gdb 会在实现 C++ 运行时异常支持的系统库中的某个位置停止，通常是 `libstdc++`。您可以使用 `up`（请参阅第 8.3 节[选择]，第 117 页）到达您的代码。
• 如果您以交互方式调用函数，gdb 通常在函数执行完成时将控制权返回给您。但是，如果调用引发异常，则调用可能绕过将控制权返回给您的机制，并导致您的程序要么中止，要么简单地继续运行，直到它命中断点、捕获 gdb 正在监听的信号或退出。即使您为异常设置了捕获点，在交互调用中对异常的捕获点也会被禁用。有关使用 `set unwind-on-terminating-exception` 控制此情况的信息，请参阅第 17.5 节[调用]，第 281 页。
• 您不能以交互方式引发异常。
• 您不能以交互方式安装异常处理程序

`exception [name]`
Ada 异常被引发。如果在命令末尾指定了异常名称（例如 `catch exception Program_Error`），则调试器仅在引发此特定异常时停止。否则，调试器在引发任何 Ada 异常时停止执行。

当在用户定义的异常上插入异常捕获点，其名称与语言定义的异常之一相同，则必须使用完全限定名称作为异常名称。否则，gdb 将假定它应该在预定义的异常而不是用户定义的异常上停止。例如，假设在包 `Pck` 中定义了一个名为 `Constraint_Error` 的异常，则用于捕获此类异常的命令是 `catch exception Pck.Constraint_Error`。

便利变量 `$_ada_exception` 保存正在抛出的异常的地址。在为此类捕获点设置条件时这可能很有用。

`exception unhandled`
引发但未被程序处理的异常。
为 `catch exception` 设置 `$_ada_exception` 便利变量。

`handlers [name]`
Ada 异常被处理。如果在命令末尾指定了异常名称（例如 `catch handlers Program_Error`），则调试器仅在处理此特定异常时停止。否则，调试器在处理任何 Ada 异常时停止执行。

当在用户定义的异常上插入处理程序捕获点，其名称与语言定义的异常之一相同，则必须使用完全限定名称作为异常名称。否则，gdb 将假定它应该在预定义的异常而不是用户定义的异常上停止。例如，假设在包 `Pck` 中定义了一个名为 `Constraint_Error` 的异常，则用于捕获此类异常处理的命令是 `catch handlers Pck.Constraint_Error`。

为 `catch exception` 设置 `$_ada_exception` 便利变量。

`assert`
Ada 断言失败。请注意，此捕获点不会设置便利变量 `$_ada_exception`。

`exec`
调用 `exec`。

`syscall`
`syscall [name | number | group:groupname | g:groupname]...`
系统调用的调用或返回，又名系统调用。系统调用是应用程序向操作系统（OS）或操作系统服务之一请求服务的机制。gdb 可以捕获调试目标发出的部分或全部系统调用，并显示每个系统调用的相关信息。如果未指定参数，则将捕获对所有系统调用的调用和返回。

`name` 可以是底层操作系统有效的任何系统调用名称。哪些系统调用有效取决于操作系统。在 GNU 和 Unix 系统上，您可以在 `/usr/include/asm/unistd.h` 中找到有效的系统调用名称的完整列表。

通常，gdb 预先知道每个操作系统哪些系统调用是有效的，因此您可以使用 gdb 命令行完成功能（请参阅第 3.3 节[命令完成]，第 24 页）列出可用的选择。

您也可以通过数字指定系统调用。系统调用的编号是传递给操作系统的系统调用调度程序以标识请求的服务的值。当您通过名称指定系统调用时，gdb 使用其系统调用数据库将名称转换为相应的数字代码，但如果 gdb 的数据库在您的系统上没有完整的系统调用列表（例如，因为 gdb 落后于操作系统升级），直接使用数字可能很有用。

您可以使用 `group:` 语法（`g:` 是较短的等效形式）一次指定要捕获的一组相关系统调用。例如，在某些平台上，gdb 允许您通过传递参数 `group:network` 来捕获所有与网络相关的系统调用。请注意，并非所有系统调用组在每个系统中都可用。您可以使用命令完成功能（请参阅第 3.3 节[命令完成]，第 24 页）列出您的环境中可用的系统调用组。

下面的示例说明了如果您不向此命令提供参数，它是如何工作的：

```
(gdb) catch syscall
Catchpoint 1 (syscall)
(gdb) r
Starting program: /tmp/catch-syscall
Catchpoint 1 (call to syscall ’close’), \
0xffffe424 in __kernel_vsyscall ()
(gdb) c
Continuing.
Catchpoint 1 (returned from syscall ’close’), \
0xffffe424 in __kernel_vsyscall ()
(gdb)
```

这是一个按名称捕获系统调用的示例：

```
(gdb) catch syscall chroot
Catchpoint 1 (syscall ’chroot’ [61])
(gdb) r
Starting program: /tmp/catch-syscall
Catchpoint 1 (call to syscall ’chroot’), \
0xffffe424 in __kernel_vsyscall ()
(gdb) c
Continuing.
Catchpoint 1 (returned from syscall ’chroot’), \
0xffffe424 in __kernel_vsyscall ()
(gdb)
```

一个通过数字指定系统调用的示例。在下面的情况中，系统调用编号在 XML 文件中有相应的条目，因此 gdb 找到了它的名称并打印出来：

```
(gdb) catch syscall 252
Catchpoint 1 (syscall(s) ’exit_group’)
(gdb) r
Starting program: /tmp/catch-syscall
Catchpoint 1 (call to syscall ’exit_group’), \
0xffffe424 in __kernel_vsyscall ()
(gdb) c
Continuing.
Program exited normally.
(gdb)
```

这是一个捕获系统调用组的示例：

```
(gdb) catch syscall group:process
Catchpoint 1 (syscalls ’exit’ [1] ’fork’ [2] ’waitpid’ [7]
’execve’ [11] ’wait4’ [114] ’clone’ [120] ’vfork’ [190]
’exit_group’ [252] ’waitid’ [284] ’unshare’ [310])
(gdb) r
Starting program: /tmp/catch-syscall
Catchpoint 1 (call to syscall fork), 0x00007ffff7df4e27 in open64 ()
from /lib64/ld-linux-x86-64.so.2
(gdb) c
Continuing.
```

但是，可能存在这种情况，即对于该系统调用编号，XML 文件中没有相应的名称。在这种情况下，gdb 会打印一条警告消息，说明它无法找到系统调用名称，但无论如何都会设置捕获点。请参见下面的示例：

```
(gdb) catch syscall 764
warning: The number ’764’ does not represent a known syscall.
Catchpoint 2 (syscall 764)
(gdb)
```

如果您使用 `'--without-expat'` 选项配置 gdb，它将无法显示系统调用名称。此外，如果您的体系结构没有描述其系统调用的 XML 文件，您将无法看到系统调用名称。重要的是要注意，这两个功能用于访问系统调用名称数据库。在任何一种情况下，您都会看到如下警告：

```
(gdb) catch syscall
warning: Could not open "syscalls/i386-linux.xml"
warning: Could not load the syscall XML file ’syscalls/i386-linux.xml’.
GDB will not be able to display syscall names.
Catchpoint 1 (syscall)
(gdb)
```

当然，文件名会根据您的体系结构和系统而变化。

仍然使用上面的示例，您也可以尝试通过数字捕获系统调用。在这种情况下，您会看到类似这样的内容：

```
(gdb) catch syscall 252
Catchpoint 1 (syscall(s) 252)
```

同样，在这种情况下，gdb 将无法显示系统调用的名称。

`fork`
调用 `fork`。

`vfork`
调用 `vfork`。

`load [regexp]`
`unload [regexp]`
共享库的加载或卸载。如果提供了 `regexp`，则仅当正则表达式与受影响的库之一匹配时，捕获点才会停止。

`signal [signal... | ‘all’]`
信号的传递。
如果没有参数，此捕获点将捕获除 gdb 内部使用的所有信号，特别是除 `SIGTRAP` 和 `SIGINT` 之外的所有信号。
使用 `all` 参数，将捕获所有信号，包括 gdb 使用的信号。此参数不能与其他信号名称一起使用。
否则，参数是传递给 `handle`（请参阅第 5.4 节[信号]，第 89 页）的信号名称列表。仅捕获在此列表中指定的信号。

`catch signal` 比 `handle` 更有用的一个原因是您可以为捕获点附加命令和条件。
当捕获点捕获信号时，`handle` 指定的信号的停止和打印设置将被忽略。但是，信号是否仍传递给下级取决于 `pass` 设置；这可以在捕获点的命令中更改。

`tcatch event`
设置仅启用一次停止的捕获点。捕获事件第一次被捕获后，捕获点将自动删除。

使用 `info break` 命令列出当前的捕获点。

### 5.1.4 删除断点（Deleting Breakpoints）

通常，当断点、观察点或捕获点完成其任务并且您不再希望程序在此停止时，就有必要将其删除。这称为删除断点。已删除的断点不再存在，已被遗忘。

使用 `clear` 命令，您可以根据断点在程序中的位置来删除它们。使用 `delete` 命令，您可以通过指定断点编号来删除单个断点、观察点或捕获点。

不必为了越过断点而删除它。当您继续执行而不更改执行地址时，`gdb` 会自动忽略在要执行的第一条指令上的断点。

`clear`
在所选堆栈帧中要执行的下一条指令处删除任何断点（请参阅第 8.3 节[选择帧]，第 117 页）。当选择最内层帧时，这是删除程序刚刚停止处的断点的好方法。

`clear locspec`
删除任何与 `locspec` 对应的代码位置的断点。有关 `locspec` 的各种形式，请参阅第 9.2 节[位置规范]，第 126 页。

与 `locspec` 对应的代码位置取决于 `locspec` 位置规范中使用的形式：

`linenum`
`filename:linenum`
`-line linenum`
`-source filename -line linenum`

如果 `locspec` 指定了行号（无论是否带有文件名），该命令将删除在与指定 `filename` 匹配的文件中位于或处于指定行 `linenum` 内的任何断点。如果省略 `filename`，则默认为当前源文件。

`*address`
如果 `locspec` 指定了地址，则该命令将删除位于给定地址的任何断点。

`function`
`-function function`

如果 `locspec` 指定了函数，则该命令将删除位于任何名称与 `function` 匹配的函数入口处的任何断点。

文件和函数名称的歧义可以按照第 9.2 节[位置规范]（第 126 页）中所述的方式解决。

`delete [breakpoints] [list...]`
删除作为参数指定的断点列表中的断点、观察点、跟踪点或捕获点。如果未指定参数，则删除所有断点、观察点、跟踪点和捕获点（`gdb` 会询问确认，除非您已设置 `confirm off`）。您可以将此命令缩写为 `d`。

### 5.1.5 禁用断点（Disabling Breakpoints）

与其删除断点、观察点或捕获点，您可能更愿意禁用它。这会使断点不起作用，就好像已被删除一样，但会记住断点的信息，以便您以后再次启用它。

您可以使用 `enable` 和 `disable` 命令来禁用和启用断点、观察点、跟踪点和捕获点，并可以选择指定一个或多个断点编号作为参数。如果不知道使用哪些编号，可以使用 `info break` 打印所有断点、观察点、跟踪点和捕获点的列表。

禁用和启用具有多个位置的断点会影响其所有位置。

断点、观察点或捕获点可以具有以下几种不同的启用状态：

• 启用。断点会使您的程序停止。使用 `break` 命令设置的断点最初处于此状态。

• 禁用。断点对您的程序没有影响。

• 启用一次。断点会使您的程序停止，但随后会被禁用。

• 启用计数。断点会使您的程序在接下来的 `N` 次停止，然后被禁用。

• 启用删除。断点会使您的程序停止，但在停止后会立即被永久删除。使用 `tbreak` 命令设置的断点最初处于此状态。

您可以使用以下命令来启用或禁用断点、观察点、跟踪点和捕获点：

`disable [breakpoints] [list...]`
禁用指定的断点 - 如果未列出，则禁用所有断点。禁用的断点没有效果，但不会被遗忘。所有选项（例如忽略计数、条件和命令）都会被记住，以防断点再次启用。您可以将 `disable` 缩写为 `dis`。

`enable [breakpoints] [list...]`
启用指定的断点（或所有已定义的断点）。它们再次在停止您的程序时生效。

`enable [breakpoints] once list...`
临时启用指定的断点。`gdb` 在程序停止后立即禁用这些断点中的任何一个。

`enable [breakpoints] count count list...`
临时启用指定的断点。`gdb` 为每个指定的断点记录 `count`，并且在命中时递减断点的计数。当任何计数达到 0 时，`gdb` 禁用该断点。如果断点具有忽略计数（请参阅第 5.1.6 节[断点条件]，第 76 页），则在 `count` 受到影响之前，该忽略计数将递减到 0。

`enable [breakpoints] delete list...`
启用指定的断点以工作一次，然后消失。`gdb` 在您的程序在此停止后立即删除这些断点中的任何一个。使用 `tbreak` 命令设置的断点最初处于此状态。

除了使用 `tbreak` 设置的断点（请参阅第 5.1.1 节[设置断点]，第 58 页）之外，您设置的断点最初是启用的；随后，只有在您使用上述命令之一时，它们才会被禁用或启用。（`until` 命令可以设置和删除自己的断点，但它不会更改您的其他断点的状态；请参阅第 5.2 节[继续和单步执行]，第 83 页。） 

### 5.1.6 断点条件（Break Conditions）

最简单的断点类型是每次程序到达指定位置时都会中断。您还可以为断点指定一个条件。条件只是您所使用编程语言中的布尔表达式（请参阅第 10.1 节[表达式]，第 145 页）。带有条件的断点每次程序到达时都会计算表达式，并且只有当条件为真时，程序才会停止。

这与使用断言进行程序验证相反；在那种情况下，当断言被违反时（即条件为假时），您希望停止。在 C 语言中，如果您想要测试由条件 `assert` 表示的断言，您应该在适当的断点上设置条件 `! assert` 。

观察点也接受条件；您可能不需要它们，因为观察点无论如何都在检查表达式的值 - 但可能更简单，例如，只需在变量名称上设置观察点，并指定一个测试新值是否有趣的条件。

断点条件可能有副作用，甚至可能调用您程序中的函数。这可能很有用，例如，激活记录程序进度的函数，或者使用您自己的打印函数来格式化特殊的数据结构。除非在同一地址还有另一个启用的断点，否则效果是完全可预测的。（在这种情况下，`gdb` 可能首先看到另一个断点，并在不检查此断点条件的情况下停止您的程序。）请注意，在到达断点时执行副作用的目的，断点命令通常比断点条件更方便和灵活（请参阅第 5.1.7 节[断点命令列表]，第 77 页）。

如果目标支持，断点条件也可以在目标端进行评估。`gdb` 不是在本地评估条件，而是将表达式编码为适合在目标上执行的代理表达式（请参阅附录 F [代理表达式]，第 849 页），独立于 `gdb` 。全局变量成为原始内存位置，局部变量成为堆栈访问等等。

在这种情况下，只有当条件计算结果为真时，`gdb` 才会收到断点触发的通知。根据目标的性能特征，此机制可能提供更快的响应时间，因为它不需要将每个断点触发（即使条件为假）通知 `gdb` 。

断点条件可以在设置断点时通过在 `break` 命令的参数中使用 `if` 来指定。请参阅第 5.1.1 节[设置断点]，第 58 页。它们也可以随时使用 `condition` 命令更改。

您还可以在 `watch` 命令中使用 `if` 关键字。`catch` 命令不识别 `if` 关键字；`condition` 是对捕获点施加进一步条件的唯一方法。

`condition bnum expression`
为断点、观察点或捕获点编号 `bnum` 指定 `expression` 作为断点条件。设置条件后，只有当 `expression` 的值为真（在 C 语言中为非零）时，断点 `bnum` 才会停止您的程序。使用 `condition` 时，`gdb` 会立即检查 `expression` 的语法正确性，并确定其中的符号在断点上下文中是否有引用。如果 `expression` 使用了在断点上下文中未引用的符号，`gdb` 会打印错误消息：

`No symbol "foo" in current context.`

然而，在给出 `condition` 命令（或设置带有条件的断点的命令，如 `break if...`）时，`gdb` 实际上并不会立即计算 `expression` 。请参阅第 10.1 节[表达式]，第 145 页。

`condition -force bnum expression`
使用 `-force` 标志时，即使在断点 `bnum` 的所有当前位置 `expression` 无效，也定义条件。这类似于 `break` 命令的 `-force-condition` 选项。

`condition bnum`
从编号为 `bnum` 的断点中删除条件。它变为普通的无条件断点。

断点条件的一种特殊情况是仅在断点达到一定次数时停止。这非常有用，因此有一种特殊的方法来实现，即使用断点的忽略计数。每个断点都有一个忽略计数，它是一个整数。大多数时候，忽略计数为零，因此没有效果。但是，如果您的程序到达一个忽略计数为正的断点，那么它不会停止，而是将忽略计数减 1 并继续。因此，如果忽略计数值为 `n`，则在您的程序接下来 `n` 次到达该断点时，它不会停止。

`ignore bnum count`
将编号为 `bnum` 的断点的忽略计数设置为 `count` 。在接下来达到该断点的 `count` 次中，您的程序的执行不会停止；除了递减忽略计数外，`gdb` 不采取任何行动。

要使断点在下次到达时停止，请指定计数为零。

当您使用 `continue` 从断点恢复程序执行时，可以直接将忽略计数作为 `continue` 的参数指定，而不是使用 `ignore` 。请参阅第 5.2 节[继续和单步执行]，第 83 页。

如果断点具有正的忽略计数和条件，则不检查条件。一旦忽略计数达到零，`gdb` 恢复检查条件。

您可以使用诸如 `$foo-- <= 0` 这样的条件，并使用每次递减的调试器便利变量来实现忽略计数的效果。请参阅第 10.12 节[便利变量]，第 171 页。

忽略计数适用于断点、观察点、跟踪点和捕获点。

### 5.1.7 断点命令列表（Breakpoint Command Lists）

您可以为任何断点（或观察点或捕获点）提供一系列命令，当程序由于该断点停止时执行。例如，您可能想要打印某些表达式的值，或者启用其他断点。

`commands [list...]`
`... command-list...`
`end` 
为给定的断点指定一个命令列表。命令本身出现在后续行。输入仅包含 `end` 的行来终止命令。

要从断点中删除所有命令，输入 `commands` 并立即跟随 `end` ；也就是说，不给出任何命令。

如果没有参数，`commands` 指的是最后设置的断点、观察点或捕获点（而不是最近遇到的断点）。如果最近的断点是通过单个命令设置的，那么命令将应用于该命令设置的所有断点。这适用于通过 `rbreak` 设置的断点，并且当单个 `break` 命令创建多个断点时也适用（请参阅第 10.2 节[模糊表达式]，第 146 页）。

在命令列表内，按 `RET` 键重复上一个 `gdb` 命令的功能被禁用。

在命令列表内部，您可以使用命令 `disable $_hit_bpnum` 来禁用遇到的断点。

如果您的断点有多个代码位置，`disable $_hit_bpnum.$_hit_locno` 命令将禁用遇到的特定断点代码位置。如果断点只有一个位置，此命令将禁用遇到的断点。

您可以使用断点命令再次启动您的程序。只需使用 `continue` 命令，或者 `step` ，或者任何其他恢复执行的命令。

在恢复执行的命令之后的命令列表中的任何其他命令都将被忽略。这是因为每次您恢复执行（即使是简单的 `next` 或 `step`），您都可能遇到另一个断点 - 这可能有它自己的命令列表，导致关于执行哪个列表的歧义。

如果您在命令列表中指定的第一个命令是 `silent` ，则不会打印关于在断点处停止的常规消息。对于要打印特定消息然后继续的断点，这可能是理想的。如果其余的命令都没有打印任何内容，则您看不到到达断点的迹象。`silent` 仅在断点命令列表的开头才有意义。

命令 `echo` 、 `output` 和 `printf` 允许您进行精确控制的输出打印，并且在静默断点中经常很有用。请参阅第 23.1.4 节[受控输出命令]，第 397 页。

例如，以下是如何使用断点命令在每次 `x` 为正数进入 `foo` 时打印 `x` 的值。

```
break foo if x>0
commands
silent
printf "x is %d\n",x
cont
end
```

断点命令的一个应用是补偿一个错误，以便您可以测试另一个错误。在错误的代码行之后设置一个断点，给它一个条件来检测错误情况，并给它命令为任何需要的变量分配正确的值。以 `continue` 命令结束，以使您的程序不停止，并以 `silent` 命令开头，以便不产生输出。以下是一个示例：

```
break 403
commands
silent
set x = y + 4
cont
end
```

### 5.1.8 动态 `printf`（Dynamic Printf）

动态 `printf` 命令 `dprintf` 将断点与格式化打印您程序的数据相结合，让您无需重新编译程序就能即时在程序中插入 `printf` 调用的效果。

在其最基本的形式中，输出将发送到 `GDB` 控制台。然而，您可以设置变量 `dprintf-style` 以进行替代处理。例如，您可以要求通过调用您程序的 `printf` 函数来格式化输出。这样做的优点是字符会发送到程序的输出设备，因此它们可以在重定向到文件等操作中被记录。

如果您正在使用存根或代理进行远程调试，您还可以要求由远程代理处理 `printf` 。除了确保输出与程序可能产生的任何其他输出一起发送到远程程序的设备外，您还可以要求即使从远程目标断开连接后，`dprintf` 仍然保持活动。使用存根/代理也更有效，因为它可以在不需要与 `gdb` 通信的情况下完成所有操作。

`dprintf locspec,template,expression[,expression...]`
每当执行到达由解析 `locspec` 得到的代码位置时，根据字符串 `template` 的控制打印一个或多个表达式的值。要打印多个值，请用逗号分隔它们。

`set dprintf-style style`
将 `dprintf` 输出设置为以下几种不同风格之一进行处理。风格的更改会立即影响所有现有的动态 `printf` 。（如果您需要对打印命令进行单独控制，只需定义具有明确提供的命令列表的普通断点。）

`gdb` 使用 `gdb` 的 `printf` 命令处理输出。使用此风格时，可以使用 `%V` 格式说明符（请参阅[`%V` 格式说明符]，第 398 页）。

`call` 通过调用您程序中的函数（通常是 `printf`）来处理输出。使用此风格时，支持的格式说明符完全取决于被调用的函数。

`gdb` 的大多数格式说明符与 `printf` 函数支持的格式说明符对齐，但是，`printf` 不支持 `gdb` 的 `%V` 格式说明符扩展。使用 `call` 风格的 `dprintf` 时，应注意确保仅使用输出函数支持的格式说明符，否则结果将未定义。

`agent` 让远程调试代理（如 `gdbserver`）自己处理输出。此风格仅适用于支持在目标上运行命令的代理。此风格不支持 `%V` 格式说明符。

`set dprintf-function function`
如果 `dprintf` 风格为 `call` ，则设置要调用的函数。默认值为 `printf` 。您可以将其设置为 `gdb` 可以评估为函数的任何表达式，按照 `call` 命令的方式。

`set dprintf-channel channel`
为 `dprintf` 设置一个“通道”。如果设置为非空值，`gdb` 将其作为表达式进行评估，并将结果作为第一个参数传递给 `dprintf-function` ，类似于 `fprintf` 和类似的函数。否则，`dprintf` 格式字符串将是第一个参数，类似于 `printf` 。

例如，如果您希望 `dprintf` 输出到分配给变量 `mylog` 的标准 I/O 流的日志文件中，您可以执行以下操作：

```
(gdb) set dprintf-style call
(gdb) set dprintf-function fprintf
(gdb) set dprintf-channel mylog
(gdb) dprintf 25,"at line 25, glob=%d\n",glob
Dprintf 1 at 0x123456: file main.c, line 25.
(gdb) info break
1 dprintf keep y 0x00123456 in main at main.c:25
call (void) fprintf (mylog,"at line 25, glob=%d\n",glob)
continue
(gdb)
```

请注意，`info break` 显示动态 `printf` 命令为普通断点命令；因此，您可以轻松看到变量设置的效果。

`set disconnected-dprintf on`
`set disconnected-dprintf off`
选择如果 `gdb` 已与目标断开连接，`dprintf` 命令是否应继续运行。这仅适用于 `dprintf-style` 为 `agent` 的情况。

`show disconnected-dprintf off`
显示当前关于断开连接的 `dprintf` 的选择。

`gdb` 不检查函数和通道的有效性，依靠您提供对其使用上下文有意义的值。例如，函数和通道可能是局部变量的值，但如果是这种情况，则所有启用的动态打印必须位于这些局部变量的作用域内的位置。如果评估失败，`gdb` 将报告错误。

### 5.1.9 如何将断点保存到文件（How to save breakpoints to a file）

要将断点定义保存到文件中，请使用 `save breakpoints` 命令。

`save breakpoints [filename]`
此命令将所有当前断点定义及其命令和忽略计数保存到一个文件 `filename` 中，适用于在以后的调试会话中使用。这包括所有类型的断点（断点、观察点、捕获点、跟踪点）。要读取保存的断点定义，请使用 `source` 命令（请参阅第 23.1.3 节[命令文件]，第 395 页）。请注意，涉及局部变量的表达式的观察点可能无法重新创建，因为可能不再能够访问观察点有效的上下文。由于保存的断点定义只是重新创建断点的一系列 `gdb` 命令，您可以在您喜欢的编辑程序中编辑该文件，并删除您不感兴趣或无法重新创建的断点定义。

### 5.1.10 静态探测点（Static Probe Points）

`gdb` 在代码中支持 `SDT` 探测点。`SDT` 代表静态定义跟踪，并且探测点设计为具有极小的运行时代码和数据占用空间，并且没有动态重定位。

目前，在与 `ELF` 兼容的系统上支持以下类型的探测点：

• `SystemTap`（http://sourceware.org/systemtap/） `SDT` 探测点 1. `SystemTap` 探测点可从汇编、`C` 和 `C++` 语言中使用 2.

• `DTrace`（http://oss.oracle.com/projects/DTrace） `USDT` 探测点。`DTrace` 探测点可从 `C` 和 `C++` 语言中使用。

一些 `SystemTap` 探测点具有相关的信号量变量；例如，如果您使用 `DTrace` 风格的 `.d` 文件定义探测点，则会自动发生这种情况。如果您的探测点有一个信号量，当您使用 `'-probe-stap'` 表示法指定断点时，`gdb` 将自动启用它。但是，如果您通过其他方法（例如，`break file:line`）在探测点的位置设置断点，则 `gdb` 不会自动设置信号量。`DTrace` 探测点不支持信号量。

您可以使用 `info probes` 并带有可选参数来检查可用的静态探测点：

`info probes [type] [provider [name [objfile]]]`
如果给定，`type` 为 `stap` 用于列出 `SystemTap` 探测点，`dtrace` 用于列出 `DTrace` 探测点。如果省略，则列出所有类型的所有探测点。

如果给定，`provider` 是一个正则表达式，用于在选择要列出的探测点时与提供程序名称匹配。如果省略，则列出所有提供程序的所有探测点。

如果给定，`name` 是一个正则表达式，用于在选择要列出的探测点时与探测点名称匹配。如果省略，则在决定是否显示时不考虑探测点名称。

如果给定，`objfile` 是一个正则表达式，用于选择要检查的对象文件（可执行文件或共享库）。如果未给定，则考虑所有对象文件。

`info probes all`
列出所有类型的可用静态探测点。

一些探测点可以启用和/或禁用。启用或禁用探测点的效果取决于所处理的探测点的类型。一些 `DTrace` 探测点可以启用或禁用，但 `SystemTap` 探测点不能禁用。

您可以使用以下命令启用（或禁用）一个或多个探测点，并带有可选参数：

`enable probes [provider [name [objfile]]]`
如果给定，`provider` 是一个正则表达式，用于在选择要启用的探测点时与提供程序名称匹配。如果省略，则启用所有提供程序的所有探测点。

如果给定，`name` 是一个正则表达式，用于在选择要启用的探测点时与探测点名称匹配。如果省略，则在决定是否启用时不考虑探测点名称。

如果给定，`objfile` 是一个正则表达式，用于选择要检查的对象文件（可执行文件或共享库）。如果未给定，则考虑所有对象文件。

`disable probes [provider [name [objfile]]]`
有关此命令接受的可选参数的说明，请参阅上面的 `enable probes` 命令。

一个探测点最多可以指定十二个参数。这些在探测点定义的点可用 - 也就是说，当当前 `PC` 位于探测点的位置时。这些参数可以使用便利变量（请参阅第 10.12 节[便利变量]，第 171 页）`$_probe_arg0...$_probe_arg11` 来获取。在 `SystemTap` 探测点中，每个探测点参数是适当大小的整数；类型不保留。在 `DTrace` 探测点中，如果 `gdb` 识别它们的类型，则类型会保留；否则，探测点参数的值将是一个长整数。便利变量 `$_probe_argc` 保存当前探测点的参数数量。

这些变量始终可用，但在除探测点之外的任何位置尝试访问它们将导致 `gdb` 给出错误消息。

### 5.1.11 “无法插入断点”（“Cannot insert breakpoints”）

如果您请求的活动硬件辅助断点和观察点过多，您将看到此错误消息：

`Stopped; cannot insert breakpoints.`

`You may have requested too many hardware breakpoints and watchpoints.`

当您尝试恢复程序时会打印此消息，因为只有此时 `gdb` 才确切知道需要插入多少硬件断点和观察点。

当打印此消息时，您需要禁用或删除一些硬件辅助断点和观察点，然后继续。

### 5.1.12 “断点地址调整...”（“Breakpoint address adjusted...”）

某些处理器架构对可设置断点的地址有限制。对于受到此类限制的架构，`gdb` 将尝试调整断点的地址以符合架构规定的限制。

富士通 `FR-V` 就是这样一种架构的例子。`FR-V` 是一种 `VLIW` 架构，其中许多类似 `RISC` 的指令可能被捆绑在一起并行执行。`FR-V` 架构将断点指令在这样的捆绑中的位置限制为地址最低的指令。`gdb` 通过将断点的地址调整为捆绑中的第一个来遵守此限制。

优化后的代码中包含来自不同源语句的指令的捆绑并不罕见，因此可能会发生断点的地址从一个源语句调整到另一个源语句的情况。由于这种调整可能会显著改变 `gdb` 与断点相关的行为，与用户的预期不同，因此在首次设置断点以及命中断点时都会打印警告。

设置经过地址调整的断点时，会打印如下警告：

`warning: Breakpoint address adjusted from 0x00010414 to 0x00010410.`

对于用户可设置的断点和 `gdb` 的内部断点都会打印此类警告。如果您看到此类警告，您应该验证在调整后的地址设置的断点是否会产生预期的效果。如果不是，可能需要删除有问题的断点，并设置其他具有所需行为的断点。例如，在稍后的指令处设置断点可能就足够了。在某些情况下，条件断点也可能有助于防止断点过于频繁地触发。

`gdb` 在在这些调整后的断点处停止时也会发出警告：

`warning: Breakpoint 1 address previously adjusted from 0x00010414 to 0x00010410.`

遇到此警告时，除了断点比预期更早或更频繁地被命中的情况外，可能为时已晚采取补救措施。

## 5.2 继续和单步执行（Continuing and Stepping）

“继续”意味着恢复程序执行，直到您的程序正常完成。相比之下，“单步执行”意味着只执行程序的一个“步骤”，其中“步骤”可能意味着一行源代码，或者一条机器指令（取决于您使用的特定命令）。无论是继续还是单步执行，您的程序都可能由于断点或信号而更早停止。（如果由于信号而停止，您可能想要使用 `handle`，或者使用 `'signal 0'` 恢复执行（请参阅第 5.4 节[信号]，第 89 页），或者您可以单步进入信号的处理程序（请参阅[单步执行和信号处理程序]，第 91 页）。）

`continue [ignore-count]`
`c [ignore-count]`
`fg [ignore-count]`
恢复程序执行，从程序上次停止的地址开始；该地址处设置的任何断点都会被绕过。可选参数 `ignore-count` 允许您指定在此位置进一步忽略断点的次数；其效果类似于 `ignore`（请参阅第 5.1.6 节[断点条件]，第 76 页）。

参数 `ignore-count` 仅在您的程序因断点而停止时才有意义。在其他时候，`continue` 的参数将被忽略。

同义词 `c` 和 `fg`（代表前台，因为被调试的程序被视为前台程序）纯粹是为了方便而提供的，并且与 `continue` 具有完全相同的行为。

要在不同的位置恢复执行，您可以使用 `return`（请参阅第 17.4 节[从函数返回]，第 280 页）返回调用函数；或者使用 `jump`（请参阅第 17.2 节[在不同地址继续]，第 278 页）转到程序中的任意位置。

使用单步执行的典型技术是在认为存在问题的函数或程序部分的开头设置断点（请参阅第 5.1 节[断点、观察点和捕获点]，第 57 页），运行程序直到在该断点处停止，然后逐步通过可疑区域，检查感兴趣的变量，直到看到问题发生。

`step` 继续运行您的程序，直到控制到达不同的源代码行，然后停止并将控制权返回给 `gdb`。此命令缩写为 `s`。

警告：如果在控制位于没有调试信息编译的函数内时使用 `step` 命令，执行将继续，直到控制到达具有调试信息的函数。同样，它不会单步进入没有调试信息编译的函数。要单步通过没有调试信息的函数，请使用下面描述的 `stepi` 命令。

`step` 命令仅在源代码行的第一条指令处停止。这可以防止在 `switch` 语句、`for` 循环等中可能出现的多次停止。如果在该行内调用了具有调试信息的函数，`step` 将继续停止。换句话说，`step` 会进入该行内调用的任何函数。

此外，`step` 命令仅在函数具有行号信息时才进入函数。否则，它的行为类似于 `next` 命令。这避免了在 `MIPS` 机器上使用 `cc -gl` 时出现的问题。以前，`step` 如果有关例程有任何调试信息，就会进入子例程。

`step count` 像 `step` 一样继续运行，但执行 `count` 次。如果在达到 `count` 步之前到达断点或发生与单步执行无关的信号，单步执行将立即停止。

`next [count]` 继续执行当前（最内层）堆栈帧中的下一行源代码。这类似于 `step`，但在代码行内出现的函数调用会在不停止的情况下执行。当控制到达在您给出 `next` 命令时正在执行的原始堆栈级别上的不同代码行时，执行停止。此命令缩写为 `n`。

参数 `count` 是重复计数，与 `step` 相同。

`next` 命令仅在源代码行的第一条指令处停止。这可以防止在 `switch` 语句、`for` 循环等中可能出现的多次停止。

`set step-mode`
`set step-mode on`
`set step-mode on` 命令导致 `step` 命令在没有调试行信息的函数的第一条指令处停止，而不是跨过它。

在您可能对检查没有符号信息的函数的机器指令感兴趣并且不希望 `gdb` 自动跳过此函数的情况下，这很有用。

`set step-mode off`
导致 `step` 命令跨过任何没有调试信息的函数。这是默认设置。

`show step-mode`
显示 `gdb` 是否会在没有源代码行调试信息的函数中停止或跨过。

`finish` 继续运行，直到所选堆栈帧中的函数返回后立即停止。打印返回值（如果有）。此命令可以缩写为 `fin`。
与 `return` 命令（请参阅第 17.4 节[从函数返回]，第 280 页）形成对比。

`set print finish [on|off]`
`show print finish`
默认情况下，`finish` 命令将显示函数返回的值。可以使用 `set print finish off` 禁用此功能。禁用时，该值仍会输入到值历史记录中（请参阅第 10.11 节[值历史记录]，第 170 页），但不会显示。

`until`
`u` 继续运行，直到到达当前行之后的源代码行，在当前堆栈帧中。此命令用于避免在循环中多次单步执行。它类似于 `next` 命令，不同之处在于当 `until` 遇到跳转时，它会自动继续执行，直到程序计数器大于跳转的地址。

这意味着当您在单步执行完循环后到达循环的末尾时，`until` 会使您的程序继续执行，直到退出循环。相比之下，在循环末尾的 `next` 命令只是回到循环的开头，这迫使您单步执行下一次迭代。

`until` 始终会在程序尝试退出当前堆栈帧时停止您的程序。

如果机器代码的顺序与源代码行的顺序不匹配，`until` 可能会产生一些违反直觉的结果。例如，在下面的调试会话摘录中，`f`（帧）命令显示执行在第 206 行停止；然而，当我们使用 `until` 时，我们到达了第 195 行：

```
(gdb) f
#0 main (argc=4, argv=0xf7fffae8) at m4.c:206
206 expand_input();
(gdb) until
195 for ( ; argc > 0; NEXTARG) {
```

这是因为，为了执行效率，编译器在循环的末尾而不是开头生成了循环结束测试的代码 - 即使在 `C` 的 `for` 循环中，测试是写在循环体之前的。当 `until` 前进到这个表达式时，它似乎回退到了循环的开头；然而，实际上它并没有真正到达更早的语句 - 就实际的机器代码而言并非如此。

没有参数的 `until` 通过单指令单步执行工作，因此比带有参数的 `until` 慢。

`until locspec`
`u locspec` 继续运行您的程序，直到它到达解析 `locspec` 得到的代码位置，或者当前堆栈帧返回。`locspec` 是第 9.2 节[位置规范]（第 126 页）中描述的任何形式。

此命令形式使用临时断点，因此比没有参数的 `until` 更快。指定的位置实际上只有在当前帧中才能到达。这意味着 `until` 可用于跳过递归函数调用。例如，在下面的代码中，如果当前位置是第 96 行，发出 `until 99` 将在 `factorial` 的同一次调用中执行程序到第 99 行，即在内部调用返回之后。

```
94 int factorial (int value)
95 {
96 if (value > 1) {
97 value *= factorial (value - 1);
98 }
99 return (value);
100 }
```

`advance locspec` 继续运行您的程序，直到它到达解析 `locspec` 得到的代码位置，或者当前堆栈帧返回。`locspec` 是第 9.2 节[位置规范]（第 126 页）中描述的任何形式。

此命令类似于 `until`，但 `advance` 不会跳过递归函数调用，并且目标代码位置不必与当前帧相同。

`stepi`
`stepi arg`
`si` 执行一条机器指令，然后停止并返回调试器。在按机器指令单步执行时，执行 `display/i $pc` 通常很有用。这使得 `gdb` 在每次程序停止时自动显示要执行的下一条指令。请参阅第 10.8 节[自动显示]，第 155 页。

参数是重复计数，与 `step` 相同。

`nexti`
`nexti arg`
`ni` 执行一条机器指令，但如果它是函数调用，则继续执行直到函数返回。

参数是重复计数，与 `next` 相同。

默认情况下，如果可用，`gdb` 会使用目标辅助的范围单步执行。换句话说，每当您使用单步执行命令（例如，`step`，`next`）时，`gdb` 会告诉目标自行单步执行相应的指令地址范围，而不是发出多个单步执行。这加快了行单步执行的速度，特别是对于远程目标。理想情况下，您应该没有理由想要关闭范围单步执行。但是，调试信息中的错误、远程存根中的错误（对于远程目标），甚至 `gdb` 中的错误都可能导致在启用目标辅助的范围单步执行时行单步执行行为不正确。如果必要，您可以使用以下命令关闭范围单步执行：

`set range-stepping`
`show range-stepping`
控制是否启用范围单步执行。

如果启用，并且目标支持，`gdb` 会告诉目标自行单步执行一系列地址，而不是发出多个单步执行。如果禁用，`gdb` 始终发出单步执行，即使目标支持范围单步执行。默认是启用。

## 5.3 跳过函数和文件（Skipping Over Functions and Files）

您正在调试的程序可能包含一些您不感兴趣调试的函数。`skip` 命令允许您告诉 `gdb` 在单步执行时跳过一个函数、一个文件中的所有函数或特定文件中的特定函数。

例如，考虑以下 C 函数：

```
101 int func()
102 {
103    foo(boring());
104    bar(boring());
105 }
```

假设您希望单步进入 `foo` 和 `bar` 函数，但对单步进入 `boring` 不感兴趣。如果您在第 103 行运行 `step`，您将进入 `boring()`，但如果您运行 `next`，您将跳过 `foo` 和 `boring` 两者！

一种解决方案是单步进入 `boring` 并使用 `finish` 命令立即退出它。但如果 `boring` 从许多地方被调用，这可能会变得繁琐。

更灵活的解决方案是执行 `skip boring`。这指示 `gdb` 永远不要单步进入 `boring`。现在，当您在第 103 行执行 `step` 时，您将跳过 `boring` 并直接进入 `foo` 。

可以通过提供函数名、行规范（请参阅第 9.2 节[位置规范]，第 126 页）、匹配函数名称的正则表达式、文件名或匹配文件名的 glob 样式模式来跳过函数。

在 Posix 系统上，正则表达式的形式是“扩展正则表达式”。例如，在 gnu/Linux 系统上查看 `man 7 regex` 。在非 Posix 系统上，正则表达式的形式是底层系统的 `regcomp` 函数提供的任何形式。例如，在 gnu/Linux 系统上查看 `man 7 glob` 以获取关于 glob 样式模式的描述。

`skip [options]`
`skip` 命令的基本形式接受零个或多个指定要跳过的内容的选项。`options` 参数是以下任何有用的组合：

`-file file`
`-fi file` 单步执行时，文件 `file` 中的函数将被跳过。

`-gfile file-glob-pattern`
`-gfi file-glob-pattern` 单步执行时，与文件 glob 模式匹配的文件中的函数将被跳过。

`(gdb) skip -gfi utils/*.c`

`-function linespec`
`-fu linespec` 由 `linespec` 命名的函数或包含由 `linespec` 命名的行的函数在单步执行时将被跳过。请参阅第 9.2 节[位置规范]，第 126 页。

`-rfunction regexp`
`-rfu regexp` 名称与 `regexp` 匹配的函数在单步执行时将被跳过。

对于复杂的函数名称，此形式很有用。例如，通常不需要单步进入 C++ `std::string` 的构造函数或析构函数。加上 C++ 模板，写出函数的完整名称可能很困难，而且通常模板参数是什么并不重要。将要跳过的函数指定为正则表达式会使这更容易。

`(gdb) skip -rfu ^std::(allocator|basic_string)<.*>::~?\1 *\(`

如果您想跳过 `std` 命名空间中的每个模板化 C++ 构造函数和析构函数，可以这样做：

`(gdb) skip -rfu ^std::([a-zA-z0-9_]+)<.*>::~?\1 *\(`

如果未指定任何选项，则当前正在调试的函数将被跳过。

`skip function [linespec]`
运行此命令后，在单步执行时，由 `linespec` 命名的函数或包含由 `linespec` 命名的行的函数将被跳过。请参阅第 9.2 节[位置规范]，第 126 页。

如果您未指定 `linespec`，则当前正在调试的函数将被跳过。

（如果您有一个名为 `file` 的函数要跳过，请使用 `skip function file`。）

`skip file [filename]`
运行此命令后，在单步执行时，任何其源代码位于 `filename` 中的函数都将被跳过。

`(gdb) skip file boring.c`

单步执行时，文件 `boring.c` 将被跳过。

如果您未指定 `filename`，则其源代码位于当前正在调试的文件中的函数将被跳过。

跳过可以像断点一样被列出、删除、禁用和启用。以下是用于管理您的跳过列表的命令：

`info skip [range]`
打印有关指定跳过项的详细信息。如果未指定 `range`，则打印一个包含有关所有标记为要跳过的函数和文件的详细信息的表格。`info skip` 打印每个跳过的以下信息：

标识符 标识此跳过的编号。

启用或禁用 启用的跳过标记为 `y`。禁用的跳过标记为 `n`。

Glob 如果文件名是“glob”模式，则为 `y`。否则为 `n`。

文件 要跳过的文件的名称或“glob”模式。如果未指定文件，则为 `<none>`。

RE 如果函数名称是“正则表达式”，则为 `y`。否则为 `n`。

函数 要跳过的函数的名称或正则表达式。如果未指定函数，则为 `<none>`。

`skip delete [range]`
删除指定的跳过项。如果未指定 `range`，则删除所有跳过项。

`skip enable [range]`
启用指定的跳过项。如果未指定 `range`，则启用所有跳过项。

`skip disable [range]`
禁用指定的跳过项。如果未指定 `range`，则禁用所有跳过项。

`set debug skip [on|off]`
设置是否打印有关跳过文件和函数的调试输出。

`show debug skip`
显示是否打印有关跳过文件和函数的调试输出。

## 5.4 信号（Signals）

信号是程序中可能发生的异步事件。操作系统定义了可能的信号种类，并为每种信号赋予名称和编号。例如，在 Unix 中，`SIGINT` 是当您键入中断字符（通常是 `Ctrl-c`）时程序收到的信号；`SIGSEGV` 是程序从引用远离所有正在使用的内存区域的位置时收到的信号；`SIGALRM` 在闹钟计时器到期时发生（仅当您的程序请求了闹钟时才会发生）。

一些信号，包括 `SIGALRM`，是您的程序正常运行的一部分。其他信号，如 `SIGSEGV`，表示错误；如果程序事先未指定处理该信号的其他方式，这些信号是致命的（它们会立即终止您的程序）。`SIGINT` 并不表示您的程序中有错误，但它通常是致命的，因此可以实现中断的目的：终止程序。

`gdb` 能够检测您的程序中任何信号的发生。您可以提前告诉 `gdb` 对于每种信号要做什么。

通常，`gdb` 设置为让像 `SIGALRM` 这样的非错误信号默默地传递给您的程序（以免干扰它们在程序运行中的作用），但在错误信号发生时立即停止您的程序。您可以使用 `handle` 命令更改这些设置。

`info signals`
`info handle`
打印所有信号类型以及 `gdb` 被告知如何处理每种信号的表格。您可以使用此命令查看所有定义类型的信号的编号。

`info signals sig`
类似，但仅打印有关指定信号编号的信息。

`info handle` 是 `info signals` 的别名。

`catch signal [signal... | 'all']`
为指示的信号设置捕获点。有关此命令的详细信息，请参阅第 5.1.3 节[设置捕获点]，第 69 页。

`handle signal [ signal... ] [keywords...]`
更改 `gdb` 处理每个信号的方式。每个信号可以是信号的编号或其名称（开头带或不带 `'SIG'`）；形式为 `'low-high'` 的信号编号列表；或单词 `'all'`，表示除 `SIGINT` 和 `SIGTRAP` 之外的所有已知信号，这两个信号由 `gdb` 使用。下面描述的可选参数 `keywords` 说明对所有指定信号进行的更改。

`handle` 命令允许的关键字可以缩写。它们的全名是：

`nostop` `gdb` 在该信号发生时不应停止您的程序。它仍可能打印一条消息告诉您信号已进入。

`stop` `gdb` 在该信号发生时应停止您的程序。这也意味着 `print` 关键字。

`print` `gdb` 在该信号发生时应打印一条消息。

`noprint` `gdb` 根本不应提及该信号的发生。这也意味着 `nostop` 关键字。

`pass`
`noignore` `gdb` 应允许您的程序看到此信号；您的程序可以处理该信号，否则如果该信号是致命的且未处理，它可能会终止。`pass` 和 `noignore` 是同义词。

`nopass`
`ignore` `gdb` 不应允许您的程序看到此信号。`nopass` 和 `ignore` 是同义词。

当一个信号停止您的程序时，在您继续之前，该信号对程序不可见。如果当时对该信号的 `pass` 生效，您的程序在继续时会看到该信号。换句话说，在 `gdb` 报告一个信号后，您可以使用带有 `pass` 或 `nopass` 的 `handle` 命令来控制您的程序在继续时是否看到该信号。

默认设置为对于非错误信号（如 `SIGALRM`、`SIGWINCH` 和 `SIGCHLD`）为 `nostop`、`noprint`、`pass`，对于错误信号为 `stop`、`print`、`pass`。

您还可以使用 `signal` 命令阻止您的程序看到信号，或导致它看到通常不会看到的信号，或在任何时候给它任何信号。例如，如果您的程序由于某种内存引用错误而停止，您可能会将正确的值存储到错误的变量中并继续，希望看到更多的执行；但一旦您的程序看到致命信号，它可能会立即终止。为防止这种情况，您可以使用 `'signal 0'` 继续。请参阅第 17.3 节[给您的程序一个信号]，第 279 页。

`gdb` 针对主代码的单步执行进行了优化。如果在执行单步命令（例如 `stepi`、`step`、`next`）时收到设置为 `handle nostop` 和 `handle pass` 的信号，`gdb` 会让信号处理程序运行，然后在信号处理程序返回后恢复主代码的单步执行。换句话说，`gdb` 会跳过信号处理程序。这可以防止您指定为不感兴趣的信号（使用 `handle nostop`）意外改变调试的焦点。请注意，信号处理程序本身仍可能命中断点、因生效的 `handle stop` 的另一个信号而停止，或者因任何通常导致单步执行命令更早停止的其他事件而停止。还要注意，如果设置了 `handle print`，`gdb` 仍会通知您程序收到了信号。

如果您为信号设置 `handle pass`，并且您的程序为其设置了处理程序，那么当您的程序因该信号而停止时，发出单步命令（例如 `step` 或 `stepi`）将单步进入信号处理程序（如果目标支持）。

同样，如果您使用 `queue-signal` 命令在恢复线程执行时将信号排队传递到当前线程（请参阅第 17.3 节[给您的程序一个信号]，第 279 页），那么单步命令将单步进入信号处理程序。

以下是一个示例，使用 `stepi` 单步到 `SIGUSR1` 处理程序的第一条指令：

```
(gdb) handle SIGUSR1
Signal   Stop   Print   Pass to program   Description
SIGUSR1  Yes    Yes     Yes               User defined signal 1
(gdb) c
Continuing.
Program received signal SIGUSR1, User defined signal 1.
main () sigusr1.c:28
28    p = 0;
(gdb) si
sigusr1_handler () at sigusr1.c:9
9 {
```

同样，但使用 `queue-signal` 而不是等待程序首先收到信号：

```
(gdb) n
28    p = 0;
(gdb) queue-signal SIGUSR1
(gdb) si
sigusr1_handler () at sigusr1.c:9
9 {
(gdb)
```

在某些目标上，`gdb` 可以在实际将截获的信号传递给正在调试的程序之前检查与该信号相关的额外信号信息。此信息由便利变量 `$_siginfo` 导出，并由内核在收到信号时传递给信号处理程序的数据组成。信息本身的数据类型取决于目标。您可以使用 `ptype $_siginfo` 命令查看数据类型。在 Unix 系统上，它通常对应于 `signal.h` 系统头文件中定义的标准 `siginfo_t` 类型。

以下是一个示例，在 gnu/Linux 系统上，打印引发段错误的流浪引用地址。

```
(gdb) continue
Program received signal SIGSEGV, Segmentation fault.
0x0000000000400766 in main ()
69    *(int *)p = 0;
(gdb) ptype $_siginfo
type = struct {
int si_signo;
int si_errno;
int si_code;
union {
int _pad[28];
struct {...} _kill;
struct {...} _timer;
struct {...} _rt;
struct {...} _sigchld;
struct {...} _sigfault;
struct {...} _sigpoll;
} _sifields;
}
(gdb) ptype $_siginfo._sifields._sigfault
type = struct {
void *si_addr;
}
(gdb) p $_siginfo._sifields._sigfault.si_addr
$1 = (void *) 0x7ffff7ff7000
```

根据目标支持，`$_siginfo` 也可能是可写的。

## 5.5 停止和启动多线程程序（Stopping and Starting Multi-thread Programs）

`gdb` 支持调试具有多个线程的程序（请参阅第 4.10 节[调试具有多个线程的程序]，第 47 页）。在调试器中控制程序执行有两种模式。在默认模式（称为全停止模式）中，当程序中的任何线程停止（例如，在断点处或单步执行时），程序中的所有其他线程也会被 `gdb` 停止。在某些目标上，`gdb` 还支持非停止模式，在这种模式下，当您在调试器中检查停止的线程时，其他线程可以继续自由运行。

### 5.5.1 全停止模式（All-Stop Mode）

在全停止模式中，无论程序由于任何原因在 `gdb` 下停止，所有执行线程都会停止，而不仅仅是当前线程。这允许您检查程序的整体状态，包括在线程之间切换，而不必担心情况可能会在脚下发生变化。

相反，每当您重新启动程序时，所有线程都会开始执行。即使使用像 `step` 或 `next` 这样的单步命令也是如此。

特别要注意的是，`gdb` 不能同步单步所有线程。由于线程调度由您调试目标的操作系统决定（而不是由 `gdb` 控制），在当前线程完成单步时，其他线程可能会执行多条语句。

而且，一般来说，当程序停止时，其他线程会在语句中间停止，而不是在清晰的语句边界处停止。

甚至在继续或单步执行后，您可能会发现程序在另一个线程中停止。只要在第一个线程完成您请求的操作之前，其他线程遇到断点、信号或异常，就会发生这种情况。

每当 `gdb` 由于断点或信号而停止您的程序时，它会自动选择发生断点或信号的线程。`gdb` 会通过诸如 `[Switching to Thread n]` 这样的消息提醒您上下文切换，以标识线程。

在某些操作系统上，您可以通过锁定操作系统调度程序来修改 `gdb` 的默认行为，以仅允许单个线程运行。

`set scheduler-locking mode`
设置调度程序锁定模式。它适用于正常执行、记录模式和重放模式。`mode` 可以是以下之一：

`off` 没有锁定，任何线程都可以随时运行。

`on` 当从下级恢复时，只有当前线程可以运行。新由恢复的线程创建的线程在其入口点被保持停止，在它们执行任何指令之前。

`step` 单步时表现得像 `on`，其他时候像 `off`。当您单步时，除当前线程外的线程永远没有机会运行，而当您使用像 `continue`、`until` 或 `finish` 这样的命令时，它们完全自由运行。

这种模式针对单步进行了优化；它防止在您单步时其他线程抢占当前线程，因此调试的焦点不会意外改变。但是，除非在其时间片期间另一个线程命中断点，否则 `gdb` 不会将当前线程从您正在调试的线程更改。

`replay` 在重放模式下表现得像 `on`，在记录模式或正常执行期间表现得像 `off`。这是默认模式。

`show scheduler-locking`
显示当前的调度程序锁定模式。

默认情况下，当您发出诸如 `continue`、`next` 或 `step` 之类的执行命令时，`gdb` 只允许当前下级的线程运行。例如，如果 `gdb` 附加到两个下级，每个下级有两个线程，`continue` 命令仅恢复当前下级的两个线程。这在例如调试分叉的程序并且您希望保持父进程停止（例如，以便它不会运行到退出），同时调试子进程时很有用。在其他情况下，您可能对检查 `gdb` 所附加的任何进程的当前状态不感兴趣，并且您可能希望恢复它们所有直到命中某个断点。在后一种情况下，您可以使用 `set schedule-multiple` 命令指示 `gdb` 允许所有下级的所有线程运行。

`set schedule-multiple`
设置发出执行命令时允许恢复多个进程的线程的模式。当为 `on` 时，允许所有进程的所有线程运行。当为 `off` 时，仅恢复当前进程的线程。默认是 `off`。当设置为 `on` 或在单步并设置为 `step` 时，调度程序锁定模式优先。

`show schedule-multiple`
显示恢复多个进程的线程执行的当前模式。

### 5.5.2 非停止模式（Non-Stop Mode）

对于某些多线程目标，`gdb` 支持一种可选的操作模式，在这种模式下，您可以在调试器中检查停止的程序线程，而其他线程继续自由执行。这在调试实时系统（例如某些线程具有实时约束或必须继续响应外部事件的程序）时最大限度地减少了干扰。这被称为非停止模式。

在非停止模式中，当一个线程停止以报告调试事件时，只有该线程停止；与全停止模式的行为相反，`gdb` 不会停止其他线程。

此外，默认情况下，诸如 `continue` 和 `step` 之类的执行命令在非停止模式中仅适用于当前线程，而不像在全停止模式中适用于所有线程。这允许您以在全停止模式中不可能的方式明确控制线程 - 例如，在允许其他线程自由运行的同时单步一个线程，在保持所有其他线程停止的同时单步一个线程，或者独立且同时单步多个线程。

要进入非停止模式，请在运行或附加到您的程序之前使用以下命令序列：

```
# 如果使用 CLI，分页会破坏非停止模式。
set pagination off
# 最后，打开它！
set non-stop on
```

您可以使用这些命令来操作非停止模式设置：

`set non-stop on`
启用非停止模式的选择。

`set non-stop off`
禁用非停止模式的选择。

`show non-stop`
显示当前的非停止启用设置。

请注意，这些命令仅反映非停止模式是否启用，而不是当前正在执行的程序是否正在以非停止模式运行。特别是，仅在 `gdb` 启动或连接到目标程序时才会参考 `set non-stop` 偏好，并且一旦调试开始，通常不可能切换模式。此外，由于并非所有目标都支持非停止模式，即使您已启用非停止模式，`gdb` 仍可能默认回退到全停止操作。

在非停止模式中，默认情况下所有执行命令仅适用于当前线程。也就是说，`continue` 仅继续一个线程。要继续所有线程，请发出 `continue -a` 或 `c -a` 。

您可以使用 `gdb` 的后台执行命令（请参阅第 5.5.3 节[后台执行]，第 95 页）在您继续从 `gdb` 检查或单步其他线程时在后台运行一些线程。`MI` 执行命令（请参阅第 27.15 节[GDB/MI 程序执行]，第 629 页）在非停止模式中始终异步执行。

在后台运行时，使用 `interrupt` 命令暂停执行，或者在前台执行时使用 `Ctrl-c` 。在全停止模式中，这会停止整个进程；但在非停止模式中，`interrupt` 仅适用于当前线程。要在非停止模式中停止整个程序，请使用 `interrupt -a` 。

在非停止模式中，当一个线程停止时，`gdb` 不会像在全停止模式中那样自动将该线程设置为当前线程。这是因为线程停止通知相对于 `gdb` 的命令解释器是异步的，如果 `gdb` 在您输入对先前当前线程进行操作的命令时意外切换到不同的线程，那将会令人困惑。

### 5.5.3 后台执行（Background Execution）

`gdb` 的执行命令有两种变体：正常的前台（同步）行为和后台（异步）行为。在前台执行中，`gdb` 等待程序报告某个线程已停止，然后提示输入另一个命令。在后台执行中，`gdb` 立即给出命令提示符，以便您可以在程序运行时发出其他命令。

如果目标不支持异步模式，当您尝试使用后台执行命令时，`gdb` 会发出错误消息。

要指定后台执行，请在命令后添加 `&` 。例如，`continue` 命令的后台形式是 `continue&`，或者只是 `c&` 。接受后台执行的执行命令是：

`run` 请参阅第 4.2 节[启动您的程序]，第 34 页。

`attach` 请参阅第 4.7 节[调试已经运行的进程]，第 41 页。

`step` 请参阅第 5.2 节[继续和单步执行]，第 83 页。

`stepi` 请参阅第 5.2 节[继续和单步执行]，第 83 页。

`next` 请参阅第 5.2 节[继续和单步执行]，第 83 页。

`nexti` 请参阅第 5.2 节[继续和单步执行]，第 83 页。

`continue` 请参阅第 5.2 节[继续和单步执行]，第 83 页。

`finish` 请参阅第 5.2 节[继续和单步执行]，第 83 页。

`until` 请参阅第 5.2 节[继续和单步执行]，第 83 页。

后台执行与非停止模式结合使用对于调试具有多个线程的程序特别有用；请参阅第 5.5.2 节[非停止模式]，第 94 页。但是，您也可以在正常的全停止模式中使用这些命令，但限制是在之前的执行命令完成之前，您不能发出另一个执行命令。在程序运行时在全停止模式中有效的命令示例包括 `help` 和 `info break` 。

您可以在程序在后台运行时使用 `interrupt` 命令中断您的程序。

`interrupt`
`interrupt -a`
暂停正在运行的程序的执行。在全停止模式中，`interrupt` 停止整个进程，但在非停止模式中，它仅停止当前线程。要在非停止模式中停止整个程序，请使用 `interrupt -a` 。

### 5.5.4 线程特定的断点（Thread-Specific Breakpoints）

当您的程序具有多个线程（请参阅第 4.10 节[调试具有多个线程的程序]，第 47 页）时，您可以选择是在所有线程上设置断点，还是在特定线程上设置断点。

`break locspec thread thread-id`
`break locspec thread thread-id if...`
`locspec` 指定您程序中的一个或多个代码位置。有关详细信息，请参阅第 9.2 节[位置规范]，第 126 页。

使用带有断点命令的限定符 `'thread thread-id'` 来指定您仅希望当特定线程到达此断点时 `gdb` 停止程序。`thread-id` 规范是 `gdb` 分配的线程标识符之一，显示在 `'info threads'` 显示的第一列中。

如果在设置断点时未指定 `'thread thread-id'`，则断点适用于程序的所有线程。

您也可以在条件断点上使用线程限定符；在这种情况下，将 `'thread thread-id'` 放在断点条件之前或之后，如下所示：

```
(gdb) break frik.c:13 thread 28 if bartab > lim
```

当 `gdb` 检测到相应的线程不再在线程列表中时，线程特定的断点会自动删除。例如：

```
(gdb) c
Thread-specific breakpoint 3 deleted - thread 28 no longer in the thread list.
```

线程消失有几种方式，例如常规的线程退出，还包括使用 `detach` 命令从进程分离（请参阅第 4.7 节[调试已经运行的进程]，第 41 页），或者如果 `gdb` 失去远程连接（请参阅第 20 章[远程调试]，第 315 页）等。请注意，对于某些目标，只有当用户使用 `info threads` 命令明确请求线程列表时，`gdb` 才能检测到线程已退出。

一个断点不能既是线程特定的又是下级特定的（请参阅第 4.9.1 节[下级特定的断点]，第 46 页），也不能是任务特定的（请参阅第 15.4.10.7 节[Ada 任务]，第 255 页）；在创建断点时使用多个线程、下级或任务关键字会出错。

### 5.5.5 中断的系统调用（Interrupted System Calls）

在使用 `gdb` 调试多线程程序时存在一个不幸的副作用。如果一个线程因断点或其他原因停止，而另一个线程被阻塞在系统调用中，那么系统调用可能会过早返回。这是多个线程与 `gdb` 用于实现断点和其他停止执行事件的信号之间相互作用的结果。

为了处理这个问题，您的程序应该检查每个系统调用的返回值并做出适当的反应。无论如何，这都是良好的编程风格。

例如，不要编写这样的代码：

```
sleep (10);
```

如果不同的线程在断点处停止或由于其他原因，对 `sleep` 的调用将提前返回。

相反，应该这样写：

```
int unslept = 10;
while (unslept > 0)
    unslept = sleep (unslept);
```

系统调用被允许提前返回，所以系统仍然符合其规范。但是 `gdb` 确实导致您的多线程程序的行为与没有 `gdb` 时不同。

此外，`gdb` 在线程库中使用内部断点来监视某些事件，例如线程创建和线程销毁。当这样的事件发生时，另一个线程中的系统调用可能会过早返回，即使您的程序似乎没有停止。

### 5.5.6 观察者模式（Observer Mode）

如果您想在非停止模式的基础上观察程序行为，而不希望被 `gdb` 有任何干扰的机会，可以设置变量来禁用调试器的所有修改状态的尝试，无论是写入内存、插入断点等。这些操作在较低级别，拦截来自所有命令的操作。

当所有这些都设置为 `off` 时，`gdb` 被称为处于观察者模式。为了方便起见，可以设置变量 `observer` 来禁用这些，并启用非停止调试。

请注意，`gdb` 不会阻止您进行这些设置的无意义组合。例如，如果您启用了 `may-insert-breakpoints` 但禁用了 `may-write-memory`，那么通过在代码流中写入陷阱指令来工作的断点仍然无法设置。

`set observer on`
`set observer off`
设置为 `on` 时，这会禁用下面所有的权限变量（除了 `insert-fast-tracepoints`），并启用非停止调试。设置为 `off` 会切换回正常调试，但仍保持在非停止模式。

`show observer`
显示观察者模式是开启还是关闭。

`set may-write-registers on`
`set may-write-registers off`
这控制 `gdb` 是否尝试更改寄存器的值，例如在 `print` 中的赋值表达式，或 `jump` 命令。默认为 `on` 。

`show may-write-registers`
显示当前写入寄存器的权限。

`set may-write-memory on`
`set may-write-memory off`
这控制 `gdb` 是否尝试更改内存的内容，例如在 `print` 中的赋值表达式。默认为 `on` 。

`show may-write-memory`
显示当前写入内存的权限。

`set may-insert-breakpoints on`
`set may-insert-breakpoints off`
这控制 `gdb` 是否尝试插入断点。这会影响所有断点，包括 `gdb` 定义的内部断点。默认为 `on` 。

`show may-insert-breakpoints`
显示当前插入断点的权限。

`set may-insert-tracepoints on`
`set may-insert-tracepoints off`
这控制 `gdb` 是否尝试在跟踪实验开始时插入（常规）跟踪点。它仅影响非快速跟踪点，快速跟踪点由 `may-insert-fast-tracepoints` 控制。默认为 `on` 。

`show may-insert-tracepoints`
显示当前插入跟踪点的权限。

`set may-insert-fast-tracepoints on`
`set may-insert-fast-tracepoints off`
这控制 `gdb` 是否尝试在跟踪实验开始时插入快速跟踪点。它仅影响快速跟踪点，常规（非快速）跟踪点由 `may-insert-tracepoints` 控制。默认为 `on` 。

`show may-insert-fast-tracepoints`
显示当前插入快速跟踪点的权限。

`set may-interrupt on`
`set may-interrupt off`
这控制 `gdb` 是否尝试中断或停止程序执行。当此变量为 `off` 时，`interrupt` 命令将没有效果，`Ctrl-c` 也没有效果。默认为 `on` 。

`show may-interrupt`
显示当前中断或停止程序的权限。