
# 14 调试使用覆盖的程序

如果您的程序太大，无法完全放入目标系统的内存中，有时可以使用覆盖来解决此问题。gdb 为调试使用覆盖的程序提供了一些支持。

## 14.1 覆盖的工作原理

假设您有一台计算机，其指令地址空间只有 64 千字节长，但通过其他方式（例如特殊指令、段寄存器或内存管理硬件）可以访问更多的内存。进一步假设您希望让一个大于 64 千字节的程序在该系统上运行。

一种解决方案是识别程序中相对独立且不需要直接相互调用的模块；将这些模块称为覆盖。将覆盖与主程序分离，并将它们的机器代码放置在较大的内存中。将主程序放在指令内存中，但至少要在那里留出足够的空间来容纳最大的覆盖。

现在，要调用位于覆盖中的函数，必须首先将该覆盖的机器代码从大内存复制到指令内存中为其预留的空间，然后跳转到其在那里的入口点。
```
Data               Instruction            Larger
Address Space     Address Space        Address Space
+-----------+     +-----------+        +-----------+
|           |     |           |        |           |       
+-----------+     +-----------+        +-----------+<-- overlay 1
| program   |     | main      |   .----| overlay 1 | load address
| variables |     | program   |   |    +-----------+
| and heap  |     |           |   |    |           |
+-----------+     |           |   |    +-----------+<-- overlay 2
|           |     +-----------+   |    |           | load address
+-----------+     |           |   |  .-| overlay 2 |
                  |           |   |  | |           |
       mapped --->+-----------+   |  | +-----------+
       address    |           |   |  | |           |
                  | overlay   | <-’  | |           |
                  | area      |  <---’ +-----------+<-- overlay 3
                  |           | <---.  |           | load address
                  +-----------+     ‘--| overlay 3 |
                  |           |        |           |
                  +-----------+        |           |
                                       +-----------+
                                       |           |
                                       +-----------+
```

该图（请参见 [一个代码覆盖]，第 221 页）展示了具有独立的数据和指令地址空间的系统。要映射一个覆盖，程序将其代码从较大的地址空间复制到指令地址空间。由于此处显示的覆盖都使用相同的映射地址，因此一次只能映射一个。对于数据和指令具有单个地址空间的系统，该图将类似，不同之处在于程序变量和堆将与主程序和覆盖区域共享地址空间。

加载到指令内存中并准备使用的覆盖称为映射覆盖；其映射地址是其在指令内存中的地址。不在指令内存中（或仅部分存在）的覆盖称为未映射覆盖；其加载地址是其在较大内存中的地址。映射地址也称为虚拟内存地址或 VMA；加载地址也称为加载内存地址或 LMA。

不幸的是，覆盖并不是将程序适应有限指令内存的完全透明的方式。在设计程序时，它们引入了一组新的全局约束，您必须牢记：

• 在调用或从覆盖中的函数返回之前，您的程序必须确保该覆盖实际上已映射。否则，调用或返回将控制权转移到正确的地址，但在错误的覆盖中，您的程序可能会崩溃。

• 如果在您的系统上映射覆盖的过程很昂贵，您需要仔细选择覆盖，以最大程度地减少它们对程序性能的影响。

• 加载到系统上的可执行文件必须包含每个覆盖的指令，出现在覆盖的加载地址，而不是其映射地址。但是，每个覆盖的指令必须重新定位，并且其符号必须定义为覆盖位于其映射地址。您可以使用 GNU 链接器脚本为程序的各个部分指定不同的加载和重新定位地址；请参见《使用 ld：GNU 链接器》中的“覆盖描述”部分。

• 将可执行文件加载到系统上的过程必须能够将其内容加载到较大的地址空间以及指令和数据空间。

上面描述的覆盖系统相当简单，可以在许多方面进行改进：

• 如果您的系统具有合适的存储体切换寄存器或内存管理硬件，则可以使用这些设施使覆盖的加载区域内容直接出现在指令空间中的映射地址。这可能比通常的方式将覆盖复制到其映射区域更快。

• 如果您的覆盖足够小，则可以留出多个覆盖区域，并同时映射多个覆盖。

• 您可以使用覆盖来管理数据以及指令。通常，数据覆盖对您的设计来说比代码覆盖更不透明：代码覆盖仅在调用或返回函数时需要注意，而数据覆盖在每次访问数据时都需要注意。此外，如果更改数据覆盖的内容，则必须在将不同的数据覆盖复制到相同的映射区域之前，将其内容复制回其加载地址。

## 14.2 覆盖命令

要使用 gdb 的覆盖支持，程序中的每个覆盖都必须对应于可执行文件的一个单独的节。该节的虚拟内存地址和加载内存地址必须是覆盖的映射地址和加载地址。通过用节来标识覆盖，gdb 可以根据覆盖是否映射来确定函数或变量的适当地址。

gdb 的覆盖命令都以单词 `overlay` 开头；您可以将其缩写为 `ov` 或 `ovly` 。这些命令包括：

```
overlay off
	禁用 gdb 的覆盖支持。当覆盖支持被禁用时，gdb 假定所有函数和变量始终在其映射地址处存在。默认情况下，gdb 的覆盖支持是禁用的。

overlay manual
	启用手动覆盖调试。在这种模式下，gdb 依赖您使用下面描述的 `overlay map-overlay` 和 `overlay unmap-overlay` 命令来告知它哪些覆盖已映射，哪些未映射。

overlay map-overlay overlay
overlay map overlay
	告知 gdb 覆盖 `overlay` 现在已映射；`overlay` 必须是包含覆盖的目标文件节的名称。当一个覆盖被映射时，gdb 假定可以在其映射地址处找到覆盖的函数和变量。gdb 假定任何其他映射范围与该覆盖重叠的覆盖现在未映射。

overlay unmap-overlay overlay
overlay unmap overlay
	告知 gdb 覆盖 `overlay` 不再映射；`overlay` 必须是包含覆盖的目标文件节的名称。当一个覆盖未映射时，gdb 假定可以在其加载地址处找到覆盖的函数和变量。

overlay auto
	启用自动覆盖调试。在这种模式下，gdb 会查询下级维护的覆盖管理器中的数据结构，以查看哪些覆盖已映射。有关详细信息，请参见第 14.3 节[自动覆盖调试]，第 224 页。

overlay load-target
overlay load
	从下级重新读取覆盖表。通常，gdb 每次下级停止时都会自动重新读取表，因此只有在您使用 gdb 自行更改了覆盖映射时，此命令才是必要的。此命令仅在使用自动覆盖调试时有用。

overlay list-overlays
overlay list
	显示当前映射的覆盖列表，以及它们的映射地址、加载地址和大小。
```

通常，当 gdb 打印代码地址时，它会包括该地址所在的函数的名称：
```
	(gdb) print main
	$3 = {int ()} 0x11a0 <main>
```
当启用覆盖调试时，gdb 识别未映射覆盖中的代码，并在未映射函数的名称周围打印星号。例如，如果 `foo` 是未映射覆盖中的函数，gdb 会这样打印：
```
	(gdb) overlay list
	No sections are mapped.
	(gdb) print foo
	$5 = {int (int)} 0x100000 <*foo*>
```
当 `foo` 的覆盖被映射时，gdb 正常打印函数的名称：

```
	(gdb) overlay list
	Section .ov.foo.text, loaded at 0x100000 - 0x100034,
		   mapped at 0x1016 - 0x104a
	(gdb) print foo
	$6 = {int (int)} 0x1016 <foo>
```

当启用覆盖调试时，gdb 可以找到覆盖中函数和变量的正确地址，无论覆盖是否映射。这使得大多数 gdb 命令，如 `break` 和 `disassemble`，即使在未映射的代码上也能正常工作。然而，gdb 的断点支持有一些限制：

• 您可以在未映射覆盖中的函数中设置断点，只要 gdb 可以在其加载地址处写入覆盖。

• gdb 不能在未映射覆盖中设置基于硬件或模拟器的断点。但是，如果您在覆盖管理器的末尾设置断点（并且如果您使用手动覆盖管理，告知 gdb 哪些覆盖现在已映射），gdb 将正确重新设置其断点。

## 14.3 自动覆盖调试

如果下级的覆盖管理器进行一些简单的协作，gdb 可以自动跟踪哪些覆盖已映射，哪些未映射。如果使用 `overlay auto` 命令启用自动覆盖调试（请参见第 14.2 节[覆盖命令]，第 222 页），gdb 会在下级的内存中查找某些描述覆盖当前状态的变量。

以下是覆盖管理器必须定义以支持 gdb 的自动覆盖调试的变量：

```
_ovly_table:
	此变量必须是以下结构的数组：
		struct
		{
			/* 覆盖的映射地址。 */
			unsigned long vma;
			/* 覆盖的大小，以字节为单位。 */
			unsigned long size;
			/* 覆盖的加载地址。 */
			unsigned long lma;
			/* 如果覆盖当前已映射，则为非零；否则为零。 */
			unsigned long mapped;
		}

_novlys：
	此变量必须是一个四字节有符号整数，保存 `_ovly_table` 中的元素总数。
	
```
为确定特定覆盖是否已映射，gdb 会在 `_ovly_table` 中查找其 `vma` 和 `lma` 成员等于可执行文件中覆盖节的 VMA 和 LMA 的条目。当 gdb 找到匹配的条目时，它会查询条目的 `mapped` 成员以确定覆盖当前是否已映射。

此外，您的覆盖管理器可以定义一个名为 `_ovly_debug_event` 的函数。如果定义了此函数，gdb 将在那里默默地设置一个断点。如果覆盖管理器在更改覆盖表时调用此函数，这将使 gdb 能够准确跟踪哪些覆盖在程序内存中，并更新可能在覆盖中设置的任何断点。这将允许断点即使在覆盖未执行时保存在 ROM 或其他不可写内存中也能正常工作。

## 14.4 覆盖示例程序

在链接使用覆盖的程序时，必须将覆盖放置在其加载地址处，同时将其重定位到其映射地址处运行。为此，必须编写一个链接器脚本（请参见《使用 ld：GNU 链接器》中的“覆盖描述”部分）。不幸的是，由于链接器脚本特定于特定的主机系统、目标体系结构和目标内存布局，本手册无法提供演示 gdb 覆盖支持的可移植示例代码。

但是，gdb 源代码分发中确实包含一个覆盖程序，以及一些系统的链接器脚本，作为其测试套件的一部分。该程序由 gdb/testsuite/gdb.base 中的以下文件组成：

- `overlays.c`：主程序文件。
- `ovlymgr.c`：一个简单的覆盖管理器，由 `overlays.c` 使用。
- `foo.c`
- `bar.c`
- `baz.c`
- `grbx.c`：覆盖模块，由 `overlays.c` 加载和使用。
- `d10v.ld`
- `m32r.ld`：在 `d10v-elf` 和 `m32r-elf` 目标上链接测试程序的链接器脚本。

您可以使用 `d10v-elf` GCC 交叉编译器像这样构建测试程序：

```
$ d10v-elf-gcc -g -c overlays.c
$ d10v-elf-gcc -g -c ovlymgr.c
$ d10v-elf-gcc -g -c foo.c
$ d10v-elf-gcc -g -c bar.c
$ d10v-elf-gcc -g -c baz.c
$ d10v-elf-gcc -g -c grbx.c
$ d10v-elf-gcc -g overlays.o ovlymgr.o foo.o bar.o \
                  baz.o grbx.o -Wl,-Td10v.ld -o overlays
```

对于任何其他体系结构，构建过程都是相同的，只是必须将 `d10v-elf-gcc` 和 `d10v.ld` 替换为目标系统的适当编译器和链接器脚本。
