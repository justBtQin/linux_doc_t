# 10 检查数据

检查程序中数据的常用方法是使用 `print` 命令（缩写为 `p`），或者其同义词 `inspect` 。它计算并打印您程序所使用语言的表达式的值（请参见第 15 章[使用不同语言的 gdb]，第 227 页）。它还可以使用基于 Python 的漂亮打印器打印表达式（请参见第 10.10 节[漂亮打印]，第 168 页）。
```
	print [[options] --] expr
	print [[options] --] /f expr
		`expr` 是一个表达式（在源语言中）。默认情况下，`expr` 的值以适合其数据类型的格式打印；您可以通过指定 `/f` 来选择不同的格式，其中 `f` 是指定格式的字母；请参见第 10.5 节[输出格式]，第 150 页。
		`print` 命令支持许多选项，允许覆盖由 `set print` 子命令设置的相关全局打印设置：
		
		-address [on|off]
			设置地址的打印。相关设置：[set print address]，第 157 页。
		
		-array [on|off]
			数组的漂亮格式化。相关设置：[set print array]，第 159 页。
		
		-array-indexes [on|off]
			设置数组索引的打印。相关设置：[set print array-indexes]，第 159 页。
		
		-characters number-of-characters|elements|unlimited
			设置要打印的字符串字符的限制。`elements` 值会导致使用打印数组元素的限制。`unlimited` 值表示没有限制。相关设置：[set print characters]，第 159 页。
		
		-elements number-of-elements|unlimited
			设置要打印的数组元素以及可选的字符串字符的限制。有关此选项何时适用于字符串，请参见[set print characters]，第 159 页，以及上述 `-characters` 选项。`unlimited` 值表示没有限制。有关相关的 CLI 命令，请参见[set print elements]，第 160 页。
		
		-max-depth depth|unlimited
			设置嵌套结构被替换为省略号的阈值。相关设置：[set print max-depth]，第 163 页。
		
		-nibbles [on|off]
			设置是否以四个位一组（称为“半字节”）打印二进制值。请参见[set print nibbles]，第 159 页。
		
		-memory-tag-violations [on|off]
			设置打印有关内存标签违规的附加信息。请参见[set print memory-tag-violations]，第 164 页。
		
		-null-stop [on|off]
			设置字符数组在第一个空字符处停止打印。相关设置：[set print null-stop]，第 164 页。
		
		-object [on|off]
			设置打印 C++ 虚函数表。相关设置：[set print object]，第 167 页。
		
		-pretty [on|off]
			设置结构体的漂亮格式化。相关设置：[set print pretty]，第 165 页。
		
		-raw-values [on|off]
			设置是否以原始形式打印值，绕过该值的任何漂亮打印器。相关设置：[set print raw-values]，第 165 页。
		
		-repeats number-of-repeats|unlimited
			设置重复打印元素的阈值。`unlimited` 导致所有元素都单独打印。相关设置：[set print repeats]，第 163 页。
		
		-static-members [on|off]
			设置打印 C++ 静态成员。相关设置：[set print static-members]，第 167 页。
		
		-symbol [on|off]
			设置在打印指针时打印符号名称。相关设置：[set print symbol]，第 158 页。
		
		-union [on|off]
			设置打印结构体内部的联合体。相关设置：[set print union]，第 165 页。
		
		-vtbl [on|off]
			设置打印 C++ 虚函数表。相关设置：[set print vtbl]，第 167 页。

		因为 `print` 命令接受任意表达式，这些表达式可能看起来像选项（包括缩写），所以如果您指定任何命令选项，则必须使用双破折号（`--`）来标记选项处理的结束。
		例如，这会打印 `-p` 表达式的值：

			(gdb) print -p

		而这会在生效 `-pretty` 选项的情况下重复值历史中的最后一个值（见下文）：

			(gdb) print -p --

		这是一个同时包含选项和表达式的示例：

			(gdb) print -pretty -- *myptr
			$1 = {
				next = 0x0,
				flags = {
					sweet = 1,
					sour = 1
				},
				meat = 0x54 "Pork"
			}

	print [options]
	print [options] /f
		如果您省略 `expr`，gdb 会再次显示最后一个值（来自值历史；请参见第 10.11 节[值历史]，第 170 页）。这允许您以替代格式方便地检查相同的值。
```
如果架构支持内存标记，`print` 命令将在打印的内容是指针或引用类型时显示指针/内存标签不匹配。请参见第 10.7 节[内存标记]，第 154 页。

一种更低级的检查数据的方法是使用 `x` 命令。它检查指定地址的内存中的数据，并以指定的格式打印。请参见第 10.6 节[检查内存]，第 152 页。

如果您对类型的信息，或者结构体或类的字段如何声明感兴趣，请使用 `ptype expr` 命令而不是 `print` 。请参见第 16 章[检查符号表]，第 263 页。

另一种检查表达式的值和类型信息的方法是通过 Python 扩展命令 `explore`（仅在 gdb 构建配置为 `--with-python` 时可用）。它提供了一种交互式的方式，从表达式的数据类型的最高级别（或最抽象级别）开始，并一直探索到嵌入在更高级别数据类型中的叶子标量值/字段。
```
explore arg
	`arg` 要么是表达式（在源语言中），要么是在被调试程序的当前上下文中可见的类型。
	`explore` 命令的工作方式可以通过一个示例来说明。如果在您的 C 程序中定义了一个数据类型 `struct ComplexStruct` 如下：

		struct SimpleStruct
		{
			int i;
			double d;
		};

		struct ComplexStruct
		{
			struct SimpleStruct *ss_p;
			int arr[10];
		};

	接着有变量声明如下：

		struct SimpleStruct ss = { 10, 1.11 };
		struct ComplexStruct cs = { &ss, { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 } };

	那么，可以使用 `explore` 命令来探索变量 `cs` 的值，如下所示：

		(gdb) explore cs
		The value of ‘cs’ is a struct/class of type ‘struct ComplexStruct’ with the following fields:
			ss_p = <Enter 0 to explore this field of type ‘struct SimpleStruct *’>
			arr = <Enter 1 to explore this field of type ‘int [10]’>
		Enter the field number of choice:

	由于 `cs` 的字段不是标量值，您将被提示选择要探索的字段。假设您通过输入 `0` 选择字段 `ss_p` 。然后，由于此字段是一个指针，您将被询问它是否指向单个值。从上面 `cs` 的声明来看，它确实指向单个值，因此您输入 `y` 。如果您输入 `n` ，那么您将被询问它是否指向值的数组，在这种情况下，此字段将被视为数组进行探索。

		‘cs.ss_p’ is a pointer to a value of type ‘struct SimpleStruct’
		Continue exploring it as a pointer to a single value [y/n]: y
		The value of ‘*(cs.ss_p)’ is a struct/class of type ‘struct SimpleStruct’ with the following fields:
			i = 10.. (Value of type ‘int’)
			d = 1.1100000000000001.. (Value of type ‘double’)
		Press enter to return to parent value:

	如果之前通过输入 `1` 选择了 `cs` 的字段 `arr` 进行探索，那么由于它是一个数组，您将被提示输入要探索的数组元素的索引。

		‘cs.arr’ is an array of ‘int’.
		Enter the index of the element you want to explore in ‘cs.arr’: 5
		‘(cs.arr)[5]’ is a scalar value of type ‘int’.
		(cs.arr)[5] = 4
		Press enter to return to parent value:


	一般来说，在探索的任何阶段，您都可以通过适当地响应提示来更深入地探索叶子值，或者按回车键返回到封闭的数据结构（更高级别的数据结构）。

	与探索值类似，您可以使用 `explore` 命令来探索类型。不是指定一个值（通常是变量名或在被调试程序的当前上下文中有效的表达式），而是指定一个类型名。如果您考虑上面相同的示例，可以通过将参数 `struct ComplexStruct` 传递给 `explore` 命令来探索类型 `struct ComplexStruct` 。

		(gdb) explore struct ComplexStruct

	在后续的交互会话中适当地响应提示，您可以以类似于上面示例中探索值 `cs` 的方式探索类型 `struct ComplexStruct` 。

	`explore` 命令还有两个子命令，`explore value` 和 `explore type` 。

	前者子命令是一种明确指定正在调用表达式 `arg` 的值探索的方式，而后者是一种明确指定正在调用参数 `arg` 的类型探索的方式。

		explore value expr
			此 `explore` 的子命令探索表达式 `expr` 的值（如果 `expr` 是在被调试程序的当前上下文中有效的表达式）。
			此命令的行为与将参数 `expr` 传递给 `explore` 命令的行为相同。

		explore type arg
			此 `explore` 的子命令探索 `arg` 的类型（如果 `arg` 是在被调试程序的当前上下文中可见的类型），或者 `arg` 值/表达式的类型（如果 `arg` 是在被调试程序的当前上下文中有效的表达式）。如果 `arg` 是一个类型，那么此命令的行为与将参数 `arg` 传递给 `explore` 命令的行为相同。如果 `arg` 是一个表达式，那么此命令的行为将与将 `arg` 的类型作为参数传递给 `explore` 命令的行为相同。
```

## 10.1 表达式

`print` 和许多其他 gdb 命令接受一个表达式并计算其值。您正在使用的编程语言中定义的任何类型的常量、变量或运算符在 gdb 中的表达式中都是有效的。这包括条件表达式、函数调用、类型转换和字符串常量。它还包括预处理器宏，如果您编译程序时包含了此信息；请参见第 4.1 节[编译]，第 33 页。

gdb 支持用户输入的表达式中的数组常量。语法是 `{element, element...}` 。例如，您可以使用命令 `print {1, 2, 3}` 来创建一个包含三个整数的数组。如果您将数组传递给函数或将其赋值给程序变量，gdb 会将数组复制到目标程序中通过 `malloc` 分配的内存中。

由于 C 语言非常广泛，本手册中的大多数示例中的表达式都是 C 语言的。有关如何在其他语言中使用表达式的信息，请参见第 15 章[使用不同语言的 gdb]，第 227 页。

在本节中，我们讨论无论您使用何种编程语言，都可以在 gdb 表达式中使用的运算符。

类型转换在所有语言中都支持，而不仅仅是在 C 语言中，因为将数字转换为指针以便检查内存中该地址的结构非常有用。

除了编程语言中常见的运算符外，gdb 还支持以下运算符：
```
	@
		`@` 是一个二元运算符，用于将内存的部分视为数组。有关更多信息，请参见第 10.4 节[人工数组]，第 149 页。

	::
		`::` 允许您根据定义变量的文件或函数来指定变量。请参见第 10.3 节[程序变量]，第 147 页。

	{type} addr
		指的是存储在内存地址 `addr` 处的 `type` 类型的对象。地址 `addr` 可以是任何值为整数或指针的表达式（但对于二元运算符，需要像在类型转换中一样使用括号）。无论通常在 `addr` 处应该存储何种类型的数据，都允许这种构造。
```

## 10.2 歧义表达式

表达式有时可能包含一些有歧义的元素。例如，某些编程语言（特别是 Ada、C++ 和 Objective-C）允许一个函数名被多次定义，以应用于不同的上下文。这称为重载。涉及 Ada 的另一个示例是泛型。泛型包类似于 C++ 模板，通常会被多次实例化，导致相同的函数名在不同的上下文中被定义。

在某些情况下，并且取决于语言，有可能调整表达式以消除歧义。例如，在 C++ 中，您可以指定要中断的函数的签名，如 `break function(types)` 。在 Ada 中，使用函数的完全限定名称通常也会使表达式明确。

当检测到需要解决的歧义时，调试器能够为每种可能性显示一个编号的选择菜单，然后等待选择，并提示 `>` 。第一个选项始终是 `[0] cancel`，输入 0 并回车将中止当前命令。如果使用表达式的命令允许选择多个选项，菜单中的下一个选项是 `[1] all`，输入 1 并回车将选择所有可能的选项。

例如，以下会话摘录显示了尝试在重载符号 `String::after` 上设置断点的情况。我们选择了该函数名的三个特定定义：

```
	(gdb) b String::after
	[0] cancel
	[1] all
	[2] file:String.cc; line number:867
	[3] file:String.cc; line number:860
	[4] file:String.cc; line number:875
	[5] file:String.cc; line number:853
	[6] file:String.cc; line number:846
	[7] file:String.cc; line number:735
	> 2 4 6
	Breakpoint 1 at 0xb26c: file String.cc, line 867.
	Breakpoint 2 at 0xb344: file String.cc, line 875.
	Breakpoint 3 at 0xafcc: file String.cc, line 846.
	Multiple breakpoints were set.
	Use the "delete" command to delete unwanted
	breakpoints.
	(gdb)
```
```
	set multiple-symbols mode
		此选项允许您调整调试器在表达式有歧义时的行为。
		默认情况下，`mode` 设置为 `all` 。如果使用表达式的命令允许选择多个选项，那么 gdb 会自动选择所有可能的选项。例如，在具有歧义名称的函数上插入断点会导致在每个可能的匹配上插入断点。但是，如果必须做出唯一选择，那么 gdb 会使用菜单帮助您消除表达式的歧义。例如，打印重载函数的地址将导致使用菜单。
		当 `mode` 设置为 `ask` 时，调试器在检测到歧义时始终使用菜单。
		最后，当 `mode` 设置为 `cancel` 时，调试器会由于歧义报告错误并中止命令。

	show multiple-symbols
		显示 `multiple-symbols` 设置的当前值。
```

## 10.3 程序变量

在表达式中最常用的一种是您程序中的变量名。

表达式中的变量在选定的栈帧中被理解（请参见第 8.3 节[选择帧]，第 117 页）；它们必须是：

- 全局（或文件静态）

或

- 根据编程语言的作用域规则，从该帧的执行点可见

这意味着在函数

```c
foo (a)
int a;
{
	bar (a);
	{
		int b = test ();
		bar (b);
	}
}
```

只要您的程序在函数 `foo` 内执行，就可以检查和使用变量 `a`，但只有在程序在声明 `b` 的块内执行时，才能使用或检查变量 `b`。

有一个例外：您可以引用作用域为单个源文件的变量或函数，即使当前执行点不在此文件中。但是，可能会有多个具有相同名称的此类变量或函数（在不同的源文件中）。如果发生这种情况，引用该名称会产生不可预测的效果。如果您愿意，可以使用双冒号（`::`）表示法指定特定函数或文件中的静态变量：

`file::variable`

`function::variable`

这里，`file` 或 `function` 是静态变量的上下文名称。对于文件名，可以使用引号确保 gdb 将文件名解析为单个单词——例如，要打印在 `f2.c` 中定义的全局值 `x`：

```
(gdb) p 'f2.c'::x
```

`::` 表示法通常用于引用静态变量，因为您通常通过选择适当的帧并使用变量的简单名称来消除函数中局部变量的使用歧义。但是，您也可以使用此表示法引用包含所选帧的帧中的局部变量：

```c
void
foo (int a)
{
    if (a < 10)
        bar (a);
    else
        process (a); /* Stop here */
}

int
bar (int a)
{
    foo (a + 5);
}
```

例如，如果在注释行有一个断点，在执行 `bar(0)` 调用后程序停止时，您可能会看到：

```
(gdb) p a
$1 = 10
(gdb) p bar::a
$2 = 5
(gdb) up 2
#2 0x080483d0 in foo (a=5) at foobar.c:12
(gdb) p a
$3 = 5
(gdb) p bar::a
$4 = 0
```

这些 `::` 的用法很少与 C++ 中非常相似的相同表示法冲突。当它们冲突时，C++ 的含义优先；但是，可以通过用单引号引住文件或函数名称来覆盖。

例如，假设程序在一个类的方法中停止，该类有一个名为 `includefile` 的字段，并且还有一个名为 `includefile` 的包含文件，其中定义了一个变量 `some_global`。

```
(gdb) p includefile
$1 = 23
(gdb) p includefile::some_global
A syntax error in expression, near ‘’.
(gdb) p 'includefile'::some_global
$2 = 27
```

警告：偶尔，在函数中的某些点，局部变量可能看起来具有错误的值——就在进入新的作用域之后，以及就在退出之前。

当您按机器指令逐步执行时，可能会看到此问题。这是因为，在大多数机器上，设置栈帧（包括局部变量定义）需要不止一条指令；如果您按机器指令逐步执行，在栈帧完全构建之前，变量可能看起来具有错误的值。在退出时，通常也需要不止一条机器指令来销毁栈帧；在您开始逐步执行该组指令后，局部变量定义可能会消失。

这也可能在编译器进行显著优化时发生。为了确保始终看到准确的值，在编译时关闭所有优化。

编译器优化的另一个可能影响是将未使用的变量优化掉，或将变量分配到寄存器（而不是内存地址）。根据编译器使用的调试信息格式对这种情况的支持，gdb 可能无法显示此类局部变量的值。如果发生这种情况，gdb 将打印如下消息：

`No symbol "foo" in current context.`

要解决此类问题，可以重新编译而不进行优化，或者如果编译器支持多种此类格式，则使用不同的调试信息格式。有关选择编译器选项的更多信息，请参见第 4.1 节[编译]，第 33 页。有关最适合 C++ 程序的调试信息格式的更多信息，请参见第 15.4.1 节[C 和 C++]，第 231 页。

如果您要求打印 gdb 不知道其内容的对象，例如，因为其数据类型未由调试信息完全指定，gdb 将说 `<incomplete type>` 。有关此内容的更多信息，请参见第 16 章[符号]，第 263 页。

如果您尝试检查或使用 gdb 没有类型信息的（全局）变量的值，例如，因为程序不包含调试信息，gdb 将显示错误消息。有关未知类型的更多信息，请参见第 16 章[符号]，第 263 页。如果您将变量转换为其声明的类型，gdb 将使用转换后的类型作为变量的类型获取变量的值。例如，在 C 程序中：

```
(gdb) p var
'var' has unknown type; cast it to its declared type
(gdb) p (float) var
$1 = 3.14
```

如果您在函数参数名称后附加 `@entry string`，您将获得函数调用时该参数的值。如果该值不可用，则会打印错误消息。入口值仅在某些编译器中可用。根据 [set print entry-values]，第 161 页，入口值通常也会在函数参数列表中打印。

```
Breakpoint 1, d (i=30) at gdb.base/entry-value.c:29
29 i++;
(gdb) next
30 e (i);
(gdb) print i
$1 = 31
(gdb) print i@entry
$2 = 30
```

字符串被识别为未指定符号性的 `char` 值数组。有符号 `char` 或无符号 `char` 的数组将被打印为 1 字节大小的整数数组。`-fsigned-char` 或 `-funsigned-char` gcc 选项没有效果，因为 gdb 将文字字符串类型 `"char"` 定义为无符号的 `char` 。对于程序代码

```c
char var0[] = "A";
signed char var1[] = "A";
```

在调试期间，您会得到

```
(gdb) print var0
$1 = "A"
(gdb) print var1
$2 = {65 'A', 0 '\0'}
```

## 10.4 人工数组

打印内存中相同类型的连续几个对象通常很有用；比如数组的一部分，或者程序中只有一个指针存在的动态确定大小的数组。

您可以通过使用二元运算符 `@` 将连续的内存段视为人工数组来实现这一点。`@` 的左操作数应该是所需数组的第一个元素，并且是一个单独的对象。右操作数应该是数组所需的长度。结果是一个数组值，其元素都是左操作数的类型。第一个元素实际上是左操作数；第二个元素来自存储第一个元素的字节后面紧接的字节，依此类推。这里有一个示例。如果一个程序说

```c
int *array = (int *) malloc (len * sizeof (int));
```

您可以使用

```
p *array@len
```

来打印 `array` 的内容。

`@` 的左操作数必须驻留在内存中。以这种方式使用 `@` 创建的数组值在下标方面的行为与其他数组完全相同，并且在表达式中使用时会强制转换为指针。在打印出一个人工数组后，它们通常通过值历史（请参见第 10.11 节[值历史]，第 170 页）出现在表达式中。

创建人工数组的另一种方法是使用类型转换。这会将一个值重新解释为好像它是一个数组。该值不一定在内存中：

```
(gdb) p/x (short[2])0x12345678
$1 = {0x1234, 0x5678}
```

为了方便，如果您省略数组长度（如 `(type[])value`），gdb 会计算出填充该值所需的大小（如 `sizeof(value)/sizeof(type)`）：

```
(gdb) p/x (short[])0x12345678
$2 = {0x1234, 0x5678}
```

有时人工数组机制还不够；在中等复杂的数据结构中，感兴趣的元素可能实际上并不相邻——例如，如果您对数组中的指针值感兴趣。在这种情况下，一个有用的解决方法是使用便利变量（请参见第 10.12 节[便利变量]，第 171 页）作为表达式中的计数器来打印第一个感兴趣的值，然后通过回车键重复该表达式。例如，假设您有一个指向结构体的指针数组 `dtab`，并且您对每个结构体中的字段 `fv` 的值感兴趣。以下是您可能输入的示例：

```
set $i = 0
p dtab[$i++]->fv
RET
RET
...
```

## 10.5 输出格式

默认情况下，gdb 根据数据类型打印值。有时这不是您想要的。例如，您可能希望以十六进制打印数字，或以十进制打印指针。或者您可能希望将特定地址的内存中的数据视为字符串或指令。要执行这些操作，请在打印值时指定输出格式。

输出格式的最简单用法是说明如何打印已经计算的值。这是通过在 `print` 命令的参数开头使用斜杠和格式字母来完成的。支持的格式字母包括：

- `x`

  以十六进制打印值的二进制表示。

- `d`

  以十进制打印值的二进制表示。

- `u`

  将值的二进制表示视为无符号十进制并打印。

- `o`

  以八进制打印值的二进制表示。

- `t`

  以二进制打印值的二进制表示。字母 `t` 代表“two” 1 。

- `a`

  以地址形式打印，包括十六进制的绝对地址和相对于最近的前一个符号的偏移量。您可以使用此格式来发现未知地址位于何处（在哪个函数中）：

```
  (gdb) p/a 0x54320
  $3 = 0x54320 <_initialize_vx+396>
```

  `info symbol 0x54320` 命令会产生类似的结果。请参见第 16 章[符号]，第 263 页。

- `c`

  将值转换为整数（与其他格式不同，这不只是重新解释底层位）并将其作为字符常量打印。这会打印数值及其字符表示。对于超出 7 位 ASCII 范围的字符，字符表示将替换为八进制转义 `\nnn` 。

  没有此格式，gdb 将 `char`、`unsigned char` 和 `signed char` 数据显示为字符常量。向量的单字节成员显示为整数数据。

- `f`

  将值的位视为浮点数，并使用典型的浮点数语法打印。

- `s`

  如果可能，将其视为字符串。使用此格式，指向单字节数据的指针显示为空终止字符串，单字节数据的数组显示为固定长度字符串。其他值以其自然类型显示。

  没有此格式，gdb 将指向 `char`、`unsigned char` 和 `signed char` 的指针以及它们的数组显示为字符串。向量的单字节成员显示为整数数组。

- `z`

  与 `x` 格式类似，将值视为整数并以十六进制打印，但会打印前导零以将值填充到整数类型的大小。

- `r`

  使用“原始”格式打印。默认情况下，如果有可用的基于 Python 的漂亮打印器（请参见第 10.10 节[漂亮打印]，第 168 页），gdb 将使用它。这通常会导致值内容的更高级显示。`r` 格式绕过任何可能存在的 Python 漂亮打印器。

例如，要以十六进制打印程序计数器（请参见第 10.14 节[寄存器]，第 179 页），键入

```
p/x $pc
```

请注意，斜杠之前不需要空格；这是因为 gdb 中的命令名称不能包含斜杠。

要以不同格式重新打印值历史中的最后一个值，您可以使用 `print` 命令，只带有格式而没有表达式。例如，`p/x` 以十六进制重新打印最后一个值。

## 10.6 检查内存

您可以使用 `x` 命令（表示“examine”）以多种格式检查内存，而不受程序数据类型的限制。
```
	x/nfu addr
	x addr
	x	
		使用 `x` 命令来检查内存。
		`n`、`f` 和 `u` 都是可选参数，用于指定要显示多少内存以及如何格式化；`addr` 是一个表达式，给出您要开始显示内存的地址。如果您使用 `nfu` 的默认值，则无需键入斜杠 `/`。有几个命令为 `addr` 设置了方便的默认值。

	n，重复计数
		重复计数是一个十进制整数；默认值为 1。它指定要显示多少内存（按单位 `u` 计算）。如果指定了负数，则从 `addr` 向后检查内存。

	f，显示格式
		显示格式是 `print` 命令使用的格式之一（`x`、`d`、`u`、`o`、`t`、`a`、`c`、`f`、`s`）、`i`（用于机器指令）和 `m`（用于显示内存标签）。默认初始值为 `x`（十六进制）。每次使用 `x` 或 `print` 时，默认值都会更改。

	u，单位大小
		单位大小可以是：
			b 字节。
			h 半字（两个字节）。
			w 字（四个字节）。这是初始默认值。
			g 巨字（八个字节）。
		每次使用 `x` 指定单位大小时，该大小将成为下次使用 `x` 时的默认单位。对于 `i` 格式，单位大小被忽略，通常不写。对于 `s` 格式，单位大小默认为 `b`，除非明确给出。使用 `x /hs` 显示 16 位字符字符串，使用 `x /ws` 显示 32 位字符串。下次使用 `x /s` 将再次显示 8 位字符串。请注意，结果取决于当前编译单元的编程语言。如果语言是 C，`s` 修饰符将使用 UTF-16 编码，而 `w` 将使用 UTF-32 编码。编码由编程语言设置，无法更改。

	addr，起始显示地址
	  `addr` 是您希望 gdb 开始显示内存的地址。表达式不一定具有指针值（尽管可以）；它始终被解释为一个字节内存的整数地址。有关表达式的更多信息，请参见第 10.1 节[表达式]，第 145 页。`addr` 的默认值通常是刚刚检查过的最后一个地址之后——但还有其他几个命令也会设置默认地址：`info breakpoints`（到列出的最后一个断点的地址）、`info line`（到一行的起始地址）和 `print`（如果您使用它来显示来自内存的值）。
```

  例如，`x/3uh 0x54320` 是一个请求，以无符号十进制整数（`u`）格式显示从地址 0x54320 开始的三个半字（`h`）的内存。`x/4xw $sp` 以十六进制（`x`）打印堆栈指针（这里是 `$sp`；请参见第 10.14 节[寄存器]，第 179 页）上方的四个字（`w`）的内存。

  您还可以指定一个负的重复计数，以从给定地址向后检查内存。例如，`x/-3uh 0x54320` 打印 0x5431a、0x5431c 和 0x5431e 处的三个半字（`h`）。

  由于表示单位大小的字母都与指定输出格式的字母不同，您不必记住单位大小或格式哪个先；两种顺序都有效。输出规范 `4xw` 和 `4wx` 意思完全相同。（但是，计数 `n` 必须首先出现；`wx4` 不起作用。）

  即使对于 `s` 和 `i` 格式单位大小 `u` 被忽略，您可能仍然希望使用计数 `n`；例如，`3i` 指定您希望看到三个机器指令，包括任何操作数。为了方便起见，特别是与 `display` 命令一起使用时，`i` 格式还会打印超出指定计数的分支延迟槽指令（如果有），这些指令紧跟在计数范围内的最后一个指令之后。`disassemble` 命令提供了另一种检查机器指令的方法；请参见第 9.6 节[源代码和机器码]，第 135 页。

  如果为 `s` 或 `i` 格式指定了负的重复计数，则该命令会在给定地址之前显示空终止字符串或指令，数量为给定数字的绝对值。对于 `i` 格式，我们使用调试信息中的行号信息在向后反汇编时准确地定位指令边界。如果没有行信息可用，该命令将停止检查内存并显示错误消息。

  `x` 命令的所有参数的默认值旨在使您每次使用 `x` 时都能以最少的规范轻松继续扫描内存。例如，在使用 `x/3i addr` 检查了三个机器指令之后，您可以仅使用 `x/7` 检查接下来的七个。如果您使用回车键重复 `x` 命令，则重复计数 `n` 会再次使用；其他参数默认为连续使用 `x` 的情况。

  当检查机器指令时，当前程序计数器处的指令会用 `=>` 标记显示。例如：

```
	(gdb) x/5i $pc - 6
	   0x804837f <main + 11>: mov   %esp, %ebp
	   0x8048381 <main + 13>: push  %ecx
	   0x8048382 <main + 14>: sub   $0x4, %esp
	=> 0x8048385 <main + 17>: movl  $0x8048460, (%esp)
	   0x804838c <main + 24>: call  0x80482d4 <puts@plt>
```

  如果架构支持内存标记，可以使用 `m` 来显示标记。请参见第 10.7 节[内存标记]，第 154 页。

  信息将按每个粒度大小（特定内存标签覆盖的字节数）显示一次。例如，AArch64 的粒度大小为 16 字节，因此它将每 16 字节显示一个标签。

  由于 gdb 使用 `x` 命令打印信息的方式（未对齐到特定边界），标签信息将引用特定行上显示的初始地址。如果在 `x` 命令显示的一行中间跨越了内存标签边界，它将在下一行显示。

  `m` 格式不会影响传递给 `x` 命令的任何其他指定格式。

  `x` 命令打印的地址和内容不会保存在值历史中，因为通常数量太多会造成干扰。相反，gdb 将这些值在后续表达式中作为便利变量 `$_` 和 `$__` 可用。在 `x` 命令之后，最后检查的地址在便利变量 `$_` 中可用于表达式。检查的该地址的内容在便利变量 `$__` 中可用。

  如果 `x` 命令有重复计数，保存的地址和内容来自打印的最后一个内存单元；如果在输出的最后一行打印了多个单元，则这与打印的最后一个地址不同。

  大多数目标的可寻址内存单元大小为 8 位。这意味着每个内存地址都关联 8 位数据。但是，某些目标具有其他可寻址内存单元大小。在 gdb 和本文档中，当明确引用该大小的数据块时，使用术语可寻址内存单元（或简称内存单元）。单词“字节”用于指代 8 位的数据块，无论目标的可寻址内存单元大小如何。对于大多数系统，可寻址内存单元是字节的同义词。

  当您调试在远程目标机器上运行的程序时（请参见第 20 章[远程调试]，第 315 页），您可能希望根据下载到目标的可执行文件验证远程机器内存中的程序映像。或者，在任何目标上，您可能想要检查程序是否损坏了其自身的只读部分。为此提供了 `compare-sections` 命令。

```
	compare-sections [section-name|-r]
		将正在调试的程序的可执行文件中的可加载部分 `section-name` 的数据与目标机器内存中的相同部分进行比较，并报告任何不匹配。如果没有参数，则比较所有可加载部分。使用参数 `-r` 时，比较所有可加载的只读部分。
		注意：对于远程目标，如果目标支持计算内存块的 CRC 校验和（请参见[qCRC 数据包]，第 792 页），此命令可以加速。
```

## 10.7 内存标记

内存标记是一种内存保护技术，它使用一对标记来通过指针验证内存访问。标记是整数值，通常由几个位组成，具体取决于架构。

在此设置中使用了两种类型的标记：逻辑标记和分配标记。逻辑标记存储在指针本身中，通常在指针的高位。分配标记是与物理地址空间中特定范围的内存相关联的标记，与指针的逻辑标记进行比较。

指针标记（逻辑标记）必须与内存标记（分配标记）匹配，内存访问才有效。如果逻辑标记与分配标记不匹配，将引发内存违规。

分配标记覆盖物理内存中多个连续的字节。这个字节范围称为内存标记粒度，并且是特定于架构的。例如，AArch64 的标记粒度为 16 字节，这意味着每个分配标记跨越 16 字节的内存。

如果底层架构支持内存标记，如 AArch64 MTE 或 SPARC ADI，gdb 可以利用它根据内存分配标记来验证指针。

`print`（请参见第 10 章[数据]，第 141 页）和 `x`（请参见第 10.6 节[内存]，第 152 页）命令在适当的时候会显示标记信息，并且以 `memory-tag` 为前缀的命令可以访问各种内存标记命令。

内存标记命令如下：
```
	memory-tag print-logical-tag pointer_expression
		打印存储在指针表达式中的逻辑标记。

	memory-tag with-logical-tag pointer_expression tag_bytes
		打印由指针表达式给出的指针，并增加 `tag_bytes` 的逻辑标记。

	memory-tag print-allocation-tag address_expression
		打印由地址表达式给出的内存地址相关联的分配标记。

	memory-tag setatag starting_address length tag_bytes
		将内存范围[起始地址，起始地址 + 长度）的分配标记设置为 `tag_bytes` 。

	memory-tag check pointer_expression
		检查由指针表达式给出的指针中的逻辑标记是否与该指针引用的内存的分配标记匹配。
		这本质上模拟了通过带标记的内存进行访问时硬件所做的验证，但不会像硬件验证时那样导致内存错误。
		它可用于在触发任何错误之前检查正在运行的进程中潜在的内存标记违规。
```

## 10.8 自动显示

如果您发现经常需要打印某个表达式的值（以查看其如何变化），您可能希望将其添加到自动显示列表中，以便 gdb 在每次程序停止时打印其值。添加到列表中的每个表达式都被赋予一个编号以进行标识；要从列表中删除一个表达式，请指定该编号。自动显示如下所示：

```
	2: foo = 38
	3: bar[5] = (struct hack *) 0x3804
```

此显示显示项目编号、表达式及其当前值。与您使用 `x` 或 `print` 手动请求的显示一样，您可以指定您喜欢的输出格式；实际上，`display` 根据您的格式规范决定使用 `print` 还是 `x` - 如果您指定了 `i` 或 `s` 格式，或者单位大小，则使用 `x`；否则使用 `print` 。
```
	display expr
	  将表达式 `expr` 添加到每次程序停止时要显示的表达式列表中。请参见第 10.1 节[表达式]，第 145 页。
	  使用 `display` 后再次按回车键不会重复。

	display/fmt expr
	  对于仅指定显示格式而不是大小或计数的 `fmt`，将表达式 `expr` 添加到自动显示列表中，但安排每次都以指定的格式 `fmt` 显示。请参见第 10.5 节[输出格式]，第 150 页。

	display/fmt addr
	  对于 `fmt` 为 `i` 或 `s`，或者包括单位大小或单位数量，将表达式 `addr` 作为每次程序停止时要检查的内存地址添加。
	  检查实际上意味着执行 `x/fmt addr` 。请参见第 10.6 节[检查内存]，第 152 页。
```
例如，`display/i $pc` 可能会有所帮助，以便在每次执行停止时查看即将执行的机器指令（`$pc` 是程序计数器的常见名称；请参见第 10.14 节[寄存器]，第 179 页）。
```
	undisplay dnums...
	delete display dnums...
	  从要显示的表达式列表中删除项目。使用命令参数 `dnums` 指定您希望受影响的显示编号。它可以是单个显示编号，即 `info display` 显示的第一个字段中显示的编号之一；也可以是显示编号范围，例如 2 - 4 。
	  使用 `undisplay` 后按回车键不会重复。（否则您只会得到“没有显示编号...”的错误。）

	disable display dnums...
	  禁用编号为 `dnums` 的显示项目。禁用的显示项目不会自动打印，但不会被遗忘。以后可以再次启用。
	  使用命令参数 `dnums` 指定您希望受影响的显示编号。它可以是单个显示编号，即 `info display` 显示的第一个字段中显示的编号之一；也可以是显示编号范围，例如 2 - 4 。

	enable display dnums...
	  启用编号为 `dnums` 的显示项目。在自动显示其表达式时再次生效，直到您另行指定。
	  使用命令参数 `dnums` 指定您希望受影响的显示编号。它可以是单个显示编号，即 `info display` 显示的第一个字段中显示的编号之一；也可以是显示编号范围，例如 2 - 4 。

	display
	  显示列表中表达式的当前值，就像程序停止时所做的那样。

	info display
	  打印先前设置为自动显示的表达式列表，每个都带有其项目编号，但不显示值。这包括禁用的表达式，它们会被标记出来。它还包括当前由于它们引用不可用的自动变量而不会立即显示的表达式。
```

如果显示表达式引用局部变量，那么在设置它的词法上下文之外就没有意义。当执行进入其中一个变量未定义的上下文时，这样的表达式将被禁用。例如，如果您在具有参数 `last_char` 的函数内部给出命令 `display last_char`，gdb 会在您的程序继续在该函数内停止时显示此参数。当它在其他地方停止 - 没有变量 `last_char` 的地方 - 显示将自动禁用。

下次您的程序在 `last_char` 有意义的地方停止时，您可以再次启用显示表达式。

## 10.9 打印设置

gdb 提供了以下方法来控制数组、结构体和符号的打印方式。这些设置对于调试任何语言的程序都很有用：
```
	set print address
	set print address on
		gdb 打印内存地址，显示堆栈跟踪、结构体值、指针值、断点等的位置，即使它也显示这些地址的内容。默认是开启的。例如，这是 `set print address on` 时的堆栈帧显示：
			(gdb) f
			#0 set_quotes (lq=0x34c78 "<<", rq=0x34c88 ">>")
			   at input.c:530
			530       if (lquote!= def_lquote)

	set print address off
		显示内容时不打印地址。例如，这是 `set print address off` 时相同的堆栈帧显示：
			(gdb) set print addr off
			(gdb) f
			#0 set_quotes (lq="<<", rq=">>") at input.c:530
			530       if (lquote!= def_lquote)
		您可以使用 `set print address off` 从 gdb 界面中消除所有与机器相关的显示。例如，关闭打印地址后，在所有机器上，对于回溯（无论是否涉及指针参数），您应该得到相同的文本。

	show print address
		显示是否打印地址。
```
当 gdb 打印一个符号地址时，它通常打印最接近的早期符号加上偏移量。如果该符号不能唯一标识地址（例如，它是一个作用域为单个源文件的名称），您可能需要澄清。一种方法是使用 `info line`，例如 `info line *0x4537`。或者，您可以设置 gdb 在打印符号地址时打印源文件名和行号：
```
set print symbol-filename on
	告诉 gdb 在地址的符号形式中打印符号的源文件名和行号。

set print symbol-filename off
	不打印符号的源文件名和行号。这是默认值。

show print symbol-filename
	显示 gdb 是否将在地址的符号形式中打印符号的源文件名和行号。
```

  另一个需要显示符号文件名和行号的情况是在反汇编代码时；gdb 会向您显示每个指令对应的行号和源文件。

  此外，您可能希望仅在打印的地址与最接近的早期符号相当接近时才看到符号形式：
```
set print max-symbolic-offset max-offset
set print max-symbolic-offset unlimited
	告诉 gdb 仅在最接近的早期符号与地址之间的偏移量小于 `max-offset` 时显示地址的符号形式。默认值是 `unlimited`，这告诉 gdb 如果有任何符号在其之前，则始终打印地址的符号形式。零等同于 `unlimited`。

show print max-symbolic-offset
	询问 gdb 在符号地址中打印的最大偏移量是多少。
```

如果您有一个指针并且不确定它指向何处，请尝试 `set print symbol-filename on`。然后，您可以使用 `p/a pointer` 确定它所指向的变量的名称和源文件位置。这以符号形式解释地址。例如，这里 gdb 显示变量 `ptt` 指向另一个在 `hi2.c` 中定义的变量 `t`：

```
	(gdb) set print symbol-filename on
	(gdb) p/a ptt
	$4 = 0xe008 <t in hi2.c>
	警告：对于指向局部变量的指针，即使打开了适当的 `set print` 选项，`p/a` 也不会显示所引用的符号名称和文件名。
```

您还可以使用 `set print symbol on` 始终启用 `/a` 类似的格式化：

```
	set print symbol on
		告诉 gdb 如果存在与地址对应的符号，则打印该符号。

	set print symbol off
		告诉 gdb 不打印与地址对应的符号。在这种模式下，gdb 仍将打印指向函数的指针的符号。这是默认值。

	show print symbol
		显示 gdb 是否将显示与地址对应的符号。
```

其他设置控制不同类型对象的打印方式：

```
	set print array
	set print array on
		漂亮打印数组。这种格式更便于阅读，但使用更多空间。默认是关闭的。

	set print array off
		恢复为数组的压缩格式。

	show print array
		显示选择的是压缩格式还是漂亮格式来显示数组。

	set print array-indexes
	set print array-indexes on
		显示数组时打印每个元素的索引。可能更便于在数组中定位给定元素或快速找到该打印数组中给定元素的索引。默认是关闭的。

	set print array-indexes off
		显示数组时停止打印元素索引。

	show print array-indexes
		显示显示数组时是否打印每个元素的索引。

	set print nibbles
	set print nibbles on
		在使用带有 `/t` 选项的 gdb 的 `print` 命令时，以四个位一组（称为半字节）打印二进制值。例如，这是 `set print nibbles on` 时的样子：
			(gdb) print val_flags
			$1 = 1230
			(gdb) print/t val_flags
			$2 = 0100 1100 1110

	set print nibbles off
		不分组打印二进制值。这是默认值。

	show print nibbles
		显示是否以四个位一组打印二进制值。

	set print characters number-of-characters
	set print characters elements
	set print characters unlimited
		设置 gdb 打印字符串时将打印的字符数限制。如果 gdb 正在打印一个大字符串，在打印了由 `set print characters` 命令设置的字符数后，它将停止打印。这同样适用于多字节和宽字符串，即对于字符类型为 `wchar_t`、`char16_t` 或 `char32_t` 的字符串，此设置控制的是实际字符的数量，而不是编码使用的底层字节数。将 `number-of-characters` 设置为 `elements` 意味着打印的字符数限制遵循数组元素的限制；请参见[set print elements]，第 160 页。将 `number-of-characters` 设置为 `unlimited` 意味着打印的字符数不受限制。当 gdb 启动时，此限制设置为 `elements` 。

	show print characters
		显示 gdb 将打印的大字符串的字符数。

	set print elements number-of-elements
	set print elements unlimited
		设置 gdb 将打印的数组元素的数量限制。如果 gdb 正在打印一个大数组，在打印了由 `set print elements` 命令设置的元素数量后，它将停止打印。默认情况下，此限制也适用于字符串的显示；请参见[set print characters]，第 159 页。当 gdb 启动时，此限制设置为 200 。将 `number-of-elements` 设置为 `unlimited` 或零意味着打印的元素数量不受限制。
		当打印非常大的数组（其大小大于 `max-value-size`（请参见[max-value-size]，第 192 页））时，如果 `print elements` 设置为使得正在打印的元素的大小小于或等于 `max-value-size`，则 gdb 将打印数组（最多达到 `print elements` 限制），并且仅将 `max-value-size` 价值的数据添加到值历史中（请参见第 10.11 节[值历史]，第 170 页）。

	show print elements
		显示 gdb 将打印的大数组的元素数量。

	set print frame-arguments value
		此命令允许控制调试器打印帧时如何打印参数的值（请参见第 8.1 节[帧]，第 113 页）。可能的值是：
			all     	打印所有参数的值。
			scalars     仅在参数是标量时打印其值。更复杂的参数（如数组、结构体、联合体等）的值将替换为 `...` 。这是默认值。
						这里是一个仅显示标量参数的示例：
						#1 0x08048361 in call_me (i=3, s=..., ss=0xbf8d508c, u=..., e=green)
						at frame-args.c:23

			none        不打印任何参数的值。而是将每个参数的值替换为 `...` 。
						在这种情况下，上面的示例现在变为：
						#1 0x08048361 in call_me (i=..., s=..., ss=..., u=..., e=...)
						at frame-args.c:23

			presence    仅通过 `...` 指示参数的存在。对于没有任何参数的函数，不打印 `...` 。不打印任何参数名称和值。
						在这种情况下，上面的示例现在变为：
						#1 0x08048361 in call_me (...) at frame-args.c:23

		默认情况下，仅打印标量参数。此命令可用于配置调试器以打印所有参数的值，无论其类型如何。但是，通常不打印更复杂参数的值是有利的。例如，它减少了每个帧中打印的信息量，使回溯更具可读性。此外，在显示 Ada 帧时提高了性能，因为大型参数的计算有时可能是 CPU 密集型的，尤其是在大型应用程序中。将 `print frame-arguments` 设置为 `scalars`（默认值）、`none` 或 `presence` 可避免此计算，从而加快每个 Ada 帧的显示速度。

	show print frame-arguments
		显示打印帧时应如何显示参数的值。

	set print raw-frame-arguments on
		以原始、未漂亮打印的形式打印帧参数。

	set print raw-frame-arguments off
		如果有漂亮打印器（请参见第 10.10 节[漂亮打印]，第 168 页），则以漂亮打印形式打印帧参数，否则以原始形式打印值。这是默认值。

	show print raw-frame-arguments
		显示是否以原始形式打印帧参数。

	set print entry-values value
		设置在函数入口处打印帧参数值。在某些情况下，gdb 可以确定函数调用者传递的函数参数的值，即使该值在被调用函数内部被修改并且因此不同。对于优化的代码，当前值可能不可用，但入口值可能仍然已知。
		默认值是 `default`（请参见下面的描述）。较旧的 gdb 表现为设置为 `no` 。不支持此功能的编译器在默认设置下的行为与设置为 `no` 相同。
		此功能目前仅由 DWARF 2 调试格式支持，并且编译器必须生成 `DW_TAG_call_site` 标签。使用 gcc，您需要在编译时指定 `-O -g` 以获取此信息。
		`value` 参数可以是以下之一：

			no          仅打印实际参数值，从不打印函数入口点的值。
						#0 equal (val=5)
						#0 different (val=6)
						#0 lost (val=<optimized out>)
						#0 born (val=10)
						#0 invalid (val=<optimized out>)

			only        仅打印函数入口点的参数值。从不打印实际参数值。
						#0 equal (val@entry=5)
						#0 different (val@entry=5)
						#0 lost (val@entry=5)
						#0 born (val@entry=<optimized out>)
						#0 invalid (val@entry=<optimized out>)

			preferred   仅打印函数入口点的参数值。如果函数入口点的值未知而实际值已知，则打印此类参数的实际值。
						#0 equal (val@entry=5)
						#0 different (val@entry=5)
						#0 lost (val@entry=5)
						#0 born (val=10)
						#0 invalid (val@entry=<optimized out>)

			if-needed   打印实际参数值。如果实际参数值未知而函数入口点的值已知，则打印此类参数的入口点值。
						#0 equal (val=5)
						#0 different (val=6)
						#0 lost (val@entry=5)
						#0 born (val=10)
						#0 invalid (val=<optimized out>)

			both        始终打印实际参数值及其函数入口点的值，即使由于编译器优化一个或两个值都不可用。
						#0 equal (val=5, val@entry=5)
						#0 different (val=6, val@entry=5)
						#0 lost (val=<optimized out>, val@entry=5)
						#0 born (val=10, val@entry=<optimized out>)
						#0 invalid (val=<optimized out>, val@entry=<optimized out>)

			compact     如果已知实际参数值，则打印它，如果也已知函数入口点的值，则打印它。如果两者都未知，则打印 `<optimized out>` 。如果不在 MI 模式（请参见第 27 章[GDB/MI]，第 591 页）并且如果两个值都已知且相同，则打印缩短的 `param=param@entry=VALUE` 表示法。
						#0 equal (val=val@entry=5)
						#0 different (val=6, val@entry=5)
						#0 lost (val@entry=5)
						#0 born (val=10)
						#0 invalid (val=<optimized out>)

			default     始终打印实际参数值。也打印函数入口点的值，但仅在已知的情况下。如果不在 MI 模式（请参见第 27 章[GDB/MI]，第 591 页）并且如果两个值都已知且相同，则打印缩短的 `param=param@entry=VALUE` 表示法。
						#0 equal (val=val@entry=5)
						#0 different (val=6, val@entry=5)
						#0 lost (val=<optimized out>, val@entry=5)
						#0 born (val=10)
						#0 invalid (val=<optimized out>)
		有关函数入口处帧参数值解析可能失败的分析消息，请参见[set debug entry-values]，第 196 页。

	show print entry-values
		显示在函数入口处打印帧参数值所使用的方法。

	set print frame-info value
		此命令允许控制调试器打印帧时打印的信息。请参见第 8.1 节[帧]，第 113 页，第 8.2 节[回溯]，第 114 页，了解有关帧和帧信息的一般解释。请注意，其他一些设置（例如 `set print frame-arguments` 和 `set print address`）也会影响某些帧信息是否以及如何显示。特别是，如果 `set print address` 关闭，则永远不会打印帧的程序计数器。
		`set print frame-info` 的可能值是：
			short-location          打印帧级别、程序计数器（如果不在位置源行的开头）、函数、函数参数。
			location                与 `short-location` 相同，但还打印源文件和源行号。
			location-and-address    与 `location` 相同，但即使程序计数器位于位置源行的开头也打印程序计数器。
			source-line             打印程序计数器（如果不在位置源行的开头）、行号和源行。
			source-and-location     打印 `location` 和 `source-line` 所打印的内容。
			auto                    为帧打印的信息由打印帧的 gdb 命令自动决定。例如，`frame` 命令打印 `source-and-location` 所打印的信息，而 `stepi` 将根据程序计数器在 `source-line` 和 `source-and-location` 之间切换。默认值是 `auto`。

	set print repeats number-of-repeats
	set print repeats unlimited
		设置抑制显示重复数组元素的阈值。当数组的连续相同元素的数量超过阈值时，gdb 打印字符串“<repeats n times>”，其中 n 是相同重复的次数，而不是显示相同的元素本身。将阈值设置为 `unlimited` 或零将导致所有元素单独打印。默认阈值是 10 。

	show print repeats
		显示当前打印重复相同元素的阈值。

	set print max-depth depth
	set print max-depth unlimited
		设置嵌套结构被替换为省略号的阈值，这可以使可视化深度嵌套结构更容易。
		例如，给定以下 C 代码
			typedef struct s1 { int a; } s1;
			typedef struct s2 { s1 b; } s2;
			typedef struct s3 { s2 c; } s3;
			typedef struct s4 { s3 d; } s4;
			s4 var = { { { { 3 } } } };

		下面的表格显示了不同的 `depth` 值如何影响 gdb 打印 `var` 的方式：

			深度设置                  `p var` 的结果
			unlimited                $1 = {d = {c = {b = {a = 3}}}}
			0                        $1 = {...}
			1                        $1 = {d = {...}}
			2                        $1 = {d = {c = {...}}}
			3                        $1 = {d = {c = {b = {...}}}}
			4                        $1 = {d = {c = {b = {a = 3}}}}

		要查看被隐藏的结构的内容，用户可以增加 `print max-depth`，或者打印可见的结构元素，例如

			(gdb) set print max-depth 2
			(gdb) p var
			$1 = {d = {c = {...}}}
			(gdb) p var.d
			$2 = {c = {b = {...}}}
			(gdb) p var.d.c
			$3 = {b = {a = 3}}
		用于替换嵌套结构的模式因语言而异，对于大多数语言使用 `{...}`，但 Fortran 使用 `(...)` 。

	show print max-depth
		显示当前嵌套结构被替换为省略号的阈值。

	set print memory-tag-violations
	set print memory-tag-violations on
		导致 gdb 在打印指针和地址时显示有关内存标记违规的附加信息。

	set print memory-tag-violations off
		停止打印内存标记违规信息。

	show print memory-tag-violations
		显示在打印指针和地址时是否显示内存标记违规信息。

	set print null-stop
		导致 gdb 在遇到第一个空字符时停止打印数组的字符。这在大型数组实际上只包含短字符串时很有用。默认是关闭的。

	show print null-stop
		显示 gdb 是否在第一个空字符处停止打印数组。

	set print pretty on
		导致 gdb 以缩进格式打印结构，每行一个成员，如下所示：
			$1 = {
				next = 0x0,
				flags = {
					sweet = 1,
					sour = 1
				},
				meat = 0x54 "Pork"
			}

	set print pretty off
		导致 gdb 以紧凑格式打印结构，如下所示：
			$1 = {next = 0x0, flags = {sweet = 1, sour = 1}, \
				meat = 0x54 "Pork"}
		这是默认格式。

	show print pretty
		显示 gdb 用于打印结构的格式。

	set print raw-values on
		以原始形式打印值，不应用值的漂亮打印器。

	set print raw-values off
		如果有漂亮打印器（请参见第 10.10 节[漂亮打印]，第 168 页），则以漂亮打印形式打印值，否则以原始形式打印值。
		默认设置是“off”。

	show print raw-values
		显示是否以原始形式打印值。

	set print sevenbit-strings on
		仅使用七位字符打印；如果设置此选项，gdb 使用 `\nnn` 表示法显示任何八位字符（在字符串或字符值中）。
		此设置在您使用英语（ascii）并且将字符的高位用作标记或“元”位时最佳。

	set print sevenbit-strings off
		打印完整的八位字符。这允许使用更多国际字符集，并且是默认值。

	show print sevenbit-strings
		显示 gdb 是否仅打印七位字符。

	set print union on
		告诉 gdb 打印包含在结构体和其他联合体中的联合体。这是默认设置。

	set print union off
		告诉 gdb 不打印包含在结构体和其他联合体中的联合体。gdb 将打印 `{...}` 代替。

	show print union
		询问 gdb 是否打印包含在结构体和其他联合体中的联合体。
		例如，给定以下声明
			typedef enum {Tree, Bug} Species;
			typedef enum {Big_tree, Acorn, Seedling} Tree_forms;
			typedef enum {Caterpillar, Cocoon, Butterfly} Bug_forms;
			struct thing {
				Species it;
				union {
					Tree_forms tree;
					Bug_forms bug;
				} form;
			};
			struct thing foo = {Tree, {Acorn}};
		在 `set print union on` 生效时，`p foo` 将打印
			$1 = {it = Tree, form = {tree = Acorn, bug = Cocoon}}
		在 `set print union off` 生效时，它将打印
			$1 = {it = Tree, form = {...}}
		`set print union` 影响类似 C 语言和 Pascal 编写的程序。
```

以下这些设置在调试 C++ 程序时很有用：

```
	set print demangle
	set print demangle on
		以源代码形式打印 C++ 名称，而不是以传递给汇编器和链接器进行类型安全链接的编码（“混淆”）形式。默认是开启的。

	show print demangle
		显示 C++ 名称是以混淆形式还是反混淆形式打印。

	set print asm-demangle
	set print asm-demangle on
		即使在汇编代码打印输出（如指令反汇编）中，也以源代码形式打印 C++ 名称，而不是混淆形式。默认是关闭的。

	show print asm-demangle
		显示汇编列表中的 C++ 名称是以混淆形式还是反混淆形式打印。

	set demangle-style style
		选择不同编译器用于表示 C++ 名称的几种编码方案。如果省略 `style`，您将看到可能格式的列表。默认值是 `auto`，这让 gdb 通过检查您的程序选择解码风格。

	show demangle-style
		显示当前用于解码 C++ 符号的编码风格。

	set print object
	set print object on
		当显示指向对象的指针时，使用虚函数表识别对象的实际（派生）类型，而不是声明的类型。请注意，需要虚函数表 - 此功能仅适用于具有运行时类型标识的对象；对象声明类型中的单个虚方法就足够了。请注意，通过 MI 处理变量对象时（请参见第 27 章[GDB/MI]，第 591 页），此设置也会被考虑。

	set print object off
		仅显示对象的声明类型，不参考虚函数表。这是默认设置。

	show print object
		显示是显示实际对象类型还是声明对象类型。

	set print static-members
	set print static-members on
		显示 C++ 对象时打印静态成员。默认是开启的。

	set print static-members off
		显示 C++ 对象时不打印静态成员。

	show print static-members
		显示是否打印 C++ 静态成员。

	set print pascal_static-members
	set print pascal_static-members on
		显示 Pascal 对象时打印静态成员。默认是开启的。

	set print pascal_static-members off
		显示 Pascal 对象时不打印静态成员。

	show print pascal_static-members
		显示是否打印 Pascal 静态成员。

	set print vtbl
	set print vtbl on
		漂亮打印 C++ 虚函数表。默认是关闭的。（`vtbl` 命令在使用 HP ANSI C++ 编译器（aCC）编译的程序上不起作用。）

	set print vtbl off
		不漂亮打印 C++ 虚函数表。

	show print vtbl
		显示是否漂亮打印 C++ 虚函数表。
```

## 10.10 漂亮打印

gdb 提供了一种使用 Python 代码对值进行漂亮打印的机制。它极大地简化了复杂对象的显示。此机制对 MI 和 CLI 都有效。

### 10.10.1 漂亮打印器介绍

当 gdb 打印一个值时，它首先查看是否为该值注册了漂亮打印器。如果有，那么 gdb 调用漂亮打印器来打印该值。否则，该值将正常打印。

漂亮打印器通常是有名称的。这使得它们易于管理。`info pretty-printer` 命令将列出所有已安装的带有名称的漂亮打印器。如果一个漂亮打印器可以处理多种数据类型，那么它的子打印器就是针对各个数据类型的打印器。每个这样的子打印器都有自己的名称。名称的格式是 `printer-name;subprinter-name` 。

漂亮打印器通过向 gdb 注册来安装。通常，当相应的调试信息被加载时，它们会自动加载并注册，因此无需执行任何特殊操作即可使用。

漂亮打印器可以在三个地方注册。

- 全局注册的漂亮打印器在调试所有下级进程时都可用。

- 与程序空间注册的漂亮打印器仅在调试该程序时可用。有关 Python 中的程序空间的更多详细信息，请参见第 23.3.2.26 节[Progspaces In Python]，第 474 页。

- 与目标文件注册的漂亮打印器将随相应的目标文件（例如，共享库）一起加载和卸载。有关 Python 中的目标文件的更多详细信息，请参见第 23.3.2.27 节[Objfiles In Python]，第 476 页。

有关如何选择漂亮打印器的更多信息，请参见第 23.3.2.7 节[Selecting Pretty-Printers]，第 426 页，

有关为新类型实现漂亮打印器的内容，请参见第 23.3.2.8 节[Writing a Pretty-Printer]，第 427 页。

### 10.10.2 漂亮打印器示例

这是没有漂亮打印器时 C++ `std::string` 的样子：

```
(gdb) print s
$1 = {
    static npos = 4294967295,
    _M_dataplus = {
        <std::allocator<char>> = {
            <__gnu_cxx::new_allocator<char>> = {
                <No data fields>
            }, <No data fields>
        },
        members of std::basic_string<char, std::char_traits<char>, std::allocator<char> >::_Alloc_hider:
            _M_p = 0x804a014 "abcd"
    }
}
```

有了 `std::string` 的漂亮打印器，只会打印内容：

```
(gdb) print s
$2 = "abcd"
```

### 10.10.3 漂亮打印器命令

```
info pretty-printer [object-regexp [name-regexp]]
	打印已安装的漂亮打印器列表。这包括被标记为禁用的漂亮打印器。
	`object-regexp` 是一个正则表达式，用于匹配要列出其漂亮打印器的对象。对象可以是全局的、程序空间的文件（请参见第 23.3.2.26 节[Progspaces In Python]，第 474 页）以及该程序空间内的目标文件（请参见第 23.3.2.27 节[Objfiles In Python]，第 476 页）。有关 gdb 如何从这三个对象中查找打印器的详细信息，请参见第 23.3.2.7 节[Selecting Pretty-Printers]，第 426 页。
	`name-regexp` 是一个正则表达式，用于匹配要列出的打印器的名称。

disable pretty-printer [object-regexp [name-regexp]]
	禁用与 `object-regexp` 和 `name-regexp` 匹配的漂亮打印器。禁用的漂亮打印器不会被遗忘，以后可以再次启用。

enable pretty-printer [object-regexp [name-regexp]]
	启用与 `object-regexp` 和 `name-regexp` 匹配的漂亮打印器。
```

示例：

假设我们安装了三个漂亮打印器：一个来自 `library1.so` 名为 `foo` 的，用于打印类型为 `foo` 的对象，另一个来自 `library2.so` 名为 `bar` 的，用于打印两种类型的对象 `bar1` 和 `bar2` 。

```
(gdb) info pretty-printer
library1.so:
    foo
library2.so:
    bar
    bar1
    bar2
(gdb) info pretty-printer library2
library2.so:
    bar
    bar1
    bar2
(gdb) disable pretty-printer library1
1 printer disabled
2 of 3 printers enabled
(gdb) info pretty-printer
library1.so:
    foo [disabled]
library2.so:
    bar
    bar1
    bar2
(gdb) disable pretty-printer library2 bar;bar1
1 printer disabled
1 of 3 printers enabled
(gdb) info pretty-printer library2
library2.so:
    bar
    bar1 [disabled]
    bar2
(gdb) disable pretty-printer library2 bar
1 printer disabled
0 of 3 printers enabled
(gdb) info pretty-printer
library1.so:
    foo [disabled]
library2.so:
    bar [disabled]
    bar1 [disabled]
    bar2
```

请注意，对于 `bar` ，整个打印器可以被禁用，每个单独的子打印器也可以被禁用。

默认情况下，使用启用的漂亮打印器打印值和帧参数。`print` 选项 `-raw-values` 和 gdb 设置 `set print raw-values`（请参见[set print raw-values]，第 165 页）可用于在不应用启用的漂亮打印器的情况下打印值。

类似地，回溯选项 `-raw-frame-arguments` 和 gdb 设置 `set print raw-frame-arguments`（请参见[set print raw-frame-arguments]，第 161 页）可用于在打印帧参数值时忽略启用的漂亮打印器。

## 10.11 值历史

`print` 命令打印的值会保存在 gdb 的值历史中。这允许您在其他表达式中引用它们。值会一直保存，直到重新读取或丢弃符号表（例如使用 `file` 或 `symbol-file` 命令）。当符号表发生变化时，值历史会被丢弃，因为这些值可能包含指向符号表中定义的类型的指针。

打印的值会被赋予历史编号，您可以通过这些编号来引用它们。这些是从 1 开始的连续整数。`print` 会在值之前打印 `$num = ` 来向您展示分配给值的历史编号；这里 `num` 是历史编号。

要引用任何以前的值，使用 `$` 后跟值的历史编号。`print` 标记其输出的方式旨在提醒您这一点。仅 `$` 引用历史中的最新值，`$$` 引用之前的值。`$$n` 引用从末尾数的第 `n` 个值；`$$2` 是 `$$` 之前的值，`$$1` 等同于 `$$`，`$$0` 等同于 `$` 。

例如，假设您刚刚打印了一个指向结构体的指针，并想要查看结构体的内容。只需键入

```
p *$
```

如果您有一个结构体链，其中组件 `next` 指向下一个结构体，您可以使用以下命令打印下一个结构体的内容：

```
p *$.next
```

您可以通过重复此命令来打印链中的连续链接 - 您可以通过仅键入回车键来完成。

请注意，历史记录的值，而不是表达式。如果 `x` 的值是 4 并且您键入这些命令：

```
print x
set x = 5
```

那么即使 `x` 的值已更改，`print` 命令在值历史中记录的值仍然是 4 。

```
	show values
		打印值历史中的最后十个值及其项目编号。这类似于 `p $$9` 重复十次，除了 `show values` 不会更改历史。

	show values n
		打印以历史项目编号 `n` 为中心的十个历史值。

	show values +
		打印上次打印的值之后的十个历史值。如果没有更多的值可用，`show values +` 不会产生显示。
```

按回车键重复 `show values n` 与 `show values +` 的效果完全相同。

## 10.12 便利变量

gdb 提供了便利变量，您可以在 gdb 中使用它们来保存值并在以后引用。这些变量完全存在于 gdb 中；它们不是您程序的一部分，设置便利变量对程序的进一步执行没有直接影响。这就是为什么您可以自由使用它们。

便利变量以 `$` 为前缀。任何以 `$` 开头的名称都可以用作便利变量，除非它是预定义的特定于机器的寄存器名称之一（请参见第 10.14 节[寄存器]，第 179 页）。（相比之下，值历史引用是前面带有 `$` 的数字。请参见第 10.11 节[值历史]，第 170 页。）

您可以使用赋值表达式将值保存到便利变量中，就像在程序中设置变量一样。例如：

```
set $foo = *object_ptr
```

这将把 `object_ptr` 所指向的对象中包含的值保存到 `$foo` 中。

首次使用便利变量时会创建它，但在您分配新值之前其值为空。您可以随时通过另一个赋值来更改其值。

便利变量没有固定类型。您可以为便利变量分配任何类型的值，包括结构体和数组，即使该变量已经具有不同类型的值。当用作表达式时，便利变量具有其当前值的类型。

```
show convenience
	打印迄今为止使用的便利变量及其值的列表，以及便利函数的列表。缩写为 `show conv` 。

init-if-undefined $variable = expression
	如果便利变量尚未设置，则设置它。这对于保持某些状态的用户定义命令很有用。在概念上，这类似于在 C 中使用带有初始化器的局部静态变量（除了便利变量是全局的）。它还可以用于允许用户覆盖命令脚本中使用的默认值。
	如果变量已经定义，则不会计算表达式，因此不会发生任何副作用。
```

使用便利变量的一种方法是作为要递增的计数器或要前进的指针。例如，要打印结构体数组中连续元素的字段：

```
set $i = 0
print bar[$i++]->contents
```

通过键入回车键重复该命令。

gdb 会自动创建一些便利变量并为其赋予可能有用的值。

```
	$_
		变量 `$_` 会由 `x` 命令自动设置为最后检查的地址（请参见第 10.6 节[检查内存]，第 152 页）。其他为 `x` 提供默认地址以供检查的命令也会将 `$_` 设置为该地址；这些命令包括 `info line` 和 `info breakpoint` 。`$_` 的类型是 `void *`，除非由 `x` 命令设置，在这种情况下，它是指向 `$__` 类型的指针。

	$__ 
		变量 `$__` 会由 `x` 命令自动设置为在最后检查的地址中找到的值。其类型选择与数据打印的格式相匹配。

	$_exitcode 
		当被调试的程序正常终止时，gdb 会自动将此变量设置为程序的退出代码，并将 `$_exitsignal` 重置为空。

	$_exitsignal
		当被调试的程序由于未捕获的信号而终止时，gdb 会自动将此变量设置为该信号的编号，并将 `$_exitcode` 重置为空。
		要区分被调试的程序是已退出（即 `$_exitcode` 不为空）还是已发出信号（即 `$_exitsignal` 不为空），可以使用便利函数 `$_isvoid`（请参见第 10.13 节[便利函数]，第 174 页）。
		例如，考虑以下源代码：
			#include <signal.h>
			int
			main (int argc, char *argv[])
			{
				raise (SIGALRM);
				return 0;
			}

		一种有效的判断被调试的程序是已退出还是已发出信号的方法是：

			(gdb) define has_exited_or_signalled
			Type commands for definition of ‘‘has_exited_or_signalled’’.
			End with a line saying just ‘‘end’’.
			>if $_isvoid ($_exitsignal)
			 >echo The program has exited\n
			 >else
			 >echo The program has signalled\n
			 >end
			>end
			(gdb) run
			Starting program:
			
			Program terminated with signal SIGALRM, Alarm clock.
			The program no longer exists.
			(gdb) has_exited_or_signalled
			The program has signalled

		可以看到，gdb 正确地告知被调试的程序已发出信号，因为它调用了 `raise` 并引发了 `SIGALRM` 信号。如果被调试的程序没有调用 `raise`，那么 gdb 将报告正常退出：

			(gdb) has_exited_or_signalled
			The program has exited

	$_exception
		变量 `$_exception` 在与异常相关的捕获点处被设置为正在抛出的异常对象。请参见第 5.1.3 节[设置捕获点]，第 69 页。

	$_ada_exception
		变量 `$_ada_exception` 在 Ada 与异常相关的捕获点处被设置为正在捕获或抛出的异常的地址。请参见第 5.1.3 节[设置捕获点]，第 69 页。

	$_probe_argc
		`$_probe_arg0...$_probe_arg11` 静态探测的参数。请参见第 5.1.10 节[静态探测点]，第 81 页。

	$_sdata
		变量 `$_sdata` 包含额外收集的静态跟踪点数据。请参见第 13.1.6 节[跟踪点操作列表]，第 208 页。请注意，如果没有检查跟踪缓冲区，或者没有收集额外的静态跟踪点数据，`$_sdata` 可能为空。

	$_siginfo
		变量 `$_siginfo` 包含额外的信号信息（请参见[额外信号信息]，第 92 页）。请注意，如果应用程序尚未收到任何信号，`$_siginfo` 可能为空。例如，在您执行 `run` 命令之前它将为空。

	$_tlb 
		当在本地模式下调试在 MS-Windows 上运行的应用程序或连接到支持 `qGetTIBAddr` 请求的 `gdbserver` 时，变量 `$_tlb` 会自动设置。请参见第 E.5 节[通用查询数据包]，第 791 页。此变量包含线程信息块的地址。

	$_inferior
		当前下级的编号。请参见第 4.9 节[调试多个下级连接和程序]，第 42 页。

	$_thread
		当前线程的线程编号。请参见[线程编号]，第 47 页。

	$_gthread
		当前线程的全局编号。请参见[全局线程编号]，第 48 页。

	$_inferior_thread_count
		当前下级中的活动线程数量。请参见第 4.10 节[线程]，第 47 页。

	$_gdb_major
	$_gdb_minor
		正在运行的 gdb 的主版本和次版本号。开发快照和预测试版本的次版本号会增加 1；因此，gdb 预测试 9.11.90 将为 `$_gdb_minor` 产生值 12 。这些变量允许您编写在不同版本的 gdb 上工作的脚本，而不会因某些版本中不可用的功能而导致错误。

	$_shell_exitcode
	$_shell_exitsignal
		gdb 命令（如 `shell` 和 `|`）会启动 shell 命令。当启动的命令终止时，gdb 会根据最后启动的命令的退出状态自动维护变量 `$_shell_exitcode` 和 `$_shell_exitsignal` 。这些变量的设置和使用方式与变量 `$_exitcode` 和 `$_exitsignal` 类似。
```

## 10.13 便利函数

gdb 还提供了一些便利函数。它们的语法类似于便利变量。便利函数可以像普通函数一样在表达式中使用；然而，便利函数是在 gdb 内部实现的。

这些函数不需要 gdb 配置有 Python 支持，这意味着它们始终可用。
```
	$_isvoid (expr)
		如果表达式 `expr` 为空，则返回 1 。否则返回 0 。
		空表达式是结果类型为 void 的表达式。例如，您可以检查一个便利变量（请参见第 10.12 节[便利变量]，第 171 页）以检查它是否为空：

			(gdb) print $_exitcode
			$1 = void
			(gdb) print $_isvoid ($_exitcode)
			$2 = 1
			(gdb) run
			Starting program:./a.out
			[Inferior 1 (process 29572) exited normally]
			(gdb) print $_exitcode
			$3 = 0
			(gdb) print $_isvoid ($_exitcode)
			$4 = 0

		在上面的示例中，我们在被调试程序执行之前和之后使用 `$_isvoid` 检查 `$_exitcode` 是否为空。在执行之前，没有要检查的退出代码，因此 `$_exitcode` 为空。执行后，被调试的程序返回 0 ，因此 `$_exitcode` 为 0 ，这意味着它不再为空。
		空表达式也可以是被调试程序中函数的调用。例如，给定以下函数：
			void
			foo (void)
			{
			}

		在 gdb 中调用它的结果为空：
			(gdb) print foo ()
			$1 = void
			(gdb) print $_isvoid (foo ())
			$2 = 1
			(gdb) set $v = foo ()
			(gdb) print $v
			$3 = void
			(gdb) print $_isvoid ($v)
			$4 = 1

	$_gdb_setting_str (setting)
		以字符串形式返回 gdb 设置的值。`setting` 是可以在 `set` 或 `show` 命令中使用的任何设置（请参见第 22 章[控制 GDB]，第 367 页）。
			(gdb) show print frame-arguments
			Printing of non-scalar frame arguments is "scalars".
			(gdb) p $_gdb_setting_str("print frame-arguments")
			$1 = "scalars"
			(gdb) p $_gdb_setting_str("height")
			$2 = "30"

	$_gdb_setting (setting)
		返回 gdb 设置的值。返回值的类型取决于设置。
		布尔型和自动布尔型设置的值类型为 `int` 。布尔值 `off` 和 `on` 分别转换为整数 0 和 1 。值 `auto` 转换为值 -1 。
		整数设置的值类型为 `unsigned int` 或 `int` ，具体取决于设置。
		一些整数设置接受 `unlimited` 值。根据设置，`set` 命令也接受值 0 或值 -1 作为 `unlimited` 的同义词。例如，`set height unlimited` 等同于 `set height 0` 。
		其他一些接受 `unlimited` 值的设置使用值 0 来表示字面上的零。例如，`set history size 0` 表示不在命令历史中记录任何 gdb 命令。对于此类设置，-1 是 `unlimited` 的同义词。
		有关与 `unlimited` 等效的数值，请参见相应 `set` 命令的文档。
		`$_gdb_setting` 函数根据 `set` 命令的使用方式将 `unlimited` 值转换为 0 或 -1 值。

			(gdb) p $_gdb_setting_str("height")
			$1 = "30"
			(gdb) p $_gdb_setting("height")
			$2 = 30
			(gdb) set height unlimited
			(gdb) p $_gdb_setting_str("height")
			$3 = "unlimited"
			(gdb) p $_gdb_setting("height")
			$4 = 0
			(gdb) p $_gdb_setting_str("history size")
			$5 = "unlimited"
			(gdb) p $_gdb_setting("history size")
			$6 = -1
			(gdb) p $_gdb_setting_str("disassemble-next-line")
			$7 = "auto"
			(gdb) p $_gdb_setting("disassemble-next-line")
			$8 = -1

		其他设置类型（枚举、文件名、可选文件名、字符串、无转义字符串）以字符串值返回。

	$_gdb_maint_setting_str (setting)
	  与 `$_gdb_setting_str` 函数类似，但适用于维护设置变量。

	$_gdb_maint_setting (setting)
	  与 `$_gdb_setting` 函数类似，但适用于维护设置变量。

	$_shell (command-string)
		调用一个 shell 来执行 `command-string` 。`command-string` 必须是一个字符串。
		shell 在主机（gdb 运行的机器）上运行。返回命令的退出状态。在 Unix 系统上，以零退出状态退出的命令成功，非零退出状态表示失败。当命令因致命信号（其编号为 `N` ）终止时，gdb 使用值 `128 + N` 作为退出状态，这在 Unix shell 中是标准的。请注意，`N` 是主机信号编号，而不是目标信号编号。如果您正在进行本地调试，它们将是相同的，但如果进行交叉调试，主机与目标信号编号可能完全无关。请查阅您的主机操作系统的文档，以了解主机信号编号和信号名称之间的映射。
		运行的 shell 以与 `shell` 命令相同的方式确定。请参见第 2.3 节[Shell 命令]，第 20 页。
			(gdb) print $_shell("true")
			$1 = 0
			(gdb) print $_shell("false")
			$2 = 1
			(gdb) p $_shell("echo hello")
			hello
			$3 = 0
			(gdb) p $_shell("foobar")
			bash: line 1: foobar: command not found
			$4 = 127

		这在断点条件中也可能有用。例如：
			(gdb) break function if $_shell("some command") == 0

		在这种情况下，您需要确保在断点条件中运行的 shell 命令花费的时间尽可能少。例如，避免运行可能无限阻塞或在退出前睡眠一段时间的命令。更喜欢一个分析某些状态并立即退出的命令或脚本。这很重要，因为被调试的程序每次都会因为断点而停止，然后 gdb 评估断点条件。如果条件为假，程序将透明地重新恢复，而不会通知您停止。因此，快速的 shell 命令可以避免不必要地显著减慢被调试的程序。
		注意：与 `shell` 命令不同，`$_shell` 便利函数不会影响 `$_shell_exitcode` 和 `$_shell_exitsignal` 便利变量。

	以下函数需要 gdb 配置有 Python 支持。

	$_memeq(buf1, buf2, length)
		如果 `buf1` 和 `buf2` 地址处的 `length` 字节相等，则返回 1 。否则返回 0 。

	$_regex(str, regex)
		如果字符串 `str` 匹配正则表达式 `regex` ，则返回 1 。否则返回 0 。正则表达式的语法由 Python 的正则表达式支持指定。

	$_streq(str1, str2)
		如果字符串 `str1` 和 `str2` 相等，则返回 1 。否则返回 0 。

	$_strlen(str)
		返回字符串 `str` 的长度。

	$_caller_is(name[, number_of_frames])
		如果调用函数的名称等于 `name` ，则返回 1 。否则返回 0 。
		如果提供了可选参数 `number_of_frames` ，则它是在栈中向上查找的帧数。默认值为 1 。
		
		示例：
			(gdb) backtrace
			#0 bottom_func ()
			   at testsuite/gdb.python/py-caller-is.c:21
			#1 0x00000000004005a0 in middle_func ()
			   at testsuite/gdb.python/py-caller-is.c:27
			#2 0x00000000004005ab in top_func ()
			   at testsuite/gdb.python/py-caller-is.c:33
			#3 0x00000000004005b6 in main ()
			   at testsuite/gdb.python/py-caller-is.c:39
			(gdb) print $_caller_is ("middle_func")
			$1 = 1
			(gdb) print $_caller_is ("top_func", 2)
			$1 = 1

	$_caller_matches(regexp[, number_of_frames])
		如果调用函数的名称匹配正则表达式 `regexp` ，则返回 1 。否则返回 0 。
		如果提供了可选参数 `number_of_frames` ，则它是在栈中向上查找的帧数。默认值为 1 。

	$_any_caller_is(name[, number_of_frames])
		如果任何调用函数的名称等于 `name` ，则返回 1 。否则返回 0 。
		如果提供了可选参数 `number_of_frames` ，则它是在栈中向上查找的帧数。默认值为 1 。
		此函数与 `$_caller_is` 的不同之处在于，此函数检查从直接调用者到由 `number_of_frames` 指定的帧的所有栈帧，而 `$_caller_is` 仅检查由 `number_of_frames` 指定的帧。

	$_any_caller_matches(regexp[, number_of_frames])
		如果任何调用函数的名称匹配正则表达式 `regexp` ，则返回 1 。否则返回 0 。
		如果提供了可选参数 `number_of_frames` ，则它是在栈中向上查找的帧数。默认值为 1 。
		此函数与 `$_caller_matches` 的不同之处在于，此函数检查从直接调用者到由 `number_of_frames` 指定的帧的所有栈帧，而 `$_caller_matches` 仅检查由 `number_of_frames` 指定的帧。

	$_as_string(value)
		此便利函数已被弃用，可能会在未来版本的 gdb 中删除。请使用 `%V` 格式说明符代替（请参见[`%V` 格式说明符]，第 398 页）。
		返回 `value` 的字符串表示。
		此函数对于获取枚举值的文本标签（枚举器）很有用。例如，假设变量 `node` 是枚举类型：
			(gdb) printf "Visiting node of type %s\n", $_as_string(node)
			Visiting node of type NODE_INTEGER

	$_cimag(value)
	$_creal(value)
		返回复数 `value` 的虚部（`$_cimag`）或实部（`$_creal`）。
		虚部或实部的类型取决于复数的类型，例如，在浮点数复数上使用 `$_cimag` 将返回浮点数类型的虚部。

	gdb 提供了列出和获取便利函数帮助的功能。

	help function
		打印所有便利函数的列表。
```

## 10.14 寄存器

在表达式中，您可以将机器寄存器的内容作为以 `$` 开头的变量来引用。寄存器的名称因机器而异；使用 `info registers` 查看您的机器上使用的名称。

```
	info registers
		打印除浮点和向量寄存器外的所有寄存器的名称和值（在选定的栈帧中）。

	info all-registers
		打印包括浮点和向量寄存器在内的所有寄存器的名称和值（在选定的栈帧中）。

	info registers reggroup ...
		打印每个指定 `reggroup` 中的寄存器的名称和值。
		`reggroup` 可以是 `maint print reggroups` 返回的任何一个（请参见附录 D [维护命令]，第 757 页）。

	info registers regname ...
		打印每个指定寄存器 `regname` 的相对值。如下所述，寄存器值通常相对于选定的栈帧。
		`regname` 可以是您正在使用的机器上有效的任何寄存器名称，带或不带初始的 `$` 。
	  
```
gdb 在大多数机器上都有四个“标准”寄存器名称（在表达式中可用）——只要它们与架构的寄存器规范助记符不冲突。寄存器名称 `$pc` 和 `$sp` 分别用于程序计数器寄存器和栈指针。`$fp` 用于包含指向当前栈帧的指针的寄存器，`$ps` 用于包含处理器状态的寄存器。例如，您可以用以下方式以十六进制打印程序计数器：

```
p/x $pc
```

或者打印下一条要执行的指令：

```
x/i $pc
```

或者将栈指针加 4 ：

```
set $sp += 4
```

只要可能，这四个标准寄存器名称在您的机器上都是可用的，即使机器有不同的规范助记符，只要没有冲突。`info registers` 命令显示规范名称。例如，在 SPARC 上，`info registers` 显示处理器状态寄存器为 `$psr` ，但您也可以将其称为 `$ps` ；在基于 x86 的机器上，`$ps` 是 `eflags` 寄存器的别名。

当以这种方式检查寄存器时，gdb 始终将普通寄存器的内容视为整数。有些机器有特殊的寄存器，它们只能保存浮点数；这些寄存器被认为具有浮点值。没有办法将普通寄存器的内容作为浮点值引用（尽管您可以使用 `print/f $regname` 将其作为浮点值打印）。

某些寄存器具有不同的“原始”和“虚拟”数据格式。这意味着操作系统保存寄存器内容的数据格式与您的程序通常看到的格式不同。例如，68881 浮点协处理器的寄存器总是以“扩展”（原始）格式保存，但所有 C 程序都期望使用“双精度”（虚拟）格式。在这种情况下，gdb 通常仅使用虚拟格式（对您的程序有意义的格式），但 `info registers` 命令会以两种格式打印数据。

有些机器有特殊的寄存器，其内容可以有几种不同的解释方式。例如，现代基于 x86 的机器有 SSE 和 MMX 寄存器，可以以几种不同的格式将多个值打包在一起。gdb 以结构体符号来引用此类寄存器：

```
(gdb) print $xmm1
$1 = {
    v4_float = {0, 3.43859137e-038, 1.54142831e-044, 1.821688e-044},
    v2_double = {9.92129282474342e-303, 2.7585945287983262e-313},
    v16_int8 = "\000\000\000\000\3706;\001\v\000\000\000\r\000\000",
    v8_int16 = {0, 0, 14072, 315, 11, 0, 13, 0},
    v4_int32 = {0, 20657912, 11, 13},
    v2_int64 = {88725056443645952, 55834574859},
    uint128 = 0x0000000d0000000b013b36f800000000
}
```

要设置此类寄存器的值，您需要告诉 gdb 您希望更改寄存器的哪个视图，就好像您正在为结构体成员赋值一样：

```
(gdb) set $xmm1.uint128 = 0x000000000000000000000000FFFFFFFF
```

通常，寄存器值相对于选定的栈帧（请参见第 8.3 节[选择帧]，第 117 页）。这意味着您获得的是如果所有更深入的栈帧都退出并恢复其保存的寄存器时该寄存器将包含的值。为了查看硬件寄存器的真实内容，您必须选择最内层的帧（使用 `frame 0` ）。

通常，ABI 会保留一些寄存器，不需要被被调用者保存（也称为：“调用者保存”、“调用破坏”或“易变”寄存器）。因此，对于 gdb 来说，可能无法知道调用之前（换句话说，在外层帧中）寄存器的值，如果该寄存器的值此后已被被调用者更改。gdb 尝试从调试信息、展开信息或编译器生成的机器代码中推断内层帧保存（“被调用者保存”）的寄存器。如果某些寄存器未被保存，并且 gdb 知道该寄存器是“调用者保存”（通过其自身对 ABI 的了解，或者因为调试/展开信息明确表示寄存器的值未定义），gdb 将显示 `<not saved>` 作为寄存器的值。对于 gdb 不了解寄存器保存约定的目标，如果被调用者未保存寄存器，则其在外层帧中的值和位置假定与内层帧相同。这通常是无害的，因为如果寄存器是调用破坏的，调用者要么不关心调用后寄存器中的内容，要么有代码来恢复它关心的值。但是请注意，如果您在外层帧中更改这样的寄存器，您可能也会影响内层帧。此外，您查看的帧越“外”，调用破坏寄存器的值就越有可能是错误的，因为它实际上并不代表调用前寄存器的值。

## 10.15 浮点硬件

根据配置，gdb 可能能够为您提供有关浮点硬件状态的更多信息。
```
	info float
		显示与硬件相关的浮点单元信息。确切的内容和布局因浮点芯片而异。目前，`info float` 在 ARM 和 x86 机器上受支持。
```
## 10.16 向量单元

根据配置，gdb 可能能够为您提供有关向量单元状态的更多信息。
```
	info vector
		显示有关向量单元的信息。确切的内容和布局因硬件而异。
```
## 10.17 操作系统辅助信息

gdb 提供了对有用的操作系统设施的接口，可以帮助您调试程序。

某些操作系统在启动时为程序提供一个辅助向量。这类似于您为程序指定的参数和环境，但包含系统依赖的各种二进制值，这些值告诉系统库有关硬件、操作系统和进程的重要细节。每个值的目的由一个整数标签标识；含义是众所周知的，但系统特定。根据配置和操作系统设施，gdb 可能能够向您显示此信息。对于远程目标，此功能可能还取决于远程存根对 `qXfer:auxv:read` 数据包的支持，请参见[qXfer 辅助向量读取]，第 812 页。

```
	info auxv
		显示下级（可以是活动进程或核心转储文件）的辅助向量。gdb 以数字形式打印每个标签值，并显示已识别标签的名称和文本描述。向量中的一些值是数字，一些是位掩码，还有一些是指向字符串或其他数据的指针。对于已识别的标签，gdb 以最合适的形式显示每个值，对于未识别的标签，以十六进制显示。
```

在某些目标上，gdb 可以访问特定于操作系统的信息并向您显示。可用的信息类型将取决于目标上运行的操作系统的类型。获取数据的机制在附录 H [操作系统信息]，第 881 页中描述。对于远程目标，此功能取决于远程存根对 `qXfer:osdata:read` 数据包的支持，请参见[qXfer osdata 读取]，第 816 页。
```
	info os infotype
		显示请求类型的操作系统信息。
		在 gnu/Linux 上，`infotype` 的以下值是有效的：
			cpus
				显示所有 CPU/核心的列表。对于每个 CPU/核心，gdb 打印 `/proc/cpuinfo` 中的可用字段。对于每个支持的架构，不同的字段是可用的。两个常见的条目是 `processor`（给出 CPU 编号）和 `bogomips`（在内核初始化期间计算的系统常量）。

			files
				显示目标上打开的文件描述符列表。对于每个文件描述符，gdb 打印拥有该描述符的进程的标识符、拥有进程的命令、描述符的值和描述符的目标。

			modules
				显示目标上加载的所有内核模块的列表。对于每个模块，gdb 打印模块名称、模块的字节大小、模块的使用次数、模块的依赖项、模块的状态和加载的模块在内存中的地址。

			msg
				显示目标上所有 System V 消息队列的列表。对于每个消息队列，gdb 打印消息队列键、消息队列标识符、访问权限、队列上的当前字节数、队列上的当前消息数、最后在队列上发送和接收消息的进程、消息队列的所有者和创建者的用户和组、最后发送和接收消息的时间以及消息队列最后更改的时间。

			processes
				显示目标上的进程列表。对于每个进程，gdb 打印进程标识符、用户的名称、与进程对应的命令以及进程当前正在运行的处理器核心列表。（要理解这些属性的含义，对于此和以下的信息类型，请查阅一般的 gnu/Linux 文档。）

			procgroups
				显示目标上的进程组列表。对于每个进程，gdb 打印它所属的进程组的标识符、进程组领导者对应的命令、进程标识符和进程的命令行。列表首先按进程组标识符排序，然后按进程标识符排序，以便属于同一进程组的进程分组在一起，并且进程组领导者首先列出。

			semaphores
				显示目标上的所有 System V 信号量集的列表。对于每个信号量集，gdb 打印信号量集键、信号量集标识符、访问权限、集合中的信号量数量、信号量集的所有者和创建者的用户和组以及对信号量集进行操作和更改的时间。

			shm
				显示目标上的所有 System V 共享内存区域的列表。对于每个共享内存区域，gdb 打印区域键、共享内存标识符、访问权限、区域的大小、创建区域的进程、最后附加到或从区域分离的进程、当前对区域的活动附加数以及最后附加、分离和更改区域的时间。

			sockets
				显示目标上的 Internet 域套接字列表。对于每个套接字，gdb 打印本地和远程端点的地址和端口、连接的当前状态、套接字的创建者、套接字的 IP 地址族和连接的类型。

			threads
				显示目标上运行的线程列表。对于每个线程，gdb 打印线程所属的进程的标识符、进程的命令、线程标识符和它当前正在运行的处理器核心。进程的主线程未列出。

	info os
		如果省略 `infotype`，则列出 `infotype` 的可能值以及每个 `infotype` 可用的操作系统信息类型。如果目标未返回可能类型的列表，此命令将报告错误。
```

## 10.18 内存区域属性

内存区域属性允许您描述目标内存区域所需的特殊处理。gdb 使用属性来确定是否允许某些类型的内存访问；是否使用特定宽度的访问；以及是否缓存目标内存。默认情况下，内存区域的描述是从目标获取的（如果当前目标支持），但用户可以覆盖获取的区域。

定义的内存区域可以单独启用和禁用。当内存区域被禁用时，gdb 在访问该区域的内存时使用默认属性。同样，如果未定义内存区域，gdb 在访问所有内存时使用默认属性。

定义内存区域时，会为其分配一个数字以进行标识；要启用、禁用或删除内存区域，您需要指定该数字。
```
	mem lower upper attributes ...
		定义一个由 `lower` 和 `upper` 界定的具有 `attributes...` 属性的内存区域，并将其添加到 gdb 监视的区域列表中。请注意，`upper == 0` 是一种特殊情况：它被视为目标的最大内存地址。（在 16 位目标上为 `0xffff`，在 32 位目标上为 `0xffffffff` 等）

	mem auto
		丢弃对内存区域的任何用户更改，并使用目标提供的区域（如果可用），或者如果目标不支持则不使用任何区域。

	delete mem nums ...
		从 gdb 监视的区域列表中删除内存区域 `nums ...` 。

	disable mem nums ...
		禁用对内存区域 `nums ...` 的监视。禁用的内存区域不会被遗忘。以后可以再次启用。

	enable mem nums ...
		启用对内存区域 `nums ...` 的监视。

	info mem
		打印所有定义的内存区域的表，每个区域具有以下列：
			- 内存区域编号(Memory Region Number)
			- 启用或禁用(Enabled or Disabled)    启用的内存区域标记为 `y` 。禁用的内存区域标记为 `n` 。
			- 低地址(Lo Address)                定义内存区域包含下限的地址。
			- 高地址(Hi Address)                定义内存区域排他上限的地址。
			- 属性(Attributes)                  为此内存区域设置的属性列表。
```

### 10.18.1 属性
#### 10.18.1.1 内存访问模式
访问模式属性设置 gdb 是否可以对内存区域进行读或写访问。

虽然这些属性阻止 gdb 执行无效的内存访问，但它们无法阻止目标系统、I/O DMA 等访问内存。

- `ro`：内存为只读。

- `wo`：内存为只写。

- `rw`：内存为读写。这是默认值。

#### 10.18.1.2 内存访问大小
访问大小属性告诉 gdb 在内存区域中使用特定大小的访问。通常，内存映射设备寄存器需要特定大小的访问。如果未指定访问大小属性，gdb 可以使用任何大小的访问。

- `8`：使用 8 位内存访问。

- `16`：使用 16 位内存访问。

- `32`：使用 32 位内存访问。

- `64`：使用 64 位内存访问。

#### 10.18.1.3 数据缓存
数据缓存属性设置 gdb 是否将缓存目标内存。虽然这通常通过减少调试协议开销来提高性能，但它可能会导致不正确的结果，因为 gdb 不知道易失性变量或内存映射设备寄存器。

- `cache`：启用 gdb 缓存目标内存。

- `nocache`：禁用 gdb 缓存目标内存。这是默认值。

### 10.18.2 内存访问检查
gdb 可以被指示拒绝访问未明确描述的内存。如果访问此类区域对特定目标有不良影响，或者为了提供更好的错误检查，这可能很有用。以下命令控制此行为。

`set mem inaccessible-by-default [on|off]`

如果指定 `on`，使 gdb 将未由内存范围明确描述的内存视为不存在，并拒绝对此类内存的访问。只有在定义了至少一个内存范围时才执行检查。如果指定 `off`，使 gdb 将未由内存范围明确描述的内存视为 RAM。默认值为 `on` 。

`show mem inaccessible-by-default`

显示对未知内存访问的当前处理方式。

## 10.19 内存和文件之间的复制
您可以使用 `dump`、`append` 和 `restore` 命令在目标内存和文件之间复制数据。`dump` 和 `append` 命令将数据写入文件，`restore` 命令将文件中的数据读回下级的内存。文件可以是二进制、Motorola S 记录、Intel 十六进制、Tektronix 十六进制或 Verilog 十六进制格式；然而，gdb 只能向二进制文件追加，并且不能从 Verilog 十六进制文件读取。
```
	dump [format] memory filename start_addr end_addr
	dump [format] value filename expr
		以给定的格式将从 `start_addr` 到 `end_addr` 的内存内容或 `expr` 的值转储到 `filename` 。
		格式参数可以是以下任何一种：
			binary    原始二进制形式。
			ihex      Intel 十六进制格式。
			srec      Motorola S 记录格式。
			tekhex    Tektronix 十六进制格式。
			verilog   Verilog 十六进制格式。
		gdb 使用与 `gnu` 二进制实用程序（如 `objdump` 和 `objcopy`）相同的这些格式的定义。如果省略格式，gdb 以原始二进制形式转储数据。

	append [binary] memory filename start_addr end_addr
	append [binary] value filename expr
		以原始二进制形式将从 `start_addr` 到 `end_addr` 的内存内容或 `expr` 的值附加到文件 `filename` 。（gdb 只能以原始二进制形式向文件追加数据。）

	restore filename [binary] bias start end
		将文件 `filename` 的内容恢复到内存中。`restore` 命令可以自动识别任何已知的 `bfd` 文件格式，除了原始二进制。要恢复原始二进制文件，您必须在文件名后指定可选关键字 `binary` 。
		如果 `bias` 非零，其值将添加到文件中包含的地址。二进制文件始终从地址 0 开始，因此它们将在地址 `bias` 处恢复。其他 `bfd` 文件具有内置位置；它们将在该位置偏移 `bias` 处恢复。
		如果 `start` 和/或 `end` 非零，则仅恢复文件偏移量在 `start` 和 `end` 之间的数据。这些偏移量是相对于文件中的地址，在应用 `bias` 参数之前。
```

## 10.20 如何从您的程序生成核心文件
核心文件或核心转储是一个文件，它记录了运行进程的内存映像及其进程状态（寄存器值等）。它的主要用途是对在调试器之外运行时崩溃的程序进行事后调试。程序崩溃时会自动生成核心文件，除非用户禁用此功能。有关在事后调试模式下调用 gdb 的信息，请参见第 18.1 节[文件]，第 291 页。

有时，您可能希望为正在调试的程序生成核心文件，以保留其状态的快照。gdb 为此有一个特殊命令。
```
	generate-core-file [file]
	gcore [file]
		生成下级进程的核心转储。可选参数 `file` 指定放置核心转储的文件名。如果未指定，文件名默认为 `core.pid`，其中 `pid` 是下级进程 ID。
		如果写入核心的文件系统支持，gdb 会生成一个稀疏核心转储文件。
		请注意，此命令仅在某些系统上实现（截至本文撰写时，gnu/Linux、FreeBSD、Solaris 和 S390）。
		在 gnu/Linux 上，生成核心转储时，此命令可以考虑 `/proc/pid/coredump_filter` 的值（请参见[set use-coredump-filter]，第 186 页），并且默认情况下尊重 `/proc/pid/smaps` 中存在的 `VM_DONTDUMP` 标志（请参见[set dump-excluded-mappings]，第 187 页）。

	set use-coredump-filter on
	set use-coredump-filter off
		在生成核心转储文件时启用或禁用使用 `/proc/pid/coredump_filter` 文件。此文件由 Linux 内核用于决定在生成核心转储文件时将转储或忽略哪些类型的内存映射。`pid` 是当前正在运行的进程的进程 ID。
		要使用此功能，您必须在 `/proc/pid/coredump_filter` 文件中以十六进制写入一个值，该值是一个位掩码，表示内存映射类型。如果位掩码中的某位被设置，则对应类型的内存映射将被转储；否则，它们将被忽略。此配置由子进程继承。有关 `/proc/pid/coredump_filter` 文件中可以设置的位的更多信息，请参阅 `core(5)` 的手册页。
		默认情况下，此选项为开启。如果此选项关闭，gdb 不会读取 `coredump_filter` 文件，而是使用与 Linux 内核相同的默认值来决定核心转储文件中要转储哪些页面。此值当前为 `0x33`，这意味着位 0（匿名私有映射）、1（匿名共享映射）、4（ELF 头）和 5（私有大页面）是活动的。这将导致这些内存映射自动转储。

	set dump-excluded-mappings on
	set dump-excluded-mappings off
		如果指定为 `on`，gdb 将转储标记有 `VM_DONTDUMP` 标志的内存映射。此标志在 `/proc/pid/smaps` 文件中以缩写 `dd` 表示。
		默认值为 `off`。
```

## 10.21 字符集

如果您正在调试的程序使用与 gdb 本身不同的字符集来表示字符和字符串，gdb 可以为您在字符集之间自动进行转换。gdb 所使用的字符集我们称为主机字符集；下级程序所使用的字符集我们称为目标字符集。

例如，如果您在使用 ISO Latin 1 字符集的 gnu/Linux 系统上运行 gdb，但您使用 gdb 的远程协议（请参见第 20 章[远程调试]，第 315 页）来调试在使用 EBCDIC 字符集的 IBM 大型机上运行的程序，那么主机字符集是 Latin-1，目标字符集是 EBCDIC。

如果您给 gdb 命令 `set target-charset EBCDIC-US` ，那么在打印字符或字符串值或在表达式中使用字符和字符串字面量时，gdb 会在 EBCDIC 和 Latin 1 之间进行转换。

gdb 没有办法自动识别下级程序使用的字符集；您必须使用下面描述的 `set target-charset` 命令告诉它。

以下是控制 gdb 字符集支持的命令：
```
set target-charset charset
	将当前目标字符集设置为 `charset` 。要显示支持的目标字符集列表，请键入 `set target-charset TABTAB` 。

set host-charset charset
	将当前主机字符集设置为 `charset` 。
	默认情况下，gdb 使用适合其运行系统的主机字符集；您可以使用 `set host-charset` 命令覆盖该默认值。
	在某些系统上，gdb 无法自动确定适当的主机字符集。在这种情况下，gdb 使用 `UTF-8` 。
	gdb 只能使用某些字符集作为其主机字符集。如果您键入 `set host-charset TABTAB` ，gdb 将列出它支持的主机字符集。

set charset charset
	将当前主机和目标字符集设置为 `charset` 。如上所述，如果您键入 `set charset TABTAB` ，gdb 将列出可用于主机和目标的字符集的名称。

show charset
	显示当前主机和目标字符集的名称。

show host-charset
	显示当前主机字符集的名称。

show target-charset
	显示当前目标字符集的名称。

set target-wide-charset charset
	将当前目标的宽字符集设置为 `charset` 。这是目标的 `wchar_t` 类型使用的字符集。要显示支持的宽字符集列表，请键入 `set target-wide-charset TABTAB` 。

show target-wide-charset
	显示当前目标的宽字符集的名称。
```

以下是 gdb 字符集支持的实际示例。假设以下源代码已放置在文件 `charset-test.c` 中：

```c
#include <stdio.h>
char ascii_hello[]
= {72, 101, 108, 108, 111, 44, 32, 119,
   111, 114, 108, 100, 33, 10, 0};
char ibm1047_hello[]
= {200, 133, 147, 147, 150, 107, 64, 166,
   150, 153, 147, 132, 90, 37, 0};

main ()
{
    printf ("Hello, world!\n");
}
```

在这个程序中，`ascii_hello` 和 `ibm1047_hello` 是包含字符串 `Hello, world!` 后跟换行符的数组，分别以 ASCII 和 IBM1047 字符集编码。

我们编译程序，并在其上调用调试器：

```
$ gcc -g charset-test.c -o charset-test
$ gdb -nw charset-test
GNU gdb 2001-12-19-cvs
Copyright 2001 Free Software Foundation, Inc.
...
(gdb)
```

我们可以使用 `show charset` 命令查看 gdb 当前用于解释和显示字符和字符串的字符集：

```
(gdb) show charset
The current host and target character set is ‘ISO-8859-1’.
(gdb)
```

为了打印本手册，让我们使用 ASCII 作为我们的初始字符集：

```
(gdb) set charset ASCII
(gdb) show charset
The current host and target character set is ‘ASCII’.
(gdb)
```

让我们假设 ASCII 确实是我们主机系统的正确字符集 - 换句话说，假设如果 gdb 使用 ASCII 字符集打印字符，我们的终端将正确显示它们。由于我们当前的目标字符集也是 ASCII，`ascii_hello` 的内容打印清晰：

```
(gdb) print ascii_hello
$1 = 0x401698 "Hello, world!\n"
(gdb) print ascii_hello[0]
$2 = 72 ’H’
(gdb)
```

gdb 对您在表达式中使用的字符和字符串字面量使用目标字符集：

```
(gdb) print ’+’
$3 = 43 ’+’
(gdb)
```

ASCII 字符集使用数字 43 来编码 `+` 字符。

gdb 依赖用户告诉它目标程序使用的字符集。如果我们在目标字符集仍然是 ASCII 时打印 `ibm1047_hello` ，我们会得到乱码：

```
(gdb) print ibm1047_hello
$4 = 0x4016a8 "\310\205\223\223\226k@\246\226\231\223\204Z%"
(gdb) print ibm1047_hello[0]
$5 = 200 ’\310’
(gdb)
```

如果我们调用 `set target-charset` 后跟 `TABTAB` ，gdb 会告诉我们它支持的字符集：

```
(gdb) set target-charset
ASCII  EBCDIC-US  IBM1047  ISO-8859-1
(gdb) set target-charset
```

我们可以选择 IBM1047 作为我们的目标字符集，并再次检查程序的字符串。现在 ASCII 字符串是错误的，但 gdb 将 `ibm1047_hello` 的内容从目标字符集（IBM1047）转换为主机字符集（ASCII），并且它们显示正确：

```
(gdb) set target-charset IBM1047
(gdb) show charset
The current host character set is ‘ASCII’.
The current target character set is ‘IBM1047’.
(gdb) print ascii_hello
$6 = 0x401698 "\110\145%%?\054\040\167?\162%\144\041\012"
(gdb) print ascii_hello[0]
$7 = 72 ’\110’
(gdb) print ibm1047_hello
$8 = 0x4016a8 "Hello, world!\n"
(gdb) print ibm1047_hello[0]
$9 = 200 ’H’
(gdb)
```

如上所述，gdb 对您在表达式中使用的字符和字符串字面量使用目标字符集：

```
(gdb) print ’+’
$10 = 78 ’+’
(gdb)
```

IBM1047 字符集使用数字 78 来编码 `+` 字符。

## 10.22 目标数据缓存

gdb 会缓存调试器和目标之间交换的数据。每个缓存都与下级的地址空间相关联。有关下级和地址空间，请参见第 4.9 节[下级连接和程序]，第 42 页。这种缓存通常会提高远程调试的性能（请参见第 20 章[远程调试]，第 315 页），因为它通过将内存读和写捆绑到大块中来减少远程协议的开销。

不幸的是，简单地缓存所有内容会导致不正确的结果，因为 gdb 不一定知道任何关于易失性值、内存映射的 I/O 地址等的信息。此外，在非停止模式（请参见第 5.5.2 节[非停止模式]，第 94 页）中，在 gdb 命令执行时内存可能会被更改。因此，默认情况下，gdb 仅缓存已知在堆栈上或在代码段中的数据。其他内存区域可以显式标记为可缓存；请参见第 10.18 节[内存区域属性]，第 183 页。
```
	set remotecache on
	set remotecache off
		此选项不再起作用；它的存在是为了与旧脚本兼容。

	show remotecache
		显示已过时的 `remotecache` 标志的当前状态。

	set stack-cache on
	set stack-cache off
		启用或禁用堆栈访问的缓存。启用时，使用缓存。默认情况下，此选项处于启用状态。

	show stack-cache
		显示内存访问数据缓存的当前状态。

	set code-cache on
	set code-cache off
		启用或禁用代码段访问的缓存。启用时，使用缓存。默认情况下，此选项处于启用状态。这提高了远程调试中的反汇编性能。

	show code-cache
		显示目标内存中代码段访问缓存的当前状态。

	info dcache [line]
		打印有关当前下级地址空间数据缓存性能的信息。显示的信息包括 `dcache` 的宽度和深度，以及对于每个缓存行，其编号、地址和被引用的次数。此命令对于调试数据缓存操作很有用。
		如果指定了行号，则将以十六进制打印该行的内容。

	set dcache size size
		设置 `dcache` 中的最大条目数（上面的 `dcache` 深度）。

	set dcache line-size line-size
		设置每个 `dcache` 条目缓存的字节数（上面的 `dcache` 宽度）。必须是 2 的幂。

	show dcache size
		显示 `dcache` 条目的最大数量。请参见第 10.22 节[缓存目标数据]，第 190 页。

	show dcache line-size
		显示 `dcache` 行的默认大小。

	maint flush dcache
		刷新（如果有）`dcache` 的内容。此维护者命令在调试 `dcache` 实现时很有用。
```

## 10.23 搜索内存

可以使用 `find` 命令在内存中搜索特定的字节序列。
```
find [/sn] start_addr, +len, val1 [, val2, ...]
find [/sn] start_addr, end_addr, val1 [, val2, ...]
	在内存中搜索由 `val1`、`val2` 等指定的字节序列。搜索从地址 `start_addr` 开始，并持续 `len` 字节或直到包括 `end_addr` 。
	`s` 和 `n` 是可选参数。它们可以以任意顺序单独或一起指定。

		s，搜索查询大小
			每个搜索查询值的大小。
				b    字节
				h    半字（两个字节）
				w    字（四个字节）
				g    巨型字（八个字节）
			所有值都按照当前语言进行解释。这意味着，例如，如果当前源语言是 C/C++，则搜索字符串“hello”包括尾随的 `\0` 。可以通过使用强制类型转换（例如：`{char[5]}"hello"`）从搜索中删除空终止符。
			如果未指定值的大小，则从当前语言中的值的类型中获取。这在将搜索模式指定为类型混合时很有用。请注意，这意味着，例如，在类似 C 的语言中，搜索未类型化的 `0x42` 将搜索 `(int) 0x42`，通常为四个字节。

		n，最大查找数量
			要打印的最大匹配数量。默认情况下，打印所有查找结果。
```
您可以使用字符串作为搜索值。使用双引号（`"`）将它们引起来。字符串值将逐字节复制到搜索模式中，而不管目标的字节序和大小规范如何。

找到的每个匹配的地址以及找到的匹配数量都会被打印。

找到的最后一个值的地址存储在便利变量 `$_` 中。匹配的数量存储在 `$numfound` 中。

例如，如果在这个函数的 `printf` 处停止调试：

```c
void
hello ()
{
    static char hello[] = "hello-hello";
    static struct { char c; short s; int i; }
		__attribute__ ((packed)) mixed
		= { ’c’, 0x1234, 0x87654321 };
	printf ("%s\n", hello);
}
```

您在调试期间会得到：

```
(gdb) find &hello[0], +sizeof(hello), "hello"
0x804956d <hello.1620+6>
1 pattern found
(gdb) find &hello[0], +sizeof(hello), ’h’, ’e’, ’l’, ’l’, ’o’
0x8049567 <hello.1620>
0x804956d <hello.1620+6>
2 patterns found.
(gdb) find &hello[0], +sizeof(hello), {char[5]}"hello"
0x8049567 <hello.1620>
0x804956d <hello.1620+6>
2 patterns found.
(gdb) find /b1 &hello[0], +sizeof(hello), ’h’, 0x65, ’l’
0x8049567 <hello.1620>
1 pattern found
(gdb) find &mixed, +sizeof(mixed), (char) ’c’, (short) 0x1234, (int) 0x87654321
0x8049560 <mixed.1625>
1 pattern found
(gdb) print $numfound
$1 = 1
(gdb) print $_
$2 = (void *) 0x8049560
```

## 10.24 值大小

每当 gdb 打印一个值时，都会在 gdb 内部分配内存来保存该值的内容。在某些具有动态类型系统的语言中，一个无效的程序可能会指示一个过大的值，这可能会导致 gdb 尝试分配过多的内存。
```
	set max-value-size bytes
	set max-value-size unlimited
		将 gdb 为值的内容分配的最大内存大小设置为 `bytes`，尝试显示需要超过该内存的值将导致错误。
		设置此变量不会影响 gdb 中已经分配的值，只会影响未来的分配。
		为了使 gdb 能够正常运行，`max-value-size` 可以设置的最小大小是存在的，目前是 16 字节。
		该限制适用于某些子表达式的结果以及完整表达式。例如，如果 `x.y` 的大小是动态的并且超过 `bytes`，则表示简单整数组件的表达式（例如 `x.y.z`）可能会失败。另一方面，gdb 有时很聪明；表达式 `A[i]`，其中 `A` 是具有非恒定大小的数组变量，只要组件大小小于 `bytes`，通常都会成功，无论 `A` 的边界如何。
		`max-value-size` 的默认值目前是 64k 。

	show max-value-size
		显示 gdb 为值的内容分配的最大内存大小（以字节为单位）。
```