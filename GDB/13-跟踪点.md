# 13 跟踪点

在某些应用中，调试器若长时间中断程序执行，开发者难以从中获取到对程序行为有帮助的信息。如果程序的正确性取决于其实时行为，调试器引入的延迟可能会导致程序行为发生巨大变化，甚至可能失败，即便代码本身是正确的。能够在不中断程序的情况下观察其行为是很有用的。

使用 gdb 的 `trace` 和 `collect` 命令，可以在程序中指定位置（称为跟踪点），并设定当到达这些跟踪点时要计算的任意表达式。之后，使用 `tfind` 命令，可以检查程序到达跟踪点时这些表达式的值。表达式还可以表示内存中的对象，例如结构体或数组，gdb 应记录其值；在访问特定跟踪点时，可以像这些对象当时就在内存中一样对其进行检查。

然而，由于 gdb 是在不与用户交互的情况下记录这些值的，所以能够快速且不引人注意地完成，有望不干扰程序的行为。

跟踪点功能目前仅适用于远程目标。请参见第 19 章[目标]，第 311 页。此外，远程目标必须知道如何收集跟踪数据。此功能在远程存根中实现；不过，在撰写本文时，与 gdb 一起分发的存根都不支持跟踪点。用于实现跟踪点的远程数据包的格式在第 E.7 节[跟踪点数据包]，第 819 页中有描述。

也可以从文件中获取跟踪数据，这类似于核心文件；指定文件名，然后使用 `tfind` 来搜索文件。有关更多详细信息，请参见第 13.4 节[跟踪文件]，第 219 页。

本章介绍跟踪点的命令和特性。

## 13.1 设置跟踪点的命令

在运行此类跟踪实验之前，可以设置任意数量的跟踪点。跟踪点实际上是一种特殊类型的断点（请参见第 5.1.1 节[设置断点]，第 58 页），因此可以使用标准断点命令来操作它。例如，与断点一样，跟踪点编号是从 1 开始的连续整数，并且许多与跟踪点相关的命令将跟踪点编号作为其参数，以标识要处理的跟踪点。

对于每个跟踪点，可以预先指定一组任意的数据，希望目标在到达该跟踪点时在跟踪缓冲区中收集。收集的数据可以包括寄存器、局部变量或全局数据。稍后，可以使用 gdb 命令检查这些数据在跟踪点被命中时的值。

跟踪点并非支持断点的所有特性。跟踪点上的忽略计数没有效果，并且跟踪点在命中时不能运行 gdb 命令。跟踪点也可能不是特定于线程的。

某些目标可能支持快速跟踪点，它们以不同的方式插入（例如使用跳转而非陷阱），速度更快，但可能在安装位置上受到限制。

常规和快速跟踪点属于动态跟踪设施，意味着它们能够用于在目标中的（几乎）任何位置插入跟踪点。某些目标可能还支持从 gdb 控制静态跟踪点。通过静态跟踪，一组检测点（也称为标记）嵌入在目标程序中，能够通过名称或地址激活或停用。这些通常放置在便于调查目标实际行为的位置。gdb 对静态跟踪的支持包括能够列出检测点，并使用 gdb 定义的高级跟踪点将其附加，以展现 gdb 跟踪点支持的全部便利功能。即支持收集寄存器值以及全局或局部（对于检测点）变量的值；跟踪点条件和跟踪状态变量。在检测点上安装 gdb 静态跟踪点的行为，被称为探测静态跟踪点标记。

gdbserver 在某些目标系统上支持跟踪点。请参见第 20.3 节[gdbserver 中的跟踪点支持]，第 320 页。

本节介绍设置跟踪点以及相关条件和操作的命令。

### 13.1.1 创建和删除跟踪点

```
	trace locspec
		`trace` 命令与 `break` 命令非常相似。其参数 `locspec` 可以是任何有效的位置规范。请参见第 9.2 节[位置规范]，第 126 页。`trace` 命令定义一个跟踪点，即目标程序中调试器会短暂停止、收集一些数据然后允许程序继续的点。如果远程存根支持 `'InstallInTrace'` 特性（请参见[在跟踪中安装跟踪点]，第 809 页），设置跟踪点或更改其操作会立即生效。如果远程存根不支持 `'InstallInTrace'` 特性，所有这些更改在下次 `tstart` 命令之前都不会生效，并且一旦跟踪实验正在运行，进一步的更改在下次跟踪实验开始之前都不会有任何效果。此外，gdb 支持挂起的跟踪点，即地址尚未解析的跟踪点（这与挂起的断点类似）。挂起的跟踪点在未解析之前不会下载到目标并安装。挂起跟踪点的解析需要 gdb 支持——当使用远程目标进行调试并且 gdb 与远程存根断开连接时（请参见[断开连接的跟踪]，第 212 页），在 gdb 断开连接期间，挂起的跟踪点无法解析（并下载到远程存根）。
		以下是使用 `trace` 命令的一些示例：
			(gdb) trace foo.c:121    // 一个源文件和行号
			(gdb) trace +2           // 向前 2 行
			(gdb) trace my function  // 函数的第一行源代码
			(gdb) trace *my function // 函数的确切起始地址
			(gdb) trace *0x2117c4    // 一个地址
		
		可以将 `trace` 缩写为 `tr` 。

	trace locspec if cond
		设置带有条件 `cond` 的跟踪点；每次到达跟踪点时计算表达式 `cond`，并且仅当值不为零（即 `cond` 计算结果为真）时收集数据。有关跟踪点条件的更多信息，请参见第 13.1.4 节[跟踪点条件]，第 207 页。

	ftrace locspec [ if cond ]
		`ftrace` 命令设置一个快速跟踪点。对于支持它们的目标，快速跟踪点将使用更高效但可能不太通用的技术来触发数据收集，例如跳转指令而不是陷阱，或者某种硬件支持。可能无法在所需位置创建快速跟踪点，在这种情况下，命令将以解释性消息退出。
		gdb 对 `ftrace` 的参数处理与对 `trace` 的处理完全相同。
		在 32 位 x86 架构系统上，快速跟踪点通常需要放置在 5 字节或更长的指令处，但如果目标程序的低 64K 内存可用于安装跳板，则可以放置在 4 字节指令处。一些 Unix 类型的系统，例如 gnu/Linux，会从程序的地址空间中排除低地址；但例如对于 Linux 内核，可以通过执行 `sysctl` 命令设置 `mmap_min_addr` 内核参数，例如：

			sudo sysctl -w vm.mmap_min_addr=32768

		这将低地址设置为 32K，为跳板留下了足够的空间。最小地址应设置为页面边界。

	strace [locspec | -m marker] [ if cond ]
		`strace` 命令设置一个静态跟踪点。对于支持它的目标，设置静态跟踪点会探测在解析 `locspec` 得到的代码位置处找到的静态检测点或标记。可能无法在期望的代码位置设置静态跟踪点，在这种情况下，命令将以解释性消息退出。
		gdb 对 `strace` 的参数处理与对 `trace` 的处理完全相同，此外，用户还可以指定 `-m marker` 而不是位置规范。这将探测由标记字符串标识符标识的标记。此标识符取决于程序正在使用的静态跟踪点后端库。可以在 `info static-tracepoint-markers` 命令的输出的 `ID` 字段中找到所有标记标识符。例如，在以下使用 UST 跟踪引擎的小程序中：

			main ()
			{
				trace_mark(ust, bar33, "str %s", "FOOBAZ");
			}

		标记的 ID 由 `trace_mark` 调用的前两个参数用斜杠连接组成，即：

			(gdb) info static-tracepoint-markers
			Cnt Enb ID        Address            What
			1   n   ust/bar33 0x0000000000400ddc in main at stexample.c:22
					Data: "str %s"
			[etc...]

		所以可以用以下命令探测上述标记：

			(gdb) strace -m ust/bar33

		静态跟踪点接受一个额外的收集操作——`collect $_sdata` 。这会收集在探测点调用中传递给跟踪库的任意用户数据。在上述 UST 示例中，会看到 `trace_mark` 的第三个参数是一个类似于 `printf` 的格式字符串。用户数据就是针对后续参数运行该格式化字符串的结果。请注意，`info static-tracepoint-markers` 命令的输出在 `Data:` 字段中列出了该格式字符串。
		在分析跟踪缓冲区时，可以通过像打印任何其他 gdb 可用变量一样打印 `$sdata` 变量来检查此数据。请参见第 13.1.6 节[跟踪点操作列表]，第 208 页。
		便利变量 `$tpnum` 记录最近设置的跟踪点的跟踪点编号。

	delete tracepoint [num]
		永久删除一个或多个跟踪点。如果没有参数，默认是删除所有跟踪点。请注意，常规的 `delete` 命令也可以删除跟踪点。

		示例：
			(gdb) delete trace 1 2 3 // 删除三个跟踪点
			(gdb) delete trace       // 删除所有跟踪点

		可以将此命令缩写为 `del tr` 。
```

### 13.1.2 启用和禁用跟踪点

这些命令已弃用；它们等同于普通的 `disable` 和 `enable` 。

```
disable tracepoint [num]
	禁用跟踪点 `num`，如果没有给出参数 `num`，则禁用所有跟踪点。禁用的跟踪点在跟踪实验期间不会产生效果，但不会被遗忘。可以使用 `enable tracepoint` 命令重新启用已禁用的跟踪点。如果在跟踪实验期间发出此命令，并且调试目标支持在跟踪实验期间禁用跟踪点，那么更改将立即生效。否则，它将应用于下一次跟踪实验。

enable tracepoint [num]
	启用跟踪点 `num`，或者启用所有跟踪点。如果在跟踪实验期间发出此命令，并且调试目标支持在跟踪实验期间启用跟踪点，那么启用的跟踪点将立即生效。否则，它们将在下一次运行跟踪实验时生效。
```

### 13.1.3 跟踪点通过次数
```
passcount [n [num]]
	设置跟踪点的通过次数。通过次数是自动停止跟踪实验的一种方式。如果跟踪点的通过次数为 `n`，则在该跟踪点第 `n` 次被命中时，跟踪实验将自动停止。如果未指定跟踪点编号 `num`，`passcount` 命令将设置最近定义的跟踪点的通过次数。如果未给出通过次数，跟踪实验将一直运行，直到用户明确停止。

	示例：
		(gdb) passcount 5 2    // 在跟踪点 2 第 5 次执行时停止
		(gdb) passcount 12     // 在最近定义的跟踪点第 12 次执行时停止
		(gdb) trace foo
		(gdb) pass 3
		(gdb) trace bar
		(gdb) pass 2
		(gdb) trace baz
		(gdb) pass 1            // 当 `foo` 执行 3 次 或者 `bar` 执行 2 次 或者 `baz` 执行 1 次时停止跟踪
```

### 13.1.4 跟踪点条件

最简单的跟踪点在程序每次到达指定位置时收集数据。您还可以为跟踪点指定一个条件。条件就是您的编程语言中的布尔表达式（请参见第 10.1 节[表达式]，第 145 页）。带有条件的跟踪点每次程序到达时都会计算表达式，并且仅当条件为真时才收集数据。

可以在设置跟踪点时使用 `trace` 命令的参数中的 `if` 来指定跟踪点条件。请参见第 13.1.1 节[设置跟踪点]，第 204 页。也可以随时使用 `condition` 命令设置或更改条件，就像断点条件一样。

与断点条件不同，gdb 实际上不会自己计算条件表达式。相反，gdb 将表达式编码为适合在目标上执行的代理表达式（请参见附录 F [代理表达式]，第 849 页），独立于 gdb 。全局变量变为原始内存位置，局部变量变为堆栈访问，等等。

例如，假设您有一个通常被频繁调用的函数，但在错误代码传播通过程序时不应被调用。您可以使用以下跟踪点命令来收集有关在错误代码传播期间调用该函数的跟踪数据；无条件的跟踪点可能最终会收集数千个无用的跟踪帧，您需要在其中进行搜索。

```
	(gdb) trace normal_operation if errcode > 0
```

### 13.1.5 跟踪状态变量

跟踪状态变量是一种由目标端代码创建和管理的特殊类型变量。其语法与 GDB 的便利变量（以“$”为前缀的字符串）相同，但它们存储在目标上。必须使用 `tvariable` 命令显式创建。它们始终是 64 位有符号整数。

跟踪状态变量由 gdb 记住，并在跟踪实验开始时与跟踪点信息一起下载到目标。除了目标的内存限制外，跟踪状态变量的数量没有内在限制。

尽管跟踪状态变量由目标管理，但您可以在打印命令和表达式中使用它们，就像使用便利变量一样；在跟踪实验运行时，gdb 将从目标获取当前值。跟踪状态变量与其他“$”变量共享相同的命名空间，这意味着您不能有名称类似于 `$23` 或 `$pc` 的跟踪状态变量，也不能有具有相同名称的跟踪状态变量和便利变量。
```
	tvariable $name [ = expression ]
		`tvariable` 命令创建一个名为 `$name` 的新跟踪状态变量，并可选地为其赋予初始值 `expression` 。在输入此命令时会计算表达式；如果可能，结果将转换为整数，否则 gdb 将报告错误。后续指定相同名称的 `tvariable` 命令不会创建变量，而是将提供的初始值分配给该名称的现有变量，覆盖任何以前的初始值。默认初始值为 0。

	info tvariables
		列出所有跟踪状态变量及其初始值。如果跟踪实验当前正在运行，还可能显示其当前值。

	delete tvariable [ $name... ]
		删除给定的跟踪状态变量，如果未指定参数，则删除所有跟踪状态变量。
```

### 13.1.6 跟踪点操作列表

```
	actions [num]
		此命令将提示输入当跟踪点被命中时要采取的操作列表。如果未指定跟踪点编号 `num`，此命令将为最近定义的跟踪点设置操作（这样您可以定义一个跟踪点，然后说 `actions` 而不必担心其编号）。您在接下来的行中逐个指定操作，每行一个操作，并以仅包含 `end` 的行终止操作列表。到目前为止，唯一定义的操作是 `collect`、`teval` 和 `while-stepping` 。
		`actions` 实际上等同于 `commands`（请参见第 5.1.7 节[断点命令列表]，第 77 页），不同之处在于只允许定义的操作；任何其他 gdb 命令都会被拒绝。
		要从跟踪点中删除所有操作，输入 `'actions num'` 并立即跟随着 `end` 。

			(gdb) collect data // 收集一些数据
			(gdb) while-stepping 5 // 单步执行 5 次，收集数据
			(gdb) end // 表示操作结束。

		在下面的示例中，操作列表以 `collect` 命令开始，指示跟踪点被命中时要收集的内容。然后，为了在跟踪点之后单步执行并收集其他数据，使用了 `while-stepping` 命令，接着是在一系列单步执行中的每一步之后要收集的内容列表。`while-stepping` 命令由其自己单独的 `end` 命令终止。最后，操作列表由一个 `end` 命令终止。

			(gdb) trace foo
			(gdb) actions
			Enter actions for tracepoint 1, one per line:
			> collect bar,baz
			> collect $regs
			> while-stepping 12
			  > collect $pc, arr[i]
			  > end
			end

	collect[/mods] expr1, expr2, ...
		当跟踪点被命中时收集给定表达式的值。此命令接受以逗号分隔的任何有效表达式列表。除了全局、静态或局部变量外，还支持以下特殊参数：
			$regs
				收集所有寄存器。

			$args
				收集所有函数参数。

			$locals
				收集所有局部变量。

			$_ret
				收集返回地址。如果您想查看更多回溯信息，这很有帮助。
				注意：返回地址的位置并不总是能可靠地预先确定，可能最终会收集到错误的地址/寄存器。在某些架构上，对于函数入口处的跟踪点，可靠性较高，而在其他架构上则相反。当这种情况发生时，回溯将停止，因为返回地址不可用（除非另一个收集规则匹配到了它）。

			$_probe_argc
				收集跟踪点所在的静态探测的参数数量。请参见第 5.1.10 节[静态探测点]，第 81 页。

			$_probe_argn
				`n` 是 0 到 11 之间的整数。收集跟踪点所在的静态探测的第 `n` 个参数。请参见第 5.1.10 节[静态探测点]，第 81 页。

			$_sdata
				收集静态跟踪点标记特定的数据。仅适用于静态跟踪点。请参见第 13.1.6 节[跟踪点操作列表]，第 208 页。在 UST 静态跟踪点库后端，一个检测点类似于 `printf` 函数调用。跟踪库能够使用程序员提供的格式收集格式化为字符串的用户指定数据。其他后端具有类似的机制。
				这是一个 UST 标记调用的示例：

					const char master_name[] = "$your_name";
					trace_mark(channel1, marker1, "hello %s", master_name)

				在这种情况下，收集 `$_sdata` 会收集字符串 `hello $yourname` 。在分析跟踪缓冲区时，您可以像检查任何其他 gdb 可用的变量一样检查 `$_sdata` 。

		您可以给出几个连续的 `collect` 命令，每个命令带有一个参数，或者一个带有多个用逗号分隔的参数的 `collect` 命令；效果是相同的。
		可选的 `mods` 会更改参数的通常处理方式。`s` 要求将指向字符的指针作为字符串处理，特别是收集所指向内存的内容，直到第一个零。上限默认是 `print characters` 变量的值；如果 `s` 后面跟着一个十进制数，那就是上限。例如，`collect/s25 mystr` 从 `mystr` 收集多达 25 个字符。
		`info scope` 命令（请参见第 16 章[符号]，第 263 页）对于确定要收集的数据特别有用。

	teval expr1, expr2, ...
		当跟踪点被命中时计算给定的表达式。此命令接受以逗号分隔的表达式列表。结果将被丢弃，因此这主要用于为跟踪状态变量赋值（请参见第 13.1.5 节[跟踪状态变量]，第 207 页），而不会将这些值添加到跟踪缓冲区中，如果使用 `collect` 操作则会这样。

	while-stepping n
		在跟踪点之后执行 `n` 次单步指令跟踪，在每次单步执行后收集新数据。`while-stepping` 命令后面跟着单步执行时要收集的内容列表（后跟其自己的 `end` 命令）：
			> while-stepping 12
			  > collect $regs, myglobal
			  > end
			>

		请注意，`$pc` 不会被 `while-stepping` 自动收集；如果需要，您需要显式收集该寄存器。您可以将 `while-stepping` 缩写为 `ws` 或 `stepping` 。

	set default-collect expr1, expr2, ...
		此变量是在每次跟踪点命中时要收集的表达式列表。它实际上是每个跟踪点操作列表前面添加的一个额外的 `collect` 操作。表达式会针对每个跟踪点单独解析，因此例如名为 `xyz` 的变量对于一个跟踪点可能被解释为全局变量，而对于另一个跟踪点可能被解释为局部变量，具体取决于跟踪点的位置。

	show default-collect
		显示每次跟踪点命中时默认收集的表达式列表。
```

### 13.1.7 列出跟踪点

```
info tracepoints [num...]
	显示关于跟踪点 `num` 的信息。如果未指定跟踪点编号，则显示迄今为止定义的所有跟踪点的信息。格式类似于 `info breakpoints` 所使用的格式；实际上，`info tracepoints` 就是相同的命令，只是将其自身限制在跟踪点上。
	跟踪点的列表可能包括特定于跟踪的其他信息：
		• 由 `passcount n` 命令给定的通过次数
		• 每个位置在目标上的安装状态

			(gdb) info trace
			Num     Type           Disp Enb  Address      What
			1       tracepoint     keep y    0x0804ab57   in foo() at main.cxx:7
			        while-stepping 20
			          collect globfoo, $regs
			        end
			        collect globfoo2
			        end
			        pass count 1200
			2       tracepoint      keep y   <MULTIPLE>
			        collect $eip
			2.1                          y    0x0804859c   in func4 at change-loc.h:35
			        installed on target
			2.2                          y    0xb7ffc480   in func4 at change-loc.h:35
			        installed on target
			2.3                          y    <PENDING>    set_tracepoint
			3       tracepoint keep      y    0x080485b1   in foo at change-loc.c:29
			        not installed on target
			(gdb)

	此命令可以缩写为 `info tp` 。
```

### 13.1.8 列出静态跟踪点标记

```
info static-tracepoint-markers
	显示程序中定义的所有静态跟踪点标记的信息。对于每个标记，将打印以下列：
	Count
		一个递增的计数器，用于提高可读性。这不是一个稳定的标识符。

	ID
		目标报告的标记 ID。

	Enabled or Disabled
		已探测的标记标记为 `y` 。`n` 标识未启用的标记。

	Address
		标记在程序中的位置，作为内存地址。

	What
		标记在程序源代码中的位置，作为文件和行号。如果程序中包含的调试信息不允许 gdb 定位标记的源代码，此列将留空。

	此外，对于每个标记可能会打印以下信息：

	Data
		标记调用传递给跟踪库的用户数据。在 UST 后端，这是作为参数传递给标记调用的格式字符串。

	Static tracepoints probing the marker
		附加到标记的静态跟踪点列表。

		(gdb) info static-tracepoint-markers
		Cnt   ID        Enb     Address             What
		1     ust/bar2  y       0x0000000000400e1a  in main at stexample.c:25
		      Data: number1 %d number2 %d
		      Probed by static tracepoints: #2
		2     ust/bar33 n       0x0000000000400c87  in main at stexample.c:24
		      Data: str %s
		(gdb)
```

### 13.1.9 启动和停止跟踪实验

```
tstart
	此命令启动跟踪实验，并开始收集数据。它具有丢弃在上一次跟踪实验期间在跟踪缓冲区中收集的所有数据的副作用。如果提供了任何参数，它们将作为注释并与跟踪实验的状态一起存储。注释可以是任意文本，在多用户环境中的断开连接跟踪中特别有用；注释可以解释跟踪正在做什么、提供用户联系信息等。

tstop
	此命令停止跟踪实验。如果提供了任何参数，它们将作为注释与实验一起记录。例如，如果跟踪干扰了系统的行为并且需要快速停止，那么在停止其他人启动的跟踪时这很有用。
	注意：如果达到任何跟踪点的通过次数（请参见第 13.1.3 节[跟踪点通过次数]，第 206 页），或者跟踪缓冲区已满，跟踪实验和数据收集可能会自动停止。

tstatus
	此命令显示当前跟踪数据收集的状态。
	以下是到目前为止我们所描述的命令的一个示例：
		(gdb) trace gdb c test
		(gdb) actions
		Enter actions for tracepoint #1, one per line.
		> collect $regs,$locals,$args
		> while-stepping 11
		  > collect $regs
		  > end
		> end
		(gdb) tstart
		[time passes ...]
		(gdb) tstop
```

您可以选择即使 gdb 与目标断开连接（无论是自愿还是非自愿），跟踪实验仍继续运行。对于诸如 `detach` 之类的命令，调试器将询问您对跟踪的处理方式。但是对于意外终止（gdb 崩溃、网络中断），丢失来之不易的跟踪数据将是不幸的，因此变量 `disconnected-tracing` 可让您决定跟踪是否应在没有 gdb 的情况下继续运行。

```
set disconnected-tracing on
set disconnected-tracing off
	选择在 gdb 与目标断开连接时跟踪运行是否应继续。请注意，无论此变量的设置如何，`detach` 或 `quit` 都会直接询问您对正在运行的跟踪的处理方式，因此该变量主要用于处理意外情况，例如网络丢失。

show disconnected-tracing
	显示断开连接跟踪的当前选择。
```

当您重新连接到目标时，跟踪实验可能仍在运行，也可能已停止；在此期间，它可能已填满跟踪缓冲区，或者由于其他原因而停止。如果它正在运行，重新连接后将继续。

重新连接时，目标将上传有关有效的跟踪点的信息。gdb 然后将该信息与当前定义的跟踪点集进行比较，并尝试匹配它们，考虑到由于在此期间的创建和删除，数字可能已更改的可能性。如果目标的某个跟踪点与 gdb 中的任何跟踪点都不匹配，调试器将创建一个新的跟踪点，以便您有一个编号来指定该跟踪点。此匹配过程必然是启发式的，可能会导致创建无用的跟踪点；如果它们无用，您可以简单地删除它们。

如果您的目标代理支持循环跟踪缓冲区，那么您可以无限期地运行跟踪实验而不会填满跟踪缓冲区；当空间不足时，代理会删除已收集的跟踪帧，从最旧的开始，直到有足够的空间继续收集。如果您的跟踪点被命中得太频繁，并且由于缓冲区已满而导致跟踪过早终止，这将特别有用。要请求循环跟踪缓冲区，只需将 `'circular-trace-buffer'` 设置为 `on` 。您可以在任何时候设置，包括在跟踪期间；如果代理可以做到，它将即时更改缓冲区处理，否则直到下一次运行才生效。

```
set circular-trace-buffer on
set circular-trace-buffer off
	选择跟踪运行应使用线性还是循环缓冲区来存储跟踪数据。线性缓冲区不会丢失任何跟踪数据，但可能过早填满，而循环缓冲区将丢弃旧的跟踪数据，但始终为最新的跟踪点命中保留空间。

show circular-trace-buffer
	显示跟踪缓冲区的当前选择。请注意，这可能与代理的当前缓冲区处理不匹配，也不能保证与过去运行中可能有效的设置匹配，例如，如果您正在查看来自跟踪文件的帧。

set trace-buffer-size n
set trace-buffer-size unlimited
	请求目标使用 `n` 字节的跟踪缓冲区。并非所有目标都会遵守该请求；它们可能具有为跟踪缓冲区编译的固定大小，或者存在其他限制。设置为 `unlimited` 或 `-1` 以让目标使用其喜欢的任何大小。这也是默认值。

show trace-buffer-size
	显示当前请求的跟踪缓冲区大小。请注意，只有当目标支持大小设置并且能够处理请求的大小时，此变量才会与实际大小匹配。例如，如果目标只能在运行之间更改缓冲区大小，则此变量在下次运行开始之前不会反映更改。使用 `tstatus` 获取实际缓冲区大小的报告。

set trace-user text
show trace-user
set trace-notes text
	设置跟踪运行的注释。

show trace-notes
	显示跟踪运行的注释。

set trace-stop-notes text
	设置跟踪运行的停止注释。注释的处理方式与 `tstop` 参数相同；`set` 命令是一种方便的方式来修正错误或不完整的停止注释。

show trace-stop-notes
	显示跟踪运行的停止注释。
```

### 13.1.10 跟踪点限制

在使用跟踪点时存在许多限制。如上所述，跟踪点数据收集在目标上进行，而无需 gdb 进行交互。因此，在数据收集期间，调试器的全部功能不可用，然后在数据检查时，您将受到仅拥有所收集内容的限制。以下项目描述了一些常见问题，但并非详尽无遗，您可能会遇到此处未提及的其他困难。

• 跟踪点表达式旨在收集对象（左值）。因此，GDB 表达式求值器的全部灵活性不可用。您不能调用函数、将对象强制转换为聚合类型、访问便利变量或修改值（除非通过赋值给跟踪状态变量）。某些语言特性可能会隐式调用函数（例如带有访问器的 Objective-C 字段），因此也无法收集。

• 在单步执行期间，单独或通过 `$locals` 或 `$args` 批量收集局部变量的行为可能不稳定。单步操作可能会进入新的作用域（例如单步进入函数），或者变量的位置可能会改变（例如它被加载到寄存器中）。记录的跟踪点数据使用对跟踪点位置而言正确的变量位置信息。创建跟踪点时，通常无法确定单步执行序列的步骤将使程序前进到何处，特别是在单步执行条件分支时。

• 收集不完全初始化或部分销毁的对象可能会导致 gdb 无法显示或显示方式具有误导性。

• 当 gdb 显示指向字符的指针时，它会自动解引用指针以同时显示所指向字符串的字符。但是，在跟踪期间收集指针不会自动收集字符串。如果您不仅要收集指针，还要收集所指向的内存，则需要显式解引用指针并提供大小信息。例如，`*ptr@50` 可用于收集 `ptr` 所指向的 50 个元素的数组。

• 在跟踪点无法收集完整的堆栈回溯。相反，您可以使用类似于 `*(unsigned char *)$esp@300`（根据您的目标架构调整实际的堆栈指针寄存器名称和要捕获的堆栈量）来收集寄存器和从堆栈指针开始的几百个字节。然后，在使用跟踪帧时，`backtrace` 命令将显示部分回溯。可以检查的堆栈帧数取决于收集的堆栈中帧的大小。请注意，如果您请求的块太大以至于超出了堆栈底部，目标代理可能会在尝试从无效地址读取时报告错误。

• 如果在跟踪点未收集寄存器，gdb 可以推断 `$pc` 的值必须与跟踪点的地址相同，并在查看该跟踪点的跟踪帧时使用它。但是，如果跟踪点有多个位置（例如，如果它设置在被内联的函数中），或者如果它有单步执行循环，则此方法不起作用。在这些情况下，gdb 会警告您它无法推断 `$pc`，并将其默认设置为零。

## 13.2 使用收集的数据

跟踪点实验结束后，您使用 gdb 命令检查跟踪数据。基本思想是每个跟踪点每次被命中时都会收集一个跟踪快照，每次单步执行时也会收集另一个快照。所有这些快照从 0 开始连续编号并放入缓冲区，您可以稍后检查它们。检查它们的方法是专注于特定的跟踪快照。当远程存根专注于跟踪快照时，它将通过从属于该快照的缓冲区读取来响应 gdb 对内存和寄存器的所有请求，而不是从正在调试的程序的真实内存或寄存器读取。这意味着所有 gdb 命令（`print`、`info registers`、`backtrace` 等）的行为都好像我们当前正在调试跟踪点发生时的程序状态。任何不在缓冲区中的数据请求都将失败。

### 13.2.1 tfind n

从缓冲区中选择跟踪快照的基本命令是 `tfind n`，它查找编号为 `n` 的跟踪快照，从 0 开始计数。如果未给定参数 `n`，则选择下一个快照。

以下是使用 `tfind` 命令的各种形式。

```
	tfind start
		查找缓冲区中的第一个快照。这是 `tfind 0` 的同义词（因为 0 是第一个快照的编号）。

	tfind none
		停止调试跟踪快照，恢复实时调试。

	tfind end 与 tfind none 相同。

	tfind
		没有参数意味着查找下一个跟踪快照，如果没有选择跟踪快照，则查找第一个。

	tfind -
		查找当前之前的跟踪快照。这允许回溯早期的步骤。

	tfind tracepoint num
		查找与跟踪点 `num` 相关的下一个快照。从上次检查的跟踪快照向前搜索。如果未给定参数 `num`，则表示查找与当前快照相同跟踪点收集的下一个快照。

	tfind pc addr
		查找与程序计数器值 `addr` 相关的下一个快照。从上次检查的跟踪快照向前搜索。如果未给定参数 `addr`，则表示查找与当前快照具有相同 PC 值的下一个快照。

	tfind outside addr1, addr2
		查找程序计数器（PC）在给定地址范围（不包括）之外的下一个快照。

	tfind range addr1, addr2
		查找 PC 在 `addr1` 和 `addr2` 之间（包括）的下一个快照。

	tfind line [file:]n
		查找与源行 `n` 相关的下一个快照。如果给出可选参数 `file`，则指该源文件中的行 `n`。从上次检查的跟踪快照向前搜索。如果未给定参数 `n`，则表示查找与当前正在检查的行不同的下一个行；因此，重复说 `tfind line` 似乎具有与在实时调试会话中从一行步进到另一行相同的效果。
```

`tfind` 命令的默认参数专门设计为便于扫描跟踪缓冲区。例如，没有参数的 `tfind` 选择下一个跟踪快照，没有参数的 `tfind -` 选择上一个跟踪快照。因此，通过给出一个 `tfind` 命令，然后简单地重复按回车键，您可以按顺序检查所有跟踪快照。或者，通过说 `tfind -` 然后重复按回车键，您可以以相反的顺序检查快照。没有参数的 `tfind line` 命令选择下一个执行的源行的快照。没有参数的 `tfind pc` 命令选择与当前帧具有相同程序计数器（PC）的下一个快照。没有参数的 `tfind tracepoint` 命令选择与当前跟踪点相同的下一个跟踪快照。

除了让您手动扫描跟踪缓冲区外，这些命令还便于构建 gdb 脚本，以扫描跟踪缓冲区并打印出您感兴趣的任何收集的数据。因此，如果我们要检查缓冲区中每个跟踪帧的 PC、FP 和 SP 寄存器，我们可以这样说：

```
(gdb) tfind start
(gdb) while ($trace frame!= -1)
> printf "Frame %d, PC = %08X, SP = %08X, FP = %08X\n", \
          $trace_frame, $pc, $sp, $fp
> tfind
> end
Frame 0, PC = 0020DC64, SP = 0030BF3C, FP = 0030BF44
Frame 1, PC = 0020DC6C, SP = 0030BF38, FP = 0030BF44
Frame 2, PC = 0020DC70, SP = 0030BF34, FP = 0030BF44
Frame 3, PC = 0020DC74, SP = 0030BF30, FP = 0030BF44
Frame 4, PC = 0020DC78, SP = 0030BF2C, FP = 0030BF44
Frame 5, PC = 0020DC7C, SP = 0030BF28, FP = 0030BF44
Frame 6, PC = 0020DC80, SP = 0030BF24, FP = 0030BF44
Frame 7, PC = 0020DC84, SP = 0030BF20, FP = 0030BF44
Frame 8, PC = 0020DC88, SP = 0030BF1C, FP = 0030BF44
Frame 9, PC = 0020DC8E, SP = 0030BF18, FP = 0030BF44
Frame 10, PC = 00203F6C, SP = 0030BE3C, FP = 0030BF14
```

或者，如果我们要检查缓冲区中每个源行的变量 `X`：

```
(gdb) tfind start
(gdb) while ($trace frame!= -1)
> printf "Frame %d, X == %d\n", $trace_frame, X
> tfind line
> end
Frame 0, X = 1
Frame 7, X = 2
Frame 13, X = 255
```

### 13.2.2 `tdump`

此命令不接受任何参数。它打印当前跟踪快照收集的所有数据。

```
(gdb) trace 444
(gdb) actions
Enter actions for tracepoint #2, one per line:
> collect $regs, $locals, $args, gdb_long_test
> end

(gdb) tstart

(gdb) tfind line 444
#0 gdb_test (p1=0x11, p2=0x22, p3=0x33, p4=0x44, p5=0x55, p6=0x66)
at gdb_test.c:444
444 printp( "%s: arguments = 0x%X 0x%X 0x%X 0x%X 0x%X 0x%X\n", )

(gdb) tdump
Data collected at tracepoint 2, trace frame 1:
d0             0xc4aa0085 -995491707
d1             0x18 24
d2             0x80 128
d3             0x33 51
d4             0x71aea3d 119204413
d5             0x22 34
d6             0xe0 224
d7             0x380035 3670069
a0             0x19e24a 1696330
a1             0x3000668 50333288
a2             0x100 256
a3             0x322000 3284992
a4             0x3000698 50333336
a5             0x1ad3cc 1758156
fp             0x30bf3c 0x30bf3c
sp             0x30bf34 0x30bf34
ps             0x0 0
pc             0x20b2c8 0x20b2c8
fpcontrol      0x0 0
fpstatus       0x0 0
fpiaddr        0x0 0
p = 0x20e5b4 "gdb-test"
p1 = (void *) 0x11
p2 = (void *) 0x22
p3 = (void *) 0x33
p4 = (void *) 0x44
p5 = (void *) 0x55
p6 = (void *) 0x66
gdb_long_test = 17 ’\021’
(gdb)
```

`tdump` 通过扫描跟踪点当前的收集操作并打印列出的每个表达式的值来工作。因此，如果在运行后更改了跟踪点的操作以提及运行期间未收集的变量，`tdump` 可能会失败。

此外，对于具有单步执行循环的跟踪点，`tdump` 使用收集的 `$pc` 值来区分在跟踪点命中时收集的跟踪帧和在单步执行时收集的帧。这允许它正确选择是显示基本的收集列表，还是单步执行循环主体中的收集。但是，如果未收集 `$pc`，则 `tdump` 将始终尝试使用基本收集列表进行转储，如果单步执行帧不包含在跟踪点命中时收集的所有相同数据，则可能会失败。

### 13.2.3 保存断点信息到文件中，文件名是filename

此命令将当前所有跟踪点定义及其操作和通过次数保存到文件 `filename` 中，以便在以后的调试会话中使用。要读取保存的跟踪点定义，请使用 `source` 命令（请参见第 23.1.3 节[命令文件]，第 395 页）。`save-tracepoints` 是 `save tracepoints` 的已弃用别名。

## 13.3 跟踪点的便利变量

- `(int) $trace_frame`：当前跟踪快照（又称帧）编号，若未选择快照则为 -1 。
- `(int) $tracepoint`：当前跟踪快照的跟踪点。
- `(int) $trace_line`：当前跟踪快照的行号。
- `(char []) $trace_file`：当前跟踪快照的源文件。
- `(char []) $trace_func`：包含 `$tracepoint` 的函数的名称。

注意：`$trace_file` 不适用于 `printf`，应使用 `output` 代替。

以下是一个使用这些便利变量遍历所有跟踪快照并打印部分数据的简单示例。请注意，这些与由目标管理的跟踪状态变量不同。

```
(gdb) tfind start
(gdb) while $trace frame!= -1
> output $trace_file
> printf ", line %d (tracepoint #%d)\n", $trace_line, $tracepoint
> tfind
> end
```

## 13.4 使用跟踪文件

在某些情况下，运行跟踪实验的目标可能不再可用，可能已崩溃，或者硬件需要用于其他活动。为处理这些情况，可以将跟踪数据转储到文件中，然后通过 `target tfile` 命令使用该文件作为跟踪数据的来源。

```
tsave [ -r ] filename
tsave [-ctf] dirname
	将跟踪数据保存到 `filename`。默认情况下，此命令假定 `filename` 指的是主机文件系统，因此如有必要，GDB 会从目标复制原始跟踪数据，然后进行保存。如果目标支持，还可以提供可选参数 `-r`（“远程”），指示目标直接将数据保存到其自身文件系统中的 `filename`，如果跟踪缓冲区非常大，这可能更高效。（但请注意，`target tfile` 只能从主机可访问的文件中读取。）默认情况下，此命令将以 `tfile` 格式保存跟踪帧。可以提供可选参数 `-ctf` 以 `CTF` 格式保存数据。通用跟踪格式（CTF）被提议作为可由多个调试和跟踪工具共享的跟踪格式。请访问 `'http://www.efficios.com/ctf'` 以获取更多信息。

target tfile filename
	使用名为 `filename` 的文件或名为 `dirname` 的目录作为跟踪数据的来源。检查数据的命令的工作方式与实时目标相同，但无法运行任何新的跟踪实验。`tstatus` 将报告保存数据时跟踪运行的状态以及当前正在检查的跟踪帧。`filename` 和 `dirname` 都必须在主机可访问的文件系统上。
	`filename` 和 `dirname` 参数支持转义和引号，请参见第 3.4 节[作为命令参数的文件名]，第 27 页。

	(gdb) target ctf ctf.ctf
	(gdb) tfind
	Found trace frame 0, tracepoint 2
	39              ++a; /* set tracepoint 1 here */
	(gdb) tdump
	Data collected at tracepoint 2, trace frame 0:
	i = 0
	a = 0
	b = 1 ’\001’
	c = {"123", "456", "789", "123", "456", "789"}
	d = {{{a = 1, b = 2}, {a = 3, b = 4}}, {{a = 5, b = 6}, {a = 7, b = 8}}}
	(gdb) p b
	$1 = 1
```