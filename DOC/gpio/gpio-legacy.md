以下是为您转换成的 Markdown 格式：

# GPIO 接口

本文提供了 Linux 上 GPIO 访问约定的概述。

这些调用使用 `gpio_*` 命名前缀。其他任何调用都不应使用该前缀或相关的 `__gpio_*` 前缀。

# 什么是 GPIO？
===============
“通用输入/输出”（GPIO）是一种灵活的软件控制数字信号。它们由多种芯片提供，对于从事嵌入式和定制硬件工作的 Linux 开发者来说很熟悉。每个 GPIO 代表连接到特定引脚或球栅阵列（BGA）封装上的“球”的一位。电路板原理图显示了哪些外部硬件连接到哪些 GPIO。驱动程序可以编写得通用，以便板级设置代码将此类引脚配置数据传递给驱动程序。

片上系统（SOC）处理器严重依赖 GPIO。在某些情况下，每个非专用引脚都可以配置为 GPIO；并且大多数芯片至少有几十个。可编程逻辑器件（如 FPGA）可以轻松提供 GPIO；多功能芯片，如电源管理器和音频编解码器，通常有几个这样的引脚来帮助解决 SOC 上的引脚短缺问题；还有使用 I2C 或 SPI 串行总线连接的“GPIO 扩展器”芯片。大多数 PC 南桥有几十个具有 GPIO 功能的引脚（只有 BIOS 固件知道如何使用它们）。

GPIO 的确切功能在不同系统之间有所不同。常见选项：

  - 输出值是可写的（高 = 1，低 = 0）。一些芯片还具有关于如何驱动该值的选项，例如可能只驱动一个值……支持“线或”和类似方案用于其他值（特别是“开漏”信号）。

  - 输入值同样是可读的（1，0）。一些芯片支持回读配置为“输出”的引脚的值，这在“线或”情况下非常有用（以支持双向信号）。GPIO 控制器可能具有输入去抖动/去跳变逻辑，有时具有软件控制。

  - 输入通常可以用作 IRQ 信号，通常是边沿触发，但有时是电平触发。此类 IRQ 可以配置为系统唤醒事件，以从低功耗状态唤醒系统。

  - 通常，根据不同的产品板，每个 GPIO 都可以根据需要配置为输入或输出；单向的也存在。

  - 大多数 GPIO 在持有自旋锁时可以访问，但通过串行总线访问的那些通常不能。一些系统支持两种类型。

在给定的板上，每个 GPIO 都用于一个特定目的，例如监视 MMC/SD 卡的插入/移除、检测卡写保护状态、驱动 LED、配置收发器、位敲击串行总线、触发硬件看门狗、检测开关等。

# GPIO 约定
================

请注意，这被称为“约定”，因为您不需要以这种方式进行，并且如果您不这样做也不是犯罪。确实存在一些情况，其中可移植性不是主要问题；GPIO 经常用于特定于板的胶合逻辑，甚至可能在板修订之间发生变化，并且永远不能在布线不同的板上使用。只有最小公分母功能才能具有很高的可移植性。其他功能是特定于平台的，这对于胶合逻辑可能至关重要。

此外，这不需要任何实现框架，只是一个接口。一个平台可能将其实现为访问芯片寄存器的简单内联函数；另一个平台可能通过用于几种非常不同类型的 GPIO 控制器的抽象来委托实现。（后面将介绍一些支持这种实现策略的可选代码，但作为 GPIO 接口客户端的驱动程序不必关心它是如何实现的。）

话虽如此，如果其平台支持该约定，驱动程序应在可能的情况下使用它。平台必须在其 Kconfig 中选择 `ARCH_REQUIRE_GPIOLIB` 或 `ARCH_WANT_OPTIONAL_GPIOLIB`。如果没有标准的 GPIO 调用就无法工作的驱动程序，其 Kconfig 条目应依赖于 `GPIOLIB`。当驱动程序使用以下包含文件时，GPIO 调用可用，无论是“实际代码”还是优化掉的存根：

```c
#include <linux/gpio.h>
```

如果您遵循此约定，那么其他开发人员将更容易理解您的代码在做什么，并帮助维护它。

请注意，在需要使用它们的平台上，这些操作包括 I/O 屏障；驱动程序不需要显式添加它们。

# 标识 GPIO
-----------------

GPIO 通过 0 到 `MAX_INT` 范围内的无符号整数来标识。这为其他目的保留了“负数”，例如标记信号为“在此板上不可用”或指示故障。不接触底层硬件的代码将这些整数视为不透明的标记。

平台定义了如何使用这些整数，并且通常为 GPIO 线定义 `#define` 符号，以便板级特定的设置代码直接对应于相关原理图。相比之下，驱动程序应仅使用从该设置代码传递给它们的 GPIO 编号，使用 `platform_data` 来保存特定于板的引脚配置数据（以及它们需要的其他特定于板的数据）。这避免了可移植性问题。

例如，一个平台使用 32 - 159 用于 GPIO；而另一个平台使用 0..63 与一组 GPIO 控制器，64 - 79 与另一种类型的 GPIO 控制器，在一个特定的板上使用 80 - 95 与一个 FPGA。这些数字不一定是连续的；这些平台中的任何一个也可以使用 2000 - 2063 来标识 I2C GPIO 扩展器中的 GPIO 组。

如果您想使用无效的 GPIO 编号初始化一个结构，可以使用一些负数（也许是 `-EINVAL`）；这永远不会有效。要测试来自这样的结构的这样的数字是否可以引用一个 GPIO，您可以使用这个谓词：

```c
int gpio_is_valid(int number);
```

传递给 `gpio_request()` 的无效 GPIO 编号将失败，就像请求已经被该调用占用的 GPIO 一样。`gpio_request()` 的返回值必须检查。您通常应从任务上下文中发出这些调用。但是，对于自旋锁安全的 GPIO，在启用任务之前请求 GPIO 是可以的，作为早期板级设置的一部分。

这些调用有两个基本目的。一个是标记实际用作 GPIO 的信号，以便更好地进行诊断；系统可能有数百个潜在的 GPIO，但在任何给定的板上通常只使用十几个。另一个是捕获冲突，识别以下错误：（a）两个或多个驱动程序错误地认为它们对该信号有独占使用，或者（b）某些东西错误地认为在活动使用的信号中删除管理该信号所需的驱动程序是安全的。也就是说，请求一个 GPIO 可以作为一种锁。

一些平台还可以使用有关哪些 GPIO 处于活动状态的知识进行电源管理，例如通过关闭未使用的芯片扇区以及更轻松地关闭未使用的时钟。

对于使用引脚控制子系统已知引脚的 GPIO，该子系统应被告知其使用情况；gpiolib 驱动程序的 `.request()` 操作可以调用 `pinctrl_request_gpio()`，gpiolib 驱动程序的 `.free()` 操作可以调用 `pinctrl_free_gpio()`。引脚控制子系统允许 `pinctrl_request_gpio()` 与设备用于引脚复用的引脚或引脚组“拥有”并发成功。

任何将 GPIO 信号路由到适当引脚所需的引脚复用硬件编程都应在 GPIO 驱动程序的 `.direction_input()` 或 `.direction_output()` 操作中进行，并在设置输出 GPIO 的值之后进行。这允许从引脚的特殊功能到 GPIO 的无毛刺迁移。当使用 GPIO 来实现对通常由非 GPIO 硬件块驱动的信号的解决方法时，有时需要这样做。

一些平台允许将某些或所有 GPIO 信号路由到不同的引脚。同样，可能需要配置 GPIO 或引脚的其他方面，例如上拉/下拉。平台软件应安排在为这些 GPIO 调用 `gpio_request()` 之前配置任何此类细节，例如使用引脚控制子系统的映射表，以便 GPIO 用户无需了解这些细节。

还要注意，在释放 GPIO 之前，您有责任停止使用它。

考虑到在大多数情况下，GPIO 实际上是在请求后立即配置的，定义了三个额外的调用：

```c
/* 请求单个 GPIO，使用 'flags' 指定初始配置，与 gpio_request() 关于其他参数和返回值相同 */
int gpio_request_one(unsigned gpio, unsigned long flags, const char *label);

/* 在单个调用中请求多个 GPIO */
int gpio_request_array(struct gpio *array, size_t num);

/* 在单个调用中释放多个 GPIO */
void gpio_free_array(struct gpio *array, size_t num);
```

其中 `flags` 目前定义为指定以下属性：

  - `GPIOF_DIR_IN` - 配置方向为输入
  - `GPIOF_DIR_OUT` - 配置方向为输出

  - `GPIOF_INIT_LOW` - 作为输出，将初始级别设置为低
  - `GPIOF_INIT_HIGH` - 作为输出，将初始级别设置为高
  - `GPIOF_OPEN_DRAIN` - GPIO 引脚为开漏类型。
  - `GPIOF_OPEN_SOURCE` - GPIO 引脚为开源类型。

  - `GPIOF_EXPORT_DIR_FIXED` - 将 GPIO 导出到 sysfs，保持方向
  - `GPIOF_EXPORT_DIR_CHANGEABLE` - 也导出，允许更改方向

由于 `GPIOF_INIT_*` 仅在配置为输出时有效，因此将有效组合分组为：

  - `GPIOF_IN` - 配置为输入
  - `GPIOF_OUT_INIT_LOW` - 配置为输出，初始级别低
  - `GPIOF_OUT_INIT_HIGH` - 配置为输出，初始级别高

当设置标志为 `GPIOF_OPEN_DRAIN` 时，它将假定引脚为开漏类型。在输出模式下，此类引脚不会驱动为 1。需要在此类引脚上连接上拉电阻。通过启用此标志，当在输出模式下要求将值设置为 1 以使引脚为高时，gpio 库将方向设置为输入。在输出模式下通过驱动值 0 将引脚设置为低。

当设置标志为 `GPIOF_OPEN_SOURCE` 时，它将假定引脚为开源类型。在输出模式下，此类引脚不会驱动为 0。需要在此引脚连接下拉电阻。通过启用此标志，当在输出模式下要求将值设置为 0 以使引脚为低时，gpio 库将方向设置为输入。在输出模式下通过驱动值 1 将引脚设置为高。

将来，这些标志可以扩展以支持更多属性。

此外，为了简化多个 GPIO 的请求/释放，引入 `struct gpio` 来封装所有三个字段：

```c
struct gpio {
    unsigned    gpio;
    unsigned long   flags;
    const char  *label;
};
```

一个典型的使用示例：

```c
static struct gpio leds_gpios[] = {
    { 32, GPIOF_OUT_INIT_HIGH, "Power LED" }, /* 默认打开 */
    { 33, GPIOF_OUT_INIT_LOW,  "Green LED" }, /* 默认关闭 */
    { 34, GPIOF_OUT_INIT_LOW,  "Red LED"   }, /* 默认关闭 */
    { 35, GPIOF_OUT_INIT_LOW,  "Blue LED"  }, /* 默认关闭 */
    {... },
};

err = gpio_request_one(31, GPIOF_IN, "Reset Button");
if (err)
   ...

err = gpio_request_array(leds_gpios, ARRAY_SIZE(leds_gpios));
if (err)
   ...

gpio_free_array(leds_gpios, ARRAY_SIZE(leds_gpios));
```

# GPIO 映射到 IRQ
--------------------

GPIO 编号是无符号整数；IRQ 编号也是。它们构成了两个逻辑上不同的命名空间（GPIO 0 不必使用 IRQ 0）。您可以使用以下调用在它们之间进行映射：

```c
/* 将 GPIO 编号映射到 IRQ 编号 */
int gpio_to_irq(unsigned gpio);

/* 将 IRQ 编号映射到 GPIO 编号（避免使用此） */
int irq_to_gpio(unsigned irq);
```

这些返回另一个命名空间中的相应编号，或者如果无法完成映射（例如，某些 GPIO 不能用作 IRQ）则返回负的 `errno` 代码。（使用未使用 `gpio_direction_input()` 设置为输入的 GPIO 编号或使用未最初来自 `gpio_to_irq()` 的 IRQ 编号是未经检查的错误。）

这两个映射调用预计的成本约为一次加法或减法。它们不允许睡眠。

从 `gpio_to_irq()` 返回的非错误值可以传递给 `request_irq()` 或 `free_irq()`。它们通常会由特定平台的初始化代码存储到平台设备的 IRQ 资源中。请注意，IRQ 触发选项是 IRQ 接口的一部分，例如 `IRQF_TRIGGER_FALLING`，系统唤醒功能也是如此。

从 `irq_to_gpio()` 返回的非错误值最常用于 `gpio_get_value()`，例如在 IRQ 为边沿触发时初始化或更新驱动程序状态。请注意，某些平台不支持此反向映射，因此应避免使用它。

# 模拟开漏信号
----------------------------

有时共享信号需要使用“开漏”信号，其中只有低信号电平实际被驱动。（该术语适用于 CMOS 晶体管；TTL 使用“开集电极”。）上拉电阻导致高信号电平。这有时称为“线与”；或者更实际地，从负逻辑（低 = 真）的角度来看，这是“线或”。

开漏信号的一个常见示例是共享的低电平有效 IRQ 线。此外，双向数据总线信号有时使用开漏信号。

一些 GPIO 控制器直接支持开漏输出；许多不支持。当您需要开漏信号但您的硬件不直接支持时，可以使用一个常见的惯用法，使用任何可以用作输入或输出的 GPIO 引脚来模拟它：

低：`gpio_direction_output(gpio, 0)`... 这驱动信号并覆盖上拉。

高：`gpio_direction_input(gpio)`... 这关闭输出，因此上拉（或其他设备）控制信号。

如果您“驱动”信号为高，但 `gpio_get_value(gpio)` 报告为低（在适当的上升时间过去后），您知道其他组件正在将共享信号驱动为低。这不一定是错误的。作为一个常见的例子，这就是 I2C 时钟拉伸的方式：需要较慢时钟的从设备延迟 SCK 的上升沿，I2C 主设备相应地调整其信号速率。

# GPIO 控制器和引脚控制子系统
------------------------------------------

SOC 上的 GPIO 控制器可能与引脚控制子系统紧密耦合，因为引脚可以与其他功能一起使用，并具有可选的 GPIO 功能。我们已经涵盖了例如 GPIO 控制器需要通过调用以下任何一个来保留引脚或设置引脚方向的情况：

`pinctrl_request_gpio()`
`pinctrl_free_gpio()`
`pinctrl_gpio_direction_input()`
`pinctrl_gpio_direction_output()`

但是引脚控制子系统如何将 GPIO 编号（这是全局事务）与特定引脚控制器上的特定引脚相互关联？

这是通过注册“引脚范围”来完成的，这些本质上是交叉引用表。这在 `Documentation/pinctrl.txt` 中有描述。

虽然引脚分配完全由引脚控制子系统管理，但 GPIO（在 gpiolib 下）仍然由 GPIO 驱动程序维护。可能会发生不同的 SOC 中的引脚范围由不同的 GPIO 驱动程序管理。

这使得在引脚控制子系统调用 `pinctrl_request_gpio` 之前，让 GPIO 驱动程序向引脚控制子系统宣布其引脚范围是合理的，以便在任何 GPIO 使用之前要求引脚控制子系统准备相应的引脚。

为此，GPIO 控制器可以使用 `gpiochip_add_pin_range()` 函数向引脚控制子系统注册一个 GPIO 引脚范围。目前有两种方法可以做到这一点：有或没有设备树。

对于有设备树支持，请参考 `Documentation/devicetree/bindings/gpio/gpio.txt`。

对于非设备树支持，用户可以使用适当的参数调用 `gpiochip_add_pin_range()` 向引脚控制子系统注册一个 GPIO 引脚范围。为此，必须将引脚控制设备的确切名称字符串作为此例程的参数之一传递。

# 这些约定省略了什么？
===============================

这些约定省略的最重要的事情之一是引脚复用，因为这高度依赖于芯片且不可移植。一个平台可能不需要显式的复用；另一个平台对于任何给定的引脚可能只有两个使用选项；还有的平台每个引脚可能有八个选项；另一些平台可能能够将给定的 GPIO 路由到几个引脚中的任何一个。（是的，这些例子都来自现今运行 Linux 的系统。）

与复用相关的是某些平台上集成的上拉或下拉的配置和启用。并非所有平台都支持它们，或者支持方式不同；并且任何给定的电路板可能使用外部的上拉（或下拉），因此不应使用片上的。（当电路需要 5 kOhm 时，片上 100 kOhm 电阻器是不行的。）同样，驱动强度（2 mA 与 20 mA）和电压（1.8V 与 3.3V）是特定于平台的问题，就像可配置引脚和 GPIO 之间是否具有一对一的对应关系等模型一样。

这里没有指定其他特定于系统的机制，例如前面提到的输入去抖动和线或输出的选项。硬件可能支持成组读写 GPIO，但这通常取决于配置：对于共享同一组的 GPIO。（GPIO 通常分组为 16 或 32 个，给定的 SOC 具有几个这样的组。）一些系统可以从输出 GPIO 触发 IRQ，或者从未被管理为 GPIO 的引脚读取值。依赖于此类机制的代码必然是不可移植的。

GPIO 的动态定义目前不是标准的；例如，作为配置带有某些 GPIO 扩展器的附加板的副作用。

# GPIO 实现者的框架（可选）
=======================================

如前所述，有一个可选的实现框架，使平台能够使用相同的编程接口支持不同类型的 GPIO 控制器更加容易。这个框架被称为“gpiolib”。

作为调试辅助，如果 debugfs 可用，在那里会找到一个 /sys/kernel/debug/gpio 文件。它将列出通过此框架注册的所有控制器，以及当前使用的 GPIO 的状态。

# 控制器驱动程序：gpio_chip
-----------------------------

在此框架中，每个 GPIO 控制器都被打包为一个“struct gpio_chip”，其中包含该类型的每个控制器共有的信息：

 - 用于确定 GPIO 方向的方法
 - 用于访问 GPIO 值的方法
 - 表示其方法的调用是否可能睡眠的标志
 - 可选的 debugfs 转储方法（显示诸如上拉配置等额外状态）
 - 用于诊断的标签

还有每个实例的数据，可能来自 device.platform_data：其第一个 GPIO 的编号，以及它暴露的 GPIO 数量。

实现 gpio_chip 的代码应该支持控制器的多个实例，可能使用驱动模型。该代码将配置每个 gpio_chip 并发出 gpiochip_add()。删除 GPIO 控制器的情况应该很少见；在不可避免的情况下使用 gpiochip_remove()。

通常，gpio_chip 是特定实例结构的一部分，其状态未通过 GPIO 接口暴露，例如寻址、电源管理等。诸如编解码器之类的芯片将具有复杂的非 GPIO 状态。

任何 debugfs 转储方法通常都应忽略尚未请求为 GPIO 的信号。它们可以使用 gpiochip_is_requested()，该函数返回 NULL 或请求该 GPIO 时关联的标签。

# 平台支持
----------------

要支持此框架，平台的 Kconfig 将“选择”ARCH_REQUIRE_GPIOLIB 或 ARCH_WANT_OPTIONAL_GPIOLIB，并安排其 <asm/gpio.h> 包含 <asm-generic/gpio.h> 并定义三个函数：gpio_get_value()、gpio_set_value() 和 gpio_cansleep()。

它还可以为 ARCH_NR_GPIOS 提供自定义值，以便更好地反映该平台实际使用的 GPIO 数量，而不会浪费静态表空间。（它应该计算内置/SOC GPIO 以及 GPIO 扩展器上的数量。）

ARCH_REQUIRE_GPIOLIB 意味着 gpiolib 代码将始终在该架构的内核中编译。

ARCH_WANT_OPTIONAL_GPIOLIB 意味着 gpiolib 代码默认关闭，用户可以启用并可选地将其构建到内核中。

如果这两个选项都未选择，则平台不通过 GPIO-lib 支持 GPIO，并且用户无法启用该代码。

这些函数的简单实现可以直接使用框架代码，该代码始终通过 gpio_chip 进行调度：

```c
#define gpio_get_value    __gpio_get_value
#define gpio_set_value    __gpio_set_value
#define gpio_cansleep     __gpio_cansleep
```

更高级的实现可以将这些定义为内联函数，其逻辑优化了对特定基于 SOC 的 GPIO 的访问。例如，如果引用的 GPIO 是常量“12”，获取或设置其值可能只需要两到三条指令，并且从不睡眠。当这种优化不可能时，这些调用必须委托给框架代码，成本至少为几十条指令。对于位敲击 I/O，这种指令节省可能很显著。

对于 SOC，特定于平台的代码为每个片上 GPIO 组定义并注册 gpio_chip 实例。这些 GPIO 应编号/标记以匹配芯片供应商文档，并直接匹配电路板原理图。它们很可能从 0 开始并达到平台特定的限制。这样的 GPIO 通常集成到平台初始化中，使其始终可用，从 arch_initcall() 或更早开始；它们经常可以用作 IRQ。

# 板级支持
-------------

对于外部 GPIO 控制器 - 如 I2C 或 SPI 扩展器、ASIC、多功能设备、FPGA 或 CPLD - 通常板级特定的代码处理控制器设备的注册，并确保其驱动程序知道使用 gpiochip_add() 时使用哪些 GPIO 编号。它们的编号通常在特定于平台的 GPIO 之后立即开始。

例如，板级设置代码可以创建标识该芯片将暴露的 GPIO 范围的结构，并使用 platform_data 将它们传递给每个 GPIO 扩展器芯片。然后芯片驱动程序的 probe() 例程可以将该数据传递给 gpiochip_add()。

初始化顺序可能很重要。例如，当一个设备依赖于基于 I2C 的 GPIO 时，其 probe() 例程应该仅在该 GPIO 可用后调用。这可能意味着在对该 GPIO 的调用可以工作之前，不应注册该设备。解决此类依赖关系的一种方法是让此类 gpio_chip 控制器向板级特定的代码提供 setup() 和 teardown() 回调；这些板级特定的回调将在所有必要的资源可用时注册设备，并在 GPIO 控制器设备不可用时将其删除。

# 用户空间的 Sysfs 接口（可选）
========================================

使用“gpiolib”实现者框架的平台可以选择配置一个到 GPIO 的 Sysfs 用户接口。这与 debugfs 接口不同，因为它提供了对 GPIO 方向和值的控制，而不仅仅是显示 GPIO 状态摘要。此外，它可以在没有调试支持的生产系统中存在。

如果有系统的适当硬件文档，用户空间可以知道例如 GPIO #23 控制用于保护闪存中引导加载程序段的写保护线。系统升级过程可能需要暂时删除该保护，首先导入 GPIO，然后更改其输出状态，然后在重新启用写保护之前更新代码。在正常使用中，GPIO #23 永远不会被触及，内核也不需要知道它。

同样，根据适当的硬件文档，在某些系统上，用户空间 GPIO 可用于确定标准内核不知道的系统配置数据。对于某些任务，简单的用户空间 GPIO 驱动程序可能就是系统真正需要的。

请注意，对于常见的“LED 和按钮”GPIO 任务，存在标准的内核驱动程序：分别为“leds-gpio”和“gpio_keys”。使用它们而不是直接与 GPIO 通信；它们与内核框架的集成比您的用户空间代码更好。

# Sysfs 中的路径
--------------

在 /sys/class/gpio 中有三种类型的条目：

 - 用于获取用户空间对 GPIO 控制的控制接口；

 - GPIO 本身；和

 - GPIO 控制器（“gpio_chip”实例）。

这除了包括“device”符号链接在内的标准文件之外。

控制接口是只写的：

    /sys/class/gpio/

    	“export”... 用户空间可以通过向此文件写入其编号来请求内核将 GPIO 的控制权导出到用户空间。

		示例：“echo 19 > export”将为 GPIO #19 创建一个“gpio19”节点，如果内核代码未请求。

    	“unexport”... 反转导出到用户空间的效果。

		示例：“echo 19 > unexport”将删除使用“export”文件导出的“gpio19”节点。

GPIO 信号的路径类似于 /sys/class/gpio/gpio42/（对于 GPIO #42），并具有以下读写属性：

    /sys/class/gpio/gpioN/

	“direction”... 读取为“in”或“out”。此值通常可以写入。写入为“out”默认为将值初始化为低。为确保无毛刺操作，可以写入“low”和“high”值将 GPIO 配置为具有该初始值的输出。

		请注意，如果内核不支持更改 GPIO 的方向，或者它是由未明确允许用户空间重新配置此 GPIO 方向的内核代码导出的，则此属性将不存在。

	“value”... 读取为 0（低）或 1（高）。如果 GPIO 配置为输出，则可以写入此值；任何非零值都被视为高。

		如果引脚可以配置为生成中断的中断，并且已配置为生成中断（请参阅“edge”的描述），则可以对此文件进行 poll(2)，并且每当触发中断时 poll(2) 将返回。如果使用 poll(2)，请设置事件 POLLPRI 和 POLLERR。如果使用 select(2)，请在 exceptfds 中设置文件描述符。poll(2) 返回后，可以 lseek(2) 到 sysfs 文件的开头并读取新值，或者关闭文件并重新打开它以读取值。

	“edge”... 读取为“none”、“rising”、“falling”或“both”。写入这些字符串以选择将使“value”文件上的 poll(2) 返回的信号边沿。

		此文件仅在引脚可以配置为生成中断的输入引脚时存在。

	“active_low”... 读取为 0（假）或 1（真）。写入任何非零值以反转读和写的“value”属性。对于“rising”和“falling”边沿，现有的和后续的 poll(2) 支持配置通过“edge”属性将遵循此设置。

GPIO 控制器的路径类似于 /sys/class/gpio/gpiochip42/（对于从 #42 开始实现 GPIO 的控制器），并具有以下只读属性：

    /sys/class/gpio/gpiochipN/

    	“base”... 与 N 相同，此芯片管理的第一个 GPIO

    	“label”... 提供用于诊断（不总是唯一的）

    	“ngpio”... 管理多少个 GPIO（N 到 N + ngpio - 1）

大多数情况下，板级文档应涵盖 GPIO 用于何种目的。但是，这些编号并不总是稳定的；子卡上的 GPIO 可能会根据所使用的基板或堆叠中的其他卡而有所不同。在这种情况下，您可能需要使用 gpiochip 节点（可能与原理图结合）来确定给定信号应使用的正确 GPIO 编号。

# 从内核代码导出
--------------------------

内核代码可以显式管理使用 gpio_request() 已经请求的 GPIO 的导出：

```c
/* 将 GPIO 导出到用户空间 */
int gpio_export(unsigned gpio, bool direction_may_change);

/* 反转 gpio_export() */
void gpio_unexport();

/* 创建到导出的 GPIO 节点的 sysfs 链接 */
int gpio_export_link(struct device *dev, const char *name,
                     unsigned gpio);

/* 在 sysfs 中更改 GPIO 节点的极性 */
int gpio_sysfs_set_active_low(unsigned gpio, int value);
```

在内核驱动程序请求 GPIO 后，只有通过 gpio_export() 才能在 sysfs 接口中提供。驱动程序可以控制信号方向是否可以更改。这有助于驱动程序防止用户空间代码意外破坏重要的系统状态。

这种显式导出有助于调试（通过使某些类型的实验更容易），或者可以提供一个始终存在的接口，适合作为板支持包的一部分进行记录。

在 GPIO 已导出后，gpio_export_link() 允许从 sysfs 中的其他位置创建到 GPIO sysfs 节点的符号链接。驱动程序可以使用此功能在其自己的 sysfs 设备下提供具有描述性名称的接口。

驱动程序可以使用 gpio_sysfs_set_active_low() 向用户空间隐藏不同板之间 GPIO 线路极性的差异。这仅影响 sysfs 接口。极性更改可以在 gpio_export() 之前和之后进行，并且之前为上升或下降边沿启用的 poll(2) 支持将重新配置以遵循此设置。
