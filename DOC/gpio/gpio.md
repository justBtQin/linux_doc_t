# GPIO 接口
===============

此目录中的文档详细说明了如何在驱动程序中访问 GPIO，以及如何为本身提供 GPIO 的设备编写驱动程序。

由于内核中 GPIO 接口的历史原因，有两种不同的获取和使用 GPIO 的方式：

  - 基于描述符的接口是操作 GPIO 的首选方式，此目录中除 `gpio-legacy.txt` 外的所有文件都对此进行了描述。
  - 被认为已弃用的传统基于整数的接口（但出于兼容性原因仍可使用）在 `gpio-legacy.txt` 中有记录。

本文档的其余部分适用于新的基于描述符的接口。`gpio-legacy.txt` 包含适用于传统基于整数接口的相同信息。

# 什么是 GPIO？
===============

“通用输入/输出”（GPIO）是一种灵活的软件控制数字信号。它们由多种芯片提供，对于从事嵌入式和定制硬件工作的 Linux 开发者来说很熟悉。每个 GPIO 代表连接到特定引脚或球栅阵列（BGA）封装上的“球”的一位。电路板原理图显示了哪些外部硬件连接到哪些 GPIO。驱动程序可以编写得通用，以便板级设置代码将此类引脚配置数据传递给驱动程序。

片上系统（SOC）处理器严重依赖 GPIO。在某些情况下，每个非专用引脚都可以配置为 GPIO；并且大多数芯片至少有几十个。可编程逻辑器件（如 FPGA）可以轻松提供 GPIO；多功能芯片，如电源管理器和音频编解码器，通常有几个这样的引脚来帮助解决 SOC 上的引脚短缺问题；还有使用 I2C 或 SPI 串行总线连接的“GPIO 扩展器”芯片。大多数 PC 南桥有几十个具有 GPIO 功能的引脚（只有 BIOS 固件知道如何使用它们）。

GPIO 的确切功能在不同系统之间有所不同。常见选项：

  - 输出值是可写的（高 = 1，低 = 0）。一些芯片还具有关于如何驱动该值的选项，例如可能只驱动一个值，支持“线或”和类似方案用于其他值（特别是“开漏”信号）。

  - 输入值同样是可读的（1，0）。一些芯片支持回读配置为“输出”的引脚的值，这在“线或”情况下非常有用（以支持双向信号）。GPIO 控制器可能具有输入去抖动/去跳变逻辑，有时具有软件控制。

  - 输入通常可以用作 IRQ 信号，通常是边沿触发，但有时是电平触发。此类 IRQ 可以配置为系统唤醒事件，以从低功耗状态唤醒系统。

  - 通常，根据不同的产品板，每个 GPIO 都可以根据需要配置为输入或输出；单向的也存在。

  - 大多数 GPIO 在持有自旋锁时可以访问，但通过串行总线访问的那些通常不能。一些系统支持两种类型。

在给定的板上，每个 GPIO 都用于一个特定目的，例如监视 MMC/SD 卡的插入/移除、检测卡写保护状态、驱动 LED、配置收发器、位敲击串行总线、触发硬件看门狗、检测开关等。

# 常见 GPIO 属性
======================

这些属性在 GPIO 接口的所有其他文档中都有体现，理解它们很有用，特别是在需要定义 GPIO 映射时。

# 高有效和低有效
--------------------------

很自然地认为，当 GPIO 的输出信号为 1（“高”）时，它是“有效”的，而当它为 0（“低”）时，它是无效的。然而，在实际中，GPIO 的信号在到达其目的地之前可能会被反转，或者设备可能会决定对“有效”的含义有不同的约定。这样的决定应该对设备驱动程序是透明的，因此可以将 GPIO 定义为高有效（“1”表示“有效”，默认）或低有效（“0”表示“有效”），这样驱动程序只需要关心逻辑信号，而不必关心线路级别发生的情况。

# 开漏和开源
--------------------------

有时共享信号需要使用“开漏”（其中只有低信号电平实际被驱动）或“开源”（其中只有高信号电平被驱动）信号。该术语适用于 CMOS 晶体管；TTL 使用“开集电极”。上拉或下拉电阻导致高或低信号电平。这有时称为“线与”；或者更实际地，从负逻辑（低 = 真）的角度来看，这是“线或”。

开漏信号的一个常见示例是共享的低电平有效 IRQ 线。此外，双向数据总线信号有时使用开漏信号。

一些 GPIO 控制器直接支持开漏和开源输出；许多不支持。当您需要开漏信号但您的硬件不直接支持时，可以使用任何可以用作输入或输出的 GPIO 引脚来模拟它：

低：`gpiod_direction_output(gpio, 0)`... 这驱动信号并覆盖上拉。

高：`gpiod_direction_input(gpio)`... 这关闭输出，因此上拉（或其他设备）控制信号。

同样的逻辑可以应用于模拟开源信号，通过驱动高信号并将 GPIO 配置为输入以获得低信号。这种开漏/开源模拟可以由 GPIO 框架透明地处理。

如果您“驱动”信号为高，但 `gpiod_get_value(gpio)` 报告为低（在适当的上升时间过去后），您知道其他组件正在将共享信号驱动为低。这不一定是错误的。作为一个常见的例子，这就是 I2C 时钟拉伸的方式：需要较慢时钟的从设备延迟 SCK 的上升沿，I2C 主设备相应地调整其信号速率。