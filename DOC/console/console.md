<markdown_document>

# Console Drivers

Linux 内核有两种通用类型的控制台驱动程序。第一种类型在引导过程中由内核分配给所有虚拟控制台。这种类型将被称为“系统驱动程序”，并且只允许存在一个系统驱动程序。系统驱动程序是持久的，永远不会被卸载，尽管它可能会变为不活动状态。

第二种类型必须显式地加载和卸载。本文档将其称为“模块化驱动程序”。多个模块化驱动程序可以随时共存，每个驱动程序与其他驱动程序（包括系统驱动程序）共享控制台。然而，模块化驱动程序不能接管当前由另一个模块化驱动程序占用的控制台。（例外：调用 do_take_over_console() 的驱动程序将成功接管，而不管占用控制台的驱动程序类型如何。）它们只能接管被系统驱动程序占用的控制台。同样地，如果模块化驱动程序被控制台释放，系统驱动程序将接管。

从程序员的角度来看，模块化驱动程序必须调用：

- do_take_over_console() - 加载并将驱动程序绑定到控制台层

- give_up_console() - 卸载驱动程序，只有在驱动程序完全解绑时才会起作用

在较新的内核中，还提供了以下内容：

- do_register_con_driver()

- do_unregister_con_driver()

如果启用了 sysfs，则可以检查 /sys/class/vtconsole 的内容。这显示了系统当前注册的控制台后端，它们被命名为 vtcon<n>，其中 <n> 是从 0 到 15 的整数。因此：

```
ls /sys/class/vtconsole
. ..  vtcon0  vtcon1
```

/sys/class/vtconsole 中的每个目录都有 3 个文件：[core.md](../cpu-freq/core.md)

```
ls /sys/class/vtconsole/vtcon0
. ..  bind  name  uevent
```

# 这些文件的含义是什么？

1. bind - 这是一个读写文件。读取时显示驱动程序的状态，写入时用于将驱动程序绑定或解绑到虚拟控制台。可能的值为：

    0 - 表示驱动程序未绑定，如果回显，则命令驱动程序解绑
    
    1 - 表示驱动程序已绑定，如果回显，则命令驱动程序绑定

2. name - 只读文件。以以下格式显示驱动程序的名称：

```
cat /sys/class/vtconsole/vtcon0/name
(S) VGA+
```

'(S)' 表示系统驱动程序，即不能直接命令其绑定或解绑

'VGA+' 是驱动程序的名称

```
cat /sys/class/vtconsole/vtcon1/name
(M) frame buffer device
```

在这种情况下，'(M)' 表示模块化驱动程序，即可以直接命令其绑定或解绑。

3. uevent - 忽略此文件

解绑时，首先分离模块化驱动程序，然后系统驱动程序接管驱动程序腾出的控制台。另一方面，绑定将把驱动程序绑定到当前由系统驱动程序占用的控制台。

注意 1：绑定和解绑必须在 Kconfig 中选择。它位于：

设备驱动程序 -> 字符设备 -> 支持绑定和解绑控制台驱动程序

注意 2：如果任何虚拟控制台处于 KD_GRAPHICS 模式，则绑定或解绑将不会成功。一个将控制台设置为 KD_GRAPHICS 的应用程序的示例是 X。

这个功能有多有用？这对于控制台驱动程序开发者非常有用。通过将驱动程序从控制台层解绑，开发者可以卸载驱动程序、进行更改、重新编译、重新加载并重新绑定驱动程序，而无需重新启动内核。对于可能希望从帧缓冲区控制台切换到 VGA 控制台或反之亦然的普通用户，此功能也使其成为可能。（注意注意注意：请阅读 Documentation/fb 下的 fbcon.txt 以获取更多详细信息）。

# 开发者注意事项：

=====================

do_take_over_console() 现在被分解为：

- do_register_con_driver()

- do_bind_con_driver() - 私有函数

give_up_console() 是 do_unregister_con_driver() 的包装器，驱动程序必须完全解绑才能使此调用成功。con_is_bound() 将检查驱动程序是否已绑定。

# 控制台驱动程序编写者指南：

=====================================

为了使绑定到控制台和从控制台解绑能够正常工作，控制台驱动程序必须遵循以下指南：

1. 除系统驱动程序外，所有驱动程序都必须调用 do_register_con_driver() 或 do_take_over_console()。do_register_con_driver() 只会将驱动程序添加到控制台的内部列表中。它不会接管控制台。do_take_over_console()，顾名思义，也将接管（或绑定到）控制台。

2. 在 con->con_init() 期间分配的所有资源都必须在 con->con_deinit() 中释放。

3. 在 con->con_startup() 中分配的所有资源都必须在之前绑定的驱动程序变为未绑定时释放。控制台层没有与 con->con_startup() 对应的调用，因此由驱动程序自行检查何时可以合法释放这些资源。在 con->con_deinit() 中调用 con_is_bound() 将有所帮助。如果调用返回 false()，则可以安全地释放资源。必须确保这种平衡，因为当请求将驱动程序重新绑定到控制台时，con->con_startup() 可能会再次被调用。

4. 在驱动程序退出时，确保驱动程序完全解绑。如果满足条件，则驱动程序必须调用 do_unregister_con_driver() 或 give_up_console()。

5. 当驱动程序无法处理控制台请求的情况发生时，也可以调用 do_unregister_con_driver()。这可能发生在帧缓冲区控制台突然失去所有驱动程序的情况下。

当前的控制台驱动程序集仍然可以正常工作，但绑定和解绑它们可能会导致问题。进行最小的修复后，这些驱动程序可以正常工作。

==========================

Antonino Daplas <adaplas@pol.net>
