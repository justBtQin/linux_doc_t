# 每个任务的统计接口

Taskstats 是一个基于 netlink 的接口，用于将每个任务和每个进程的统计信息从内核发送到用户空间。Taskstats 是为以下好处而设计的：

- 在任务的生命周期及其退出时高效地提供统计信息

- 多个计费子系统的统一接口

- 可扩展性，可供未来的计费补丁使用

## 术语

“pid”、“tid”和“task”可互换使用，指的是由`struct task_struct`定义的标准 Linux 任务。每个 pid 的统计信息与每个任务的统计信息相同。

“tgid”、“process”和“thread group”可互换使用，指的是共享`mm_struct`的任务，即传统的 Unix 进程。尽管使用了 tgid，但对于作为线程组领导者的任务并没有特殊处理——只要一个进程有任何属于它的任务，就认为它是活动的。

## 用法

要在任务的生命周期内获取统计信息，用户空间打开一个单播 netlink 套接字（NETLINK_GENERIC 家族）并发送指定 pid 或 tgid 的命令。响应包含一个任务的统计信息（如果指定了 pid）或该进程所有任务的统计信息总和（如果指定了 tgid）。

要获取正在退出的任务的统计信息，用户空间监听器发送一个注册命令并指定一个 cpumask。每当一个任务在 cpumask 中的一个 cpu 上退出时，其每个 pid 的统计信息将被发送到注册的监听器。使用 cpumasks 可以限制一个监听器接收的数据，并有助于控制 netlink 接口的流量，下面将更详细地解释。

如果退出的任务是其线程组中最后一个退出的线程，还会向用户空间发送一个包含每个 tgid 统计信息的额外记录。后者包含线程组中所有过去和现在的线程的每个 pid 统计信息的总和。

`getdelays.c`是一个简单的实用程序，演示了 taskstats 接口用于报告延迟计费统计信息的用法。用户可以注册 cpumasks、发送命令和处理响应、监听每个 tid/tgid 的退出数据、将接收到的数据写入文件，并通过增加接收缓冲区大小来进行基本的流量控制。

## 接口

用户 - 内核接口封装在`include/linux/taskstats.h`中

为了避免此文档随着接口的发展而过时，仅给出当前版本的概述。`taskstats.h`总是覆盖此处的描述。

`struct taskstats`是每个 pid 和每个 tgid 数据的通用计费结构。它是版本化的，可以由添加到内核的每个计费子系统扩展。字段及其语义在`taskstats.h`文件中定义。

用户和内核空间之间交换的数据是属于 NETLINK_GENERIC 家族并使用 netlink 属性接口的 netlink 消息。消息的格式如下：

```
    +----------+- - -+-------------+-------------------+
    | nlmsghdr | Pad |  genlmsghdr | taskstats payload |
    +----------+- - -+-------------+-------------------+
```

taskstats 有效负载是以下三种类型之一：

1. 命令：从用户发送到内核。获取关于 pid/tgid 数据的命令由一个属性组成，类型为`TASKSTATS_CMD_ATTR_PID/TGID`，属性有效负载中包含一个 u32 pid 或 tgid。pid/tgid 表示用户空间想要统计信息的任务/进程。

    注册/注销对一组 cpu 的退出数据的兴趣的命令由一个属性组成，类型为`TASKSTATS_CMD_ATTR_REGISTER/DEREGISTER_CPUMASK`，并在属性有效负载中包含一个 cpumask。cpumask 被指定为逗号分隔的 cpu 范围的 ascii 字符串，例如，要监听来自 cpu 1、2、3、5、7、8 的退出数据，cpumask 将是“1-3,5,7-8”。如果用户空间在关闭监听套接字之前忘记注销对 cpu 的兴趣，内核将随着时间清理其兴趣集。然而，为了提高效率，建议进行显式注销。

2. 对命令的响应：从内核发送以响应用户空间的命令。有效负载是一系列三个属性，类型为：

    a) `TASKSTATS_TYPE_AGGR_PID/TGID`：包含无有效负载的属性，但表示将跟随某个 pid/tgid 的统计信息。

    b) `TASKSTATS_TYPE_PID/TGID`：属性，其有效负载是正在返回其统计信息的 pid/tgid。

    c) `TASKSTATS_TYPE_STATS`：属性，其有效负载是`struct taskstats`。相同的结构用于每个 pid 和每个 tgid 的统计信息。

3. 每当一个任务退出时，内核发送的新消息。有效负载由以下类型的一系列属性组成：

    a) `TASKSTATS_TYPE_AGGR_PID`：表示接下来的两个属性将是 pid+统计信息

    b) `TASKSTATS_TYPE_PID`：包含退出任务的 pid

    c) `TASKSTATS_TYPE_STATS`：包含退出任务的每个 pid 统计信息

    d) `TASKSTATS_TYPE_AGGR_TGID`：表示接下来的两个属性将是 tgid+统计信息

    e) `TASKSTATS_TYPE_TGID`：包含任务所属进程的 tgid

    f) `TASKSTATS_TYPE_STATS`：包含退出任务的进程的每个 tgid 统计信息

## 每个 tgid 的统计信息

Taskstats 除了提供每个任务的统计信息外，还提供每个进程的统计信息，因为资源管理通常是在进程粒度上进行的，仅在用户空间聚合任务统计信息是低效的，并且可能不准确（由于缺乏原子性）。

然而，在内核中维护每个进程以及每个任务的统计信息会有空间和时间开销。为了解决这个问题，taskstats 代码将每个退出任务的统计信息累积到一个进程范围的数据结构中。当一个进程的最后一个任务退出时，累积的进程级数据也将被发送到用户空间（连同每个任务的数据）。

当用户查询以获取每个 tgid 的数据时，将添加该组中所有其他活动线程的总和，并将其添加到同一线程组中先前退出线程的累积总数中。

## 扩展 taskstats

有两种方法可以扩展 taskstats 接口，以在将来将更多的每个任务/进程统计信息作为补丁导出到内核中：

    1. 在现有的`struct taskstats`末尾添加更多字段。通过结构中的版本号确保向后兼容性。用户空间将只使用与其使用的版本相对应的结构字段。

    2. 定义单独的统计结构，并使用 netlink 属性接口返回它们。由于用户空间独立处理每个 netlink 属性，它总是可以忽略其类型不理解的属性（因为它正在使用接口的较旧版本）。

在 1. 和 2. 之间进行选择是在灵活性和开销之间进行权衡的问题。如果只需要添加几个字段，那么 1. 是更可取的路径，因为内核和用户空间不需要承担处理新 netlink 属性的开销。但是，如果新字段过度扩展了现有结构，需要不同的用户空间计费实用程序不必要地接收其字段不感兴趣的大型结构，那么扩展属性结构将是值得的。

## taskstats 的流量控制

当任务退出的速率变大时，监听器可能无法跟上内核发送每个 tid/tgid 退出数据的速率，导致数据丢失。当 taskstats 结构扩展并且 cpu 数量增加时，这种可能性会加剧。

为了避免丢失统计信息，用户空间应该执行以下一项或多项操作：

- 增加监听器打开的用于接收退出数据的 netlink 套接字的接收缓冲区大小。

- 创建更多的监听器，并减少每个监听器监听的 cpu 数量。在极端情况下，每个 cpu 可以有一个监听器。用户还可以考虑将监听器的 cpu 亲和性设置为它监听的 cpu 的子集，特别是如果它们只监听一个 cpu。以下是转换后的 Markdown 格式：

尽管采取了这些措施，如果用户空间接收到`ENOBUFS`错误消息，表明接收缓冲区溢出，它应该采取措施来处理数据丢失。