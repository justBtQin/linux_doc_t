# 无 Open Firmware 情况下引导 Linux/ppc 内核
--------------------------------------------------

（c）2005 Benjamin Herrenschmidt <benh at kernel.crashing.org>，IBM 公司
（c）2005 Becky Bruce <becky.bruce at freescale.com>，飞思卡尔半导体，FSL SOC 和 32 位补充
（c）2006 MontaVista 软件公司
    闪存芯片节点定义

**目录**
=================

  一、引言
    1. arch/arm 的入口点
    2. arch/powerpc 的入口点
    3. arch/x86 的入口点
    4. arch/mips/bmips 的入口点

  二、DT 块格式
    1. 头部
    2. 设备树概述
    3. 设备树“结构”块
    4. 设备树“字符串”块

  三、设备树的必需内容
    1. 关于单元和地址表示的说明
    2. 关于“兼容”属性的说明
    3. 关于“名称”属性的说明
    4. 关于节点和属性名称及字符集的说明
    5. 必需的节点和属性
      a. 根节点
      b. /cpus 节点
      c. /cpus/* 节点
      d. /memory 节点
      e. /chosen 节点
      f. /soc<SOCname> 节点

  四、“dtc”，设备树编译器

  五、引导加载程序的建议

  六、片上系统设备和节点
    1. 定义 SOC 的子节点
    2. 表示没有当前 OF 规范的设备

  七、为设备指定中断信息
    1. interrupts 属性
    2. interrupt-parent 属性
    3. OpenPIC 中断控制器
    4. ISA 中断控制器

  八、指定设备电源管理信息（sleep 属性）

  九、指定 dma 总线信息

  附录 A - MPC8540 的示例 SOC 节点


**修订信息**
====================

   2005 年 5 月 18 日：修订 0.1 - 初始草案，尚无第三章。

   2005 年 5 月 19 日：修订 0.2 - 添加第三章，并指出很多内容是可选的，内核仅需要非常小的设备树，但鼓励提供尽可能完整的设备树。

   2005 年 5 月 24 日：修订 0.3 - 明确 DT 块必须在 RAM 中
			 - 杂项修复
			 - 定义版本 3 和新格式版本 16
			   对于 DT 块（版本 16 需要内核
			   补丁，将另行转发）。
			   字符串块现在有大小，并且完整路径
			   被单元名称替换以更紧凑。
			   linux,phandle 变为可选，只有被其他节点引用的节点需要它。
			   “名称”属性现在自动
			   从单元名称推导

   2005 年 6 月 1 日：修订 0.4 - 纠正结构定义中 OF_DT_END 和
                           OF_DT_END_NODE 的混淆。
                         - 将版本 16 格式更改为始终将
                           属性数据对齐到 4 字节。由于令牌已经
                           对齐，这意味着属性大小和属性数据之间
                           没有特定的要求对齐。旧的可变对齐方式将使
                           使用 memmove 进行“简单”的属性插入变得不可能
                           （感谢 Milton 注意到）。也更新了内核补丁
			 - 纠正更多的对齐约束
			 - 添加关于设备树编译器和
                           可以由 dtc“编译”的树的文本表示的章节。

   2005 年 11 月 21 日：修订 0.5
			 - 添加 32 位的内容
			 - 更改以反映新的 arch/powerpc
			   结构
			 - 添加第六章


**待办事项**：
    - 添加一些中断树（简单/复杂）的定义
    - 添加一些 PCI 主机桥的定义
    - 添加一些常见地址格式示例
    - 添加尚未由现有
      OF 规范定义的标准属性和“兼容”
      名称的单元格的定义。
    - 比较 FSL SOC 对 PCI 的使用与标准并确保不需要新的
      节点定义。
    - 添加有关当前没有标准的 SOC 设备（如 FSL CPM）的节点定义的更多信息
  


**一、引言**
================

在 Linux/ppc64 内核的开发过程中，特别是在添加旧的 IBM pSeries/iSeries 对之外的新平台类型时，决定对内核入口和引导加载程序<->内核接口实施一些严格的规则，以避免 ppc32 内核入口点出现的退化情况以及添加新平台到内核的方式。传统的 iSeries 平台由于早于此方案而违反了这些规则，但不符合这些规则的新主板支持将不会被主树接受。此外，自从 ppc32 和 ppc64 的 arch/powerpc 合并架构出现以来，新的 32 位平台和进入 arch/powerpc 的 32 位平台也将被要求使用这些规则。

下面将更详细定义的主要要求是存在一个遵循 Open Firmware 规范定义格式的设备树。然而，为了方便嵌入式主板供应商，内核不要求设备树表示系统中的每个设备，只要求存在一些节点和属性。这将在第三章详细描述，但例如，内核不要求为系统中的每个 PCI 设备创建一个节点。为 PCI 主机桥创建一个节点以提供中断路由信息和内存/IO 范围等是必需的。还建议为不符合现有 OF 规范的片上设备和其他总线定义节点。这为内核探测这些设备并将驱动程序与设备匹配提供了极大的灵活性，无需对各种表格进行硬编码。这也使主板供应商在进行轻微硬件升级时更加灵活，而不会对内核代码产生重大影响或使其混乱。


1. arch/arm 的入口点
---------------------------

   内核有一个单一的入口点，位于内核映像的开头。该入口点支持两种调用约定。接口的总结在此描述。引导要求的完整描述记录在 Documentation/arm/Booting 中。

        a) ATAGS 接口。从固件到内核传递带有预定义参数的标记列表的最少信息。

                r0 : 0

                r1 : 机器类型编号

                r2 : 系统 RAM 中标记列表的物理地址

        b) 带有扁平设备树块的入口。固件将扁平设备树块（dtb）的物理地址加载到 r2 中，r1 未使用，但使用有效的机器编号（如 Documentation/arm/Booting 中所述）被认为是良好的实践。

                r0 : 0

                r1 : 有效的机器类型编号。使用设备树时，通常会分配一个单一的机器类型编号来代表 SoC 的一类或一个系列。

                r2 : RAM 中设备树块（在第二章中定义）的物理指针。设备树可以位于系统 RAM 中的任何位置，但应在 64 位边界上对齐。

   内核将通过读取 r2 指向的内存并查找扁平设备树块的魔数值（0xd00dfeed）或 r2 偏移 0x4 处的 ATAG_CORE 值（0x54410001）来区分 ATAGS 和设备树引导。

2. arch/powerpc 的入口点
-------------------------------

   内核有一个单一的入口点，位于内核映像的开头。该入口点支持两种调用约定：

        a) 从 Open Firmware 引导。如果您的固件与 Open Firmware（IEEE 1275）兼容或提供 OF 兼容的客户端接口 API（不要求支持 forth 词的“interpret”回调），您可以通过以下方式进入内核：

              r5 : IEEE 1275 定义的 Open Firmware 回调指针
              r3, r4 : 如果有，initrd 的地址和长度，否则为 0

              MMU 可以处于开启或关闭状态；内核将运行 arch/powerpc/kernel/prom_init.c 中的跳板代码，从 Open Firmware 中提取设备树和其他信息，并构建如 b) 中所述的扁平设备树。prom_init() 然后将使用第二种方法重新进入内核。此跳板代码在固件的上下文中运行，固件应在此期间处理所有异常。

        b) 直接使用扁平设备树块入口。此入口点在 a) 中的 OF 跳板之后被调用，也可以由不支持 Open Firmware 客户端接口的引导加载程序直接调用。它也被“kexec”用于从先前运行的内核实现“热”引导新内核。此方法将在本文档中更详细地描述，因为方法 a) 只是标准的 Open Firmware，因此应根据定义它的各种标准文档及其与 PowerPC 平台的绑定来实现。入口点定义如下：

                r3 : RAM 中设备树块的物理指针（在第二章中定义）

                r4 : 内核本身的物理指针。这由汇编代码用于在您以启用 MMU 和非 1:1 映射的方式进入内核时正确禁用 MMU。

                r5 : NULL（以与方法 a) 区分）

        关于 SMP 入口的注意事项：您的固件可以将其他 CPU 置于 ROM 中的某些睡眠循环或自旋循环中，您可以通过软复位或其他方式将它们唤醒，在这种情况下，您无需关心，或者您必须与所有 CPU 一起进入内核。使用方法 b) 实现此操作的方法将在本文档的后续修订版中描述。

   主板支持（平台）不是排他性的配置选项。单个内核映像可以构建任意一组主板支持。内核将根据设备树的内容“知道”为给定平台使用哪组功能。因此，您应该：

        a) 在 arch/powerpc/Kconfig 中按照 PPC_PSERIES、PPC_PMAC 和 PPC_MAPLE 的示例将您的平台支持添加为_布尔_选项。PPC_MAPLE 可能是一个很好的起始示例。

        b) 创建您的主要平台文件为“arch/powerpc/platforms/myplatform/myboard_setup.c”，并在您的 CONFIG_选项的条件下将其添加到 Makefile 中。此文件将定义一个“ppc_md”类型的结构，其中包含通用代码将用于获取您的平台特定代码的各种回调。

  内核映像可以支持多个平台，但仅当平台具有相同的核心架构时。单个内核构建不能同时支持具有 Book E 的配置和具有经典 Powerpc 架构的配置。

3. arch/x86 的入口点
-------------------------------

  内核有一个单一的 32 位入口点位于 code32_start，解压缩器（实模式入口点在切换到保护模式后也会进入此 32 位入口点）。该入口点支持一种调用约定，记录在 Documentation/x86/boot.txt 中
  指向设备树块（在第二章中定义）的物理指针通过 setup_data 传递，至少需要引导协议 2.09。类型字段定义为

  #define SETUP_DTB                      2

  此设备树用作“引导页”的扩展。因此，它不会解析/考虑已经由引导页涵盖的数据。这包括内存大小、保留范围、命令行参数或 initrd 地址。它仅保存无法以其他方式检索的信息，如中断路由或 I2C 总线后面的设备列表。

4. arch/mips/bmips 的入口点
----------------------------------

  一些引导加载程序仅支持在内核映像开头的单个入口点。其他引导加载程序将跳转到 ELF 起始地址。两种方案都支持；CONFIG_BOOT_RAW=y 和 CONFIG_NO_EXCEPT_FILL=y，因此第一个指令立即跳转到 kernel_entry()。

  类似于 arch/arm 情况（b），一个支持 DT 的引导加载程序应设置以下寄存器：

         a0 : 0

         a1 : 0xffffffff

         a2 : RAM 中设备树块（在第二章中定义）的物理指针。设备树可以位于物理地址空间的前 512MB 中的任何位置（0x00000000 - 0x1fffffff），在 64 位边界上对齐。

  传统引导加载程序不使用此约定，并且它们不会传递 DT 块。在这种情况下，Linux 将查找内置的 DTB，通过 CONFIG_DT_* 选择。

  此约定仅针对 32 位系统定义，因为目前没有 64 位 BMIPS 实现。

**二、DT 块格式**
========================

本章定义传递给内核的扁平设备树的实际格式。其实际内容和内核要求将在后面描述。您可以在多个地方找到处理该格式的代码示例，包括 arch/powerpc/kernel/prom_init.c（它将从 Open Firmware 表示生成扁平设备树）或作为 kexec 工具一部分的 fs2dt 实用程序（它将从文件系统表示生成一个）。预计像 uboot 这样的引导加载程序将提供更多支持，这也将在后面讨论。

注意：块必须在主内存中。它必须在实模式和虚拟模式下都可访问，除了主内存外没有其他映射。如果您正在编写一个简单的闪存引导加载程序，在将其传递给内核之前，应该将该块复制到 RAM 中。

1. 头部
---------

内核接收指向内存区域的物理地址，该区域在`include/linux/of_fdt.h`中由`boot_param_header`结构大致描述：

```c
struct boot_param_header {
        u32     magic;                  /* 魔数值 OF_DT_HEADER */
        u32     totalsize;              /* DT 块的总大小 */
        u32     off_dt_struct;          /* 到“结构”的偏移 */
        u32     off_dt_strings;         /* 到字符串的偏移 */
        u32     off_mem_rsvmap;         /* 到内存保留映射的偏移 */
        u32     version;                /* 格式版本 */
        u32     last_comp_version;      /* 最后兼容版本 */

        /* 版本 2 字段如下 */
        u32     boot_cpuid_phys;        /* 正在调用内核入口点的物理 CPU ID */

        /* 版本 3 字段如下 */
        u32     size_dt_strings;        /* 字符串块的大小 */

        /* 版本 17 字段如下 */
        u32     size_dt_struct;         /* DT 结构块的大小 */
};
```

以及常量：

```c
/* 用于扁平设备树的定义 */
#define OF_DT_HEADER            0xd00dfeed      /* 4: 版本，4: 总大小 */
#define OF_DT_BEGIN_NODE        0x1             /* 开始节点：全名 */
#define OF_DT_END_NODE          0x2             /* 结束节点 */
#define OF_DT_PROP              0x3             /* 属性：名称偏移，大小，内容 */
#define OF_DT_END               0x9
```

此头部中的所有值均为大端格式，下面更精确地定义了此头部中的各个字段。所有“偏移”值均从头部的开头（即设备树块的物理基地址）以字节为单位。

  - `magic`

    这是一个魔数值，“标记”设备树块头部的开始。它包含值 0xd00dfeed，由常量`OF_DT_HEADER`定义

  - `totalsize`

    这是包括头部在内的 DT 块的总大小。“DT”块应包含本章中定义的所有数据结构（由此头部中的偏移量指向）。即，设备树结构、字符串和内存保留映射。

  - `off_dt_struct`

    这是从头部开头到设备树“结构”部分的偏移（见 2）设备树）

  - `off_dt_strings`

    这是从头部开头到设备树“字符串”部分的偏移

  - `off_mem_rsvmap`

    这是从头部开头到保留内存映射的偏移。此映射是 64 位整数对的列表。每个对都是物理地址和大小。列表以大小为 0 的条目结束。此映射为内核提供了一个物理内存区域的列表，这些区域是“保留”的，因此不能用于内存分配，特别是在早期初始化期间。内核在引导期间需要为诸如展开设备树、分配 MMU 哈希表等事情分配内存......这些分配必须以避免覆盖关键事物，例如，在支持 Open Firmware 的机器上，RTAS 实例，或在某些 pSeries 上，用于 iommu 的 TCE 表。通常，保留映射应至少包含此 DT 块本身（头部，总大小）。如果您将 initrd 传递给内核，也应将其保留。您不需要保留内核映像本身。映射应 64 位对齐。

  - `version`

    这是此结构的版本。版本 1 到此为止。版本 2 添加了一个额外的字段`boot_cpuid_phys`。版本 3 添加了字符串块的大小，允许内核在引导时轻松重新分配并在扩展后释放未使用的扁平结构。版本 16 引入了一种新的更“紧凑”的树格式，但不向后兼容。版本 17 添加了一个额外的字段，`size_dt_struct`，允许更轻松地重新分配或移动（这对于需要根据探测信息对设备树进行调整的引导加载程序特别有用）。您应该始终生成在您实现时定义的最高版本的结构。当前是版本 17，除非您明确旨在向后兼容。

  - `last_comp_version`

    最后兼容版本。这表示您对 DT 块的向后兼容版本。例如，版本 2 与版本 1 向后兼容（即，为版本 1 构建的内核能够使用版本 2 格式引导）。如果您生成版本 1 至 3 的设备树，则应在此字段中放入 1，如果生成使用新单元名称格式的版本 16 或 17 的树，则应放入 16。

  - `boot_cpuid_phys`

    此字段仅存在于版本 2 的头部中。它指示正在调用内核入口点的物理 CPU ID。这在诸如`kexec`等情况下使用。如果您处于 SMP 系统中，此值应与设备树中对应于调用内核入口点的 CPU 节点的“reg”属性的内容相匹配（有关所需设备树内容的更多信息，请参见后续章节）

  - `size_dt_strings`

    此字段仅存在于版本 3 及更高版本的头部中。它给出了设备树的“字符串”部分的大小（其从`off_dt_strings`给出的偏移开始）。

  - `size_dt_struct`

    此字段仅存在于版本 17 及更高版本的头部中。它给出了设备树的“结构”部分的大小（其从`off_dt_struct`给出的偏移开始）。

所以 DT 块的典型布局（尽管各个部分不一定按此顺序）如下所示（地址从上到下）：

```
             ------------------------------
     base -> |  struct boot_param_header  |
             ------------------------------
             |      (alignment gap) (*)   |
             ------------------------------
             |      memory reserve map    |
             ------------------------------
             |      (alignment gap)       |
             ------------------------------
             |                            |
             |    device-tree structure   |
             |                            |
             ------------------------------
             |      (alignment gap)       |
             ------------------------------
             |                            |
             |     device-tree strings    |
             |                            |
      -----> ------------------------------
      |
      |
      --- (base + totalsize)

  (*) 对齐间隙不一定存在；它们的存在和大小取决于各个数据块的各种对齐要求。
```

2. 设备树概述
---------------------------

此设备树本身分为两个不同的块，一个结构块和一个字符串块。两者都需要对齐到 4 字节边界。

首先，在详细介绍存储格式之前，让我们快速描述一下设备树的概念。本章不描述内核所需的节点和属性的类型的细节，这将在第三章中完成。

设备树布局强烈继承自 Open Firmware IEEE 1275 设备树的定义。它基本上是一个节点树，每个节点具有两个或更多个命名属性。属性可以有值或没有值。

它是一棵树，因此除了没有父节点的根节点外，每个节点都有且只有一个父节点。

一个节点有两个名称。实际节点名称通常包含在节点属性列表中类型为“name”的属性中，其值为以零结尾的字符串，并且对于格式定义的版本 1 至 3 是必需的（就像在 Open Firmware 中一样）。版本 16 使其成为可选的，因为它可以从下面定义的单元名称生成。

还有一个“单元名称”，用于区分同一级别具有相同名称的节点，它通常由节点名称、“@”符号和“单元地址”组成，其定义特定于节点所在的总线类型。

单元名称本身不作为属性存在，但包含在设备树结构中。它通常用于表示设备树中的“路径”。关于这些的实际格式的更多细节将在下面给出。

内核通用代码没有正式使用单元地址（尽管一些主板支持代码可能会使用），因此对于单元地址的唯一真正要求是确保树的给定级别上节点单元名称的唯一性。没有地址概念且没有同名同级兄弟节点（如`/memory`或`/cpus`）的节点在本规范的上下文中可以省略单元地址，或者使用“@0”默认单元地址。单元名称用于定义节点的“完整路径”，它是所有父节点单元名称用“/”分隔的串联。

根节点没有定义的名称，如果您使用版本 3 或更早的格式，也不需要具有“name”属性。它也没有单元地址（没有后跟单元地址的“@”符号）。根节点的单元名称因此是空字符串。根节点的完整路径是“/”。

每个实际代表实际设备的节点（即，不像“/cpus”那样仅是更多节点的虚拟“容器”的节点）还需要具有“compatible”属性，指示特定的硬件和可选的与其完全向后兼容的设备列表。

最后，每个可以从另一个节点的属性中引用的节点都需要具有“phandle”或“linux,phandle”属性。真正的 Open Firmware 实现为每个节点提供唯一的“phandle”值，“prom_init()”跳板代码将其转换为“linux,phandle”属性。然而，如果直接使用扁平设备树，则此属性变为可选。通过“phandle”引用另一个节点的节点的示例是在布置中断树时，这将在本文档的后续版本中描述。

“phandle”属性是一个 32 位值，唯一标识一个节点。您可以自由使用任何值或值系统、内部指针或任何东西来生成这些值，唯一的要求是为其提供该属性的每个节点都具有唯一的值。

这是一个简单设备树的示例。在这个示例中，“o”表示后跟节点单元名称的节点。属性与其名称和内容一起呈现。“content”表示 ASCII 字符串（以零结尾）值，而`<content>`表示 32 位值，以十进制或十六进制指定（后者前缀为 0x）。此示例中的各个节点将在后面的章节中讨论。此时，它仅旨在让您了解设备树的外观。我故意保留了“name”和“linux,phandle”属性，这些在实践中并非必需，以便让您更好地了解树的实际外观。

  `/ o device-tree`
      |- `name = "device-tree"`
      |- `model = "MyBoardName"`
      |- `compatible = "MyBoardFamilyName"`
      |- `#address-cells = <2>`
      |- `#size-cells = <2>`
      |- `linux,phandle = <0>`
      |
      `o cpus`
      | | - `name = "cpus"`
      | | - `linux,phandle = <1>`
      | | - `#address-cells = <1>`
      | | - `#size-cells = <0>`
      | |
      | `o PowerPC,970@0`
      |   |- `name = "PowerPC,970"`
      |   |- `device_type = "cpu"`
      |   |- `reg = <0>`
      |   |- `clock-frequency = <0x5f5e1000>`
      |   |- `64-bit`
      |   |- `linux,phandle = <2>`
      |
      `o memory@0`
      | |- `name = "memory"`
      | |- `device_type = "memory"`
      | |- `reg = <0x00000000 0x00000000 0x00000000 0x20000000>`
      | |- `linux,phandle = <3>`
      |
      `o chosen`
        |- `name = "chosen"`
        |- `bootargs = "root=/dev/sda2"`
        |- `linux,phandle = <4>`

此树几乎是最小的树。它几乎包含了引导 Linux 内核所需的最小节点和属性集；也就是说，根节点处的一些基本模型信息、CPU 和物理内存布局。它还包括通过`/chosen`传递的杂项信息，例如在此示例中，平台类型（必需）和内核命令行参数（可选）。

`/cpus/PowerPC,970@0/64-bit`属性是一个没有值的属性的示例。所有其他属性都有值。`#address-cells`和`#size-cells`属性的意义将在第四章中解释，该章精确地定义了所需的节点和属性及其内容。

3. 设备树“结构”块

设备树的结构是一个线性化的树结构。“OF_DT_BEGIN_NODE”令牌启动一个新节点，“OF_DT_END_NODE”结束该节点定义。子节点简单地在“OF_DT_END_NODE”之前定义（即在节点内的节点）。“令牌”是一个 32 位值。树必须以“OF_DT_END”令牌“完成”

这是单个节点的基本结构：

  - 令牌`OF_DT_BEGIN_NODE`（即 0x00000001）
  - 对于版本 1 至 3，这是作为以零结尾的字符串的节点完整路径，以“/”开头。对于版本 16 及更高版本，这仅是节点单元名称（对于根节点为空字符串）
  - [对齐到下一个 4 字节边界的间隙]
  - 对于每个属性：
     - 令牌`OF_DT_PROP`（即 0x00000003）
     - 属性值大小的 32 位值（以字节为单位，如果没有值则为 0）
     - 字符串块中属性名称的 32 位偏移
     - 属性值数据（如果有）
     - [对齐到下一个 4 字节边界的间隙]
  - [如果有子节点]
  - 令牌`OF_DT_END_NODE`（即 0x00000002）

因此，节点内容可以概括为起始令牌、完整路径、属性列表、子节点列表和结束令牌。每个子节点本身都是如上定义的完整节点结构。

注意：上述定义要求特定节点的所有属性定义必须先于该节点的任何子节点定义。尽管如果属性和子节点混合在一起结构不会模糊，但内核解析器要求属性首先出现（至少在 2.6.22 之前）。任何处理扁平树的工具都必须注意保留此约束。

4. 设备树“字符串”块

为了节省空间，通常冗余的属性名称单独存储在“字符串”块中。此块只是所有属性名称的零结尾字符串的串联。结构块中的设备树属性定义将包含从字符串块开头的偏移值。

**三、设备树的必需内容**
=========================================

警告：本文档中定义的所有“linux,*”属性仅适用于扁平设备树。如果您的平台使用真正的 Open Firmware 实现或与 Open Firmware 客户端接口兼容的实现，则这些属性将由内核的`prom_init()`文件中的跳板代码创建。例如，这就是您必须添加代码以检测您的主板型号并设置平台编号的地方。但是，当使用扁平设备树入口点时，没有`prom_init()`传递，因此您必须自己提供这些属性。

## 1. 关于单元和地址表示的说明
----------------------------------------------

一般规则记录在各种 Open Firmware 文档中。如果您选择使用设备树描述总线并且存在 OF 总线绑定，则应遵循该规范。但是，内核不要求设备树描述每个设备或总线。

一般来说，设备的地址格式由父总线类型定义，基于`#address-cells`和`#size-cells`属性。请注意，`#address-cells`和`#size-cells`的父节点的父节点定义不会被继承，因此每个具有子节点的节点都必须指定它们。内核要求根节点具有这些属性，用于定义直接映射到处理器总线的设备的地址格式。

这两个属性定义了表示地址和大小的“单元”。“单元”是一个 32 位数字。例如，如果两者都包含 2，如上面给出的示例树，则地址和大小都由 2 个单元组成，每个都是 64 位数字（单元串联并且预期为大端格式）。另一个例子是 Apple 固件定义它们的方式，地址为 2 个单元，大小为 1 个单元。大多数 32 位实现应将`#address-cells`和`#size-cells`定义为 1，这表示 32 位值。一些 32 位处理器允许物理地址大于 32 位；这些处理器应将`#address-cells`定义为 2。

“reg”属性始终是“地址 大小”类型的元组，其中地址和大小的单元数量由总线的`#address-cells`和`#size-cells`指定。当总线支持与给定地址分配相关的各种地址空间和其他标志（如预取等）时，这些标志通常添加到物理地址的顶级位。例如，PCI 物理地址由 3 个单元组成，底部两个包含实际地址本身，而顶部单元包含地址空间指示、标志和 pci 总线和设备编号。

对于支持动态分配的总线，通常的做法是在“reg”中不提供地址（保持为 0），同时提供一个指示地址是动态分配的标志，然后提供一个单独的“assigned-addresses”属性，其中包含完全分配的地址。有关详细信息，请参阅 PCI OF 绑定。

一般来说，如果能反映您的硬件情况，没有地址空间位且没有动态分配的简单总线是首选，因为现有的内核地址解析函数可以直接使用。如果您定义的总线类型具有更复杂的地址格式，包括地址空间位等，您就必须为您的总线类型在最新内核的 `prom_parse.c` 文件中添加一个总线转换器。

“`reg`”属性仅在给定的总线内定义地址和大小（如果“`#size-cells`”不为 0）。为了向上转换地址（即转换为父总线地址，可能转换为 CPU 物理地址），所有总线都必须包含一个“`ranges`”属性。如果在给定级别上“`ranges`”属性缺失，则假定无法进行转换，即寄存器在父总线上不可见。总线的“`ranges`”属性的格式是一个列表：

    bus address, parent bus address, size

“bus address” 是此总线节点定义的总线格式，例如，对于 PCI 桥，它将是一个 PCI 地址。因此，（总线地址，大小）为子设备定义了一个地址范围。“父总线地址”是此总线的父总线的格式。例如，对于 PCI 主机控制器，那将是一个 CPU 地址。对于 PCI<->ISA 桥，那将是一个 PCI 地址。它定义了该范围在父总线上映射的起始基地址。

对于新的 64 位主板支持，我建议使用 2/2 格式或 Apple 的 2/1 格式，因为大小通常适合单个 32 位字，所以 2/1 格式稍微更紧凑。

## 2. 关于“compatible”属性的说明
这些属性是可选的，但在设备和根节点中建议使用。“compatible”属性的格式是串联的以零结尾的字符串列表。它们允许设备表达其与类似设备系列的兼容性，在某些情况下，允许单个驱动程序匹配多个设备，而不论其实际名称如何。

## 3. 关于“name”属性的说明
早期 Open Firmware 的用户（如 OldWorld macintoshes）倾向于将实际设备名称用于“name”属性，但现在认为使用更接近设备类别的名称（通常等于“device_type”）是一种良好的实践。例如，如今，以太网控制器被命名为“ethernet”，另外还有一个“model”属性精确地定义芯片类型/型号，以及“compatible”属性定义家族，以防单个驱动程序可以驱动多个此类芯片。然而，内核通常不对“name”属性施加任何限制；只是认为尽可能遵循标准及其演变是良好的实践。

还请注意，新格式版本 16 使“name”属性成为可选。如果节点没有该属性，则使用节点的单元名称来重建名称。也就是说，使用“@”符号之前的单元名称部分（如果没有“@”符号，则使用整个单元名称）。

## 4. 关于节点和属性名称及字符集的说明
虽然 Open Firmware 对 8859-1 的使用更灵活，但本规范执行更严格的规则。节点和属性应仅由 ASCII 字符 'a' 到 'z'、'0' 到 '9'、','、'.'、'_'、'+'、'#'、'?' 和 '-' 组成。节点名称还允许大写字符 'A' 到 'Z'（属性名称应为小写。像 Apple 这样的供应商不遵守此规则这一事实在此无关紧要）。此外，节点和属性名称应始终以 'a' 到 'z' 范围内的字符开头（对于节点名称为 'A' 到 'Z'）。

节点和属性名称的最大字符数均为 31。对于节点名称，这仅是单元名称的最左边部分（纯“name”属性），它不包括可能超出该限制的单元地址。

## 5. 所需节点和属性
这些是当前所需的全部内容。但是，强烈建议您按照 Open Firmware 的 PCI 绑定文档中所述公开 PCI 主机桥，以及按照 OF 中断树规范中所述公开您的中断树。

### a. 根节点
根节点需要存在一些属性：

    - `model`：这是您的主板名称/型号
    - `#address-cells`：“根”设备的地址表示
    - `#size-cells`：“根”设备的大小表示
    - `compatible`：主板“家族”通常在此处找到，例如，如果您有 2 个具有相似布局的主板型号，通常由内核中的相同平台代码驱动，您将在“compatible”属性中指定确切的主板型号，然后是代表 SoC 模型的条目。

根节点通常也是您添加特定于主板的其他属性（如序列号等）的地方。建议如果您添加任何名称可能与标准定义冲突的“自定义”属性，请使用您的供应商名称和逗号作为前缀。

### b. `/cpus` 节点
此节点是所有单个 CPU 节点的父节点。它没有任何特定要求，但通常良好的实践是至少具有：

               `#address-cells = <00000001>`
               `#size-cells    = <00000000>`

这定义了 CPU 的“地址”是单个单元，并且没有有意义的大小。这不是必需的，但内核在读取 CPU 节点的“reg”属性时将假定该格式，见下文

### c. `/cpus/*` 节点
因此，在 `/cpus` 下，您应该为机器上的每个 CPU 创建一个节点。对 CPU 的名称没有特定限制，尽管通常将其称为 `<architecture>,<core>`。例如，Apple 使用 `PowerPC,G5`，而 IBM 使用 `PowerPC,970FX`。然而，通用名称约定建议对于每个 CPU 节点简单地使用 'cpu'，并使用 `compatible` 属性来识别特定的 CPU 核心。

所需属性：

    - `device_type`：必须是 "cpu"
    - `reg`：这是物理 CPU 编号，它是单个 32 位单元，并且还直接用作构建完整路径中的单元编号。例如，对于 2 个 CPU，您将具有完整路径：
        `/cpus/PowerPC,970FX@0`
        `/cpus/PowerPC,970FX@1`
    （单元地址不需要前导零）
    - `d-cache-block-size`：一个单元，L1 数据缓存块大小（以字节为单位）(*)
    - `i-cache-block-size`：一个单元，L1 指令缓存块大小（以字节为单位）
    - `d-cache-size`：一个单元，L1 数据缓存的大小（以字节为单位）
    - `i-cache-size`：一个单元，L1 指令缓存的大小（以字节为单位）

（*）缓存“块”大小是缓存管理指令操作的大小。从历史上看，本文档在此处使用了缓存“行”大小，这是不正确的。内核将优先使用缓存块大小，并为了向后兼容将回退到缓存行大小。

推荐属性：

    - `timebase-frequency`：一个单元，表示时基的频率（以 Hz 为单位）。通用代码不直接使用此属性，但欢迎您根据此值复制/粘贴 pSeries 代码来设置内核时基/递减器校准。
    - `clock-frequency`：一个单元，表示 CPU 核心时钟频率（以 Hz 为单位）。对于 64 位值将定义一个新属性，但如果您的频率 < 4GHz，一个单元就足够了。这里以及上述情况，通用代码不使用该属性，但欢迎您重复使用 pSeries 或 Maple 的代码。未来的内核版本可能会为此提供一个通用函数。
    - `d-cache-line-size`：一个单元，L1 数据缓存行大小（以字节为单位），如果与块大小不同
    - `i-cache-line-size`：一个单元，L1 指令缓存行大小（以字节为单位），如果与块大小不同

欢迎您添加您认为与您的主板相关的任何属性，例如有关用于软重置 CPU 的机制的一些信息。例如，Apple 将用于 CPU 软重置线的 GPIO 编号放在其中作为“soft-reset”属性，因为它们通过软重置来启动辅助 CPU。

### d. `/memory` 节点
要定义您的主板的物理内存布局，您应该创建一个或多个内存节点。您可以创建一个具有其 `reg` 属性中所有内存范围的单个节点，或者根据您的意愿创建多个节点。用于完整路径的单元地址（`@` 部分）是给定节点定义的第一个内存范围的地址。如果您使用单个内存节点，这通常将是 `@0`。

所需属性：

    - `device_type`：必须是 "memory"
    - `reg`：此属性包含您的主板的所有物理内存范围。它是地址/大小的串联列表，每个的单元数量由根节点的 `#address-cells` 和 `#size-cells` 定义。例如，对于这两个属性都为 2 的情况，如前面给出的示例，一个基于 970 的具有 6GB 内存的机器通常在此处具有如下的“reg”属性：

      `00000000 00000000 00000000 80000000`
      `00000001 00000000 00000001 00000000`

    这是一个从 0 开始的 0x80000000 字节的范围和一个从 0x100000000 开始的 0x100000000 字节的范围。您可以看到在 2GB 和 4GB 之间没有内存覆盖的 IO 孔。一些供应商更喜欢将这些范围拆分为较小的段，但内核并不关心。

### e. `/chosen` 节点
此节点有点“特殊”。通常，这是 Open Firmware 放置一些可变环境信息的地方，例如参数或默认的输入/输出设备。

本规范使其中的一些成为强制性的，但也定义了一些特定于 Linux 的属性，这些属性通常在使用 OF 客户端接口引导时由 `prom_init()` 跳板构造，但在使用扁平格式时您必须自己提供。

推荐属性：

    - `bootargs`：这是以零结尾的字符串，作为内核命令行传递
    - `linux,stdout-path`：如果有，这是您的标准控制台设备的完整路径。通常，如果您的主板上有串行设备，您可能希望将在固件中设置为默认控制台的那个的完整路径放在这里，以便内核将其作为自己的默认控制台。

请注意，u-boot 为使用它的平台创建并填充 `chosen` 节点。

（注意：现在已过时的做法是在 `/chosen` 下包含一个名为 `interrupt-controller` 的属性，该属性具有指向主中断控制器的 `phandle` 值）

### f. `/soc<SOCname>` 节点
此节点用于表示片上系统（SoC），如果处理器是 SoC，则必须存在。顶级 SoC 节点包含 SoC 上所有设备的全局信息。节点名称应包含 SoC 的单元地址，这是 SoC 的内存映射寄存器集的基地址。SoC 节点的名称应以“soc”开头，名称的其余部分应代表 SoC 的部件号。例如，MPC8540 的 SoC 节点将称为“soc8540”。

所需属性：

    - `ranges`：应按照 1）中指定的定义来描述 SoC 地址对于内存映射 SoC 寄存器的转换。
    - `bus-frequency`：包含 SoC 节点的总线频率。通常，此字段的值由引导加载程序填充。
    - `compatible`：SoC 的精确型号

推荐属性：

    - `reg`：此属性定义了用于 SoC 节点本身的内存映射寄存器的地址和大小。它不包括子设备寄存器 - 这些将在每个子节点中定义。“reg”属性中指定的地址应与 SoC 节点的单元地址匹配。
    - `#address-cells`：“soc”设备的地址表示。此字段的格式可能会根据设备寄存器是否为内存映射而有所不同。对于内存映射寄存器，此字段表示表示寄存器地址所需的单元数量。对于不使用 MMIO 的 SoC，应定义一个特殊的地址格式，其中包含足够的单元来表示所需的信息。有关定义“#address-cells”的更多详细信息，请参见 1）。
    - `#size-cells`：“soc”设备的大小表示
    - `#interrupt-cells`：定义用于表示中断的单元宽度。通常此值为 `<2>`，其中包括一个 32 位数字，表示中断编号，以及一个 32 位数字，表示中断感知和级别。此字段仅在 SoC 包含中断控制器时需要。

SoC 节点可以包含平台使用的每个 SoC 设备的子节点。对于存在于 SoC 上但特定平台未使用的设备，不应创建节点。有关如何指定作为 SoC 一部分的设备的更多信息，请参见第六章。

MPC8540 的示例 SoC 节点：

```
soc8540@e0000000 {
    #address-cells = <1>;
    #size-cells = <1>;
    #interrupt-cells = <2>;
    device_type = "soc";
    ranges = <0x00000000 0xe0000000 0x00100000>
    reg = <0xe0000000 0x00003000>;
    bus-frequency = <0>;
}
```
# 四、"dtc"，设备树编译器
====================================

dtc 的源代码可以在 <http://git.jdl.com/gitweb/?p=dtc.git> 找到。

**警告**：此版本仍处于早期开发阶段；生成的设备树“blob”尚未经过内核验证。当前生成的块缺少有用的保留映射（将被修复以生成一个空的，由引导加载程序填充）等。错误处理需要改进，可能存在隐藏的错误等。

dtc 基本上接受给定格式的设备树，并输出另一种格式的设备树。当前支持的格式有：

  输入格式：
  -------------

    - "dtb"：“blob”格式，即带有头部的扁平设备树块，全部在二进制 blob 中。
    - "dts"：“源”格式。这是一个包含设备树“源”的文本文件。格式将在本章后面定义。
    - "fs" 格式。这是一种表示，等同于 /proc/device-tree 的输出，即节点是目录，属性是文件。

  输出格式：
  ---------------

    - "dtb"：“blob”格式
    - "dts"：“源”格式
    - "asm"：汇编语言文件。这是一个可以由 gas 读取以生成设备树“blob”的文件。该文件可以简单地添加到您的 Makefile 中。此外，汇编文件导出了一些可以使用的符号。

dtc 工具的语法是：

    dtc [-I <输入格式>] [-O <输出格式>]
        [-o 输出文件名] [-V 输出版本] 输入文件名

“输出版本”定义将生成的“blob”格式的版本。支持的版本是 1、2、3 和 16。默认当前是版本 3，但未来可能会更改为版本 16。

此外，dtc 对树进行各种健全性检查，例如 `linux, phandle` 属性的唯一性、字符串的有效性等。

`.dts` “源”文件的格式类似“C”语言，支持 C 和 C++ 风格的注释。

```
/ {
}
```

以上是“设备树”的定义。这是当前在顶级唯一支持的语句。

```
/ {
  property1 = "string_value";    /* 定义一个包含以 0 结尾的字符串的属性 */

  property2 = <0x1234abcd>;    /* 定义一个包含数值 32 位值（十六进制）的属性 */

  property3 = <0x12345678 0x12345678 0xdeadbeef>;
                              /* 定义一个包含 3 个数值 32 位值（单元）的十六进制属性 */
  property4 = [0x0a 0x0b 0x0c 0x0d 0xde 0xea 0xad 0xbe 0xef];
                              /* 定义一个内容为任意字节数组的属性 */

  childnode@address {    /* 定义一个名为 "childnode" 的子节点，其单元名称为 "childnode at address" */

    childprop = "hello\n";      /* 为子节点定义一个属性 "childprop"（在这种情况下，是一个字符串） */
  };
};
```

节点可以包含其他节点等，从而定义树的层次结构。

字符串支持 C 语言中的常见转义序列："\n"、"\t"、"\r"、"\(八进制值)"、"\x(十六进制值)"。

还建议您通过 cpp（gcc 预处理器）处理源文件，以便可以使用 `#include`、`#define` 定义常量等。

最后，计划了各种选项但尚未实现，例如 `phandles` 的自动生成、标签（导出到汇编文件，以便您可以指向属性内容并从链接设备树的任何内容轻松更改）、在某些单元中使用标签或路径而不是数字值来“指向”节点（在编译时替换为 `phandle`）、将保留映射地址导出到汇编文件、在编译时指定保留映射内容的能力等。

我们可能会提供一个带有某些属性（如构建 PCI 属性或中断映射）常用定义的 `.h` 包含文件，但可能更好的是向编译器添加结构体定义的概念... 

# 五、引导加载程序的建议
====================================

以下是在定义和实现这一切时提出的一些各种想法/建议。

  - 引导加载程序可能希望能够使用设备树本身，并可能希望对其进行操作（添加/编辑一些属性，如物理内存大小或内核参数）。在这一点上，可以做出两种选择。要么引导加载程序直接在扁平格式上工作，要么引导加载程序具有自己的带有指针的内部树表示（类似于内核的），并在引导内核时重新扁平化树。前者更难以编辑/修改，后者可能需要更多的代码来处理树结构。请注意，结构格式的设计使得通过简单地移动内存中的内容来“插入”属性或节点或删除它们相对容易。为此它不包含内部偏移或指针。

  - 从扁平树格式直接迭代节点和检索属性的代码示例可以在内核文件 `drivers/of/fdt.c` 中找到。查看 `of_scan_flat_dt()` 函数、它在 `early_init_devtree()` 中的使用以及相应的各种 `early_init_dt_scan_*()` 回调。该代码可以在 GPL 引导加载程序中重用，作为该代码的作者，我很乐意与任何希望将全部或部分此代码集成到非 GPL 引导加载程序中的供应商讨论可能的免费许可。（需要参考；这里的“我”是谁？---gcl 2011 年 1 月 31 日）

# 六、片上系统设备和节点
=======================================

许多公司现在开始开发片上系统（SOC）处理器，其中处理器核心（CPU）和许多外围设备存在于单个硅片上。对于这些 SOC，应该使用一个 SOC 节点来为构成 SOC 的设备定义子节点。虽然平台不需要使用此模型来引导内核，但强烈鼓励所有 SOC 实现尽可能定义完整的扁平设备树来描述 SOC 上的设备。这将允许内核代码的大量通用化。

1. 定义 SOC 的子节点
---------------------------------

作为 SOC 一部分的每个设备可能在 SOC 节点内部有自己的节点条目。对于包含在 SOC 中的每个设备，单元地址属性表示此设备在父地址空间中的内存映射寄存器的地址偏移。父地址空间由顶级 SOC 节点中的“ranges”属性定义。直接存在于 SOC 节点下的每个节点的“reg”属性应包含从子地址空间到父 SOC 地址空间的地址映射以及设备的内存映射寄存器文件的大小。

对于可能存在于 SOC 内部的许多设备，设备树节点的格式有预定义的规范。所有 SOC 子节点都应遵循这些规范，除非本文档中另有说明。

有关 MPC8540 的示例部分 SOC 节点定义，请参见附录 A。

2. 表示没有当前 OF 规范的设备
----------------------------------------------------------

目前，SOC 上有许多设备没有作为 Open Firmware 规范的一部分定义标准表示，主要是因为包含这些 SOC 的主板当前未使用 Open Firmware 引导。新设备的绑定文档应添加到 `Documentation/devicetree/bindings` 目录中。随着越来越多的 SOC 添加设备树支持，该目录将扩展。

# 七、为设备指定中断信息
===================================================

设备树以类似于硬件物理总线拓扑的形式表示硬件系统的总线和设备。

此外，存在一个逻辑的“中断树”，它表示硬件中中断的层次结构和路由。

中断树模型在“Open Firmware 推荐实践：中断映射版本 0.9”文档中有完整描述。该文档可在 <http://www.openfirmware.org/ofwg/practice/> 获得。

1. `interrupts` 属性
----------------------

向单个中断控制器生成中断的设备应使用 OF 中断映射文档中描述的常规 OF 表示。

每个生成中断的设备必须具有“interrupt”属性。中断属性值是任意数量的“中断说明符”值，用于描述设备的中断或中断。

中断说明符的编码由设备在中断树中所在的中断域决定。中断域的根在其“#interrupt-cells”属性中指定编码中断说明符所需的 32 位单元的数量。有关域的详细描述，请参阅 OF 中断映射文档。

例如，OpenPIC 中断控制器的绑定指定“#interrupt-cells”值为 2 以编码中断号和级别/感知信息。OpenPIC 中断域中的所有中断子节点在其“interrupts”属性中每个中断使用 2 个单元。

PCI 总线绑定指定“#interrupt-cell”值为 1 以编码使用的中断引脚（INTA、INTB、INTC、INTD）。

2. `interrupt-parent` 属性
----------------------------

指定“interrupt-parent”属性以在中断树中定义设备节点与其中断父节点之间的显式链接。“interrupt-parent”的值是父节点的“phandle”。

如果未为节点定义“interrupt-parent”属性，则假定其中断父节点是节点的设备树层次结构中的祖先。

3. OpenPIC 中断控制器
--------------------------------

OpenPIC 中断控制器需要 2 个单元来编码中断信息。第一个单元定义中断号。第二个单元定义感知和级别信息。

感知和级别信息应按如下方式编码：

    0 = 低到高边沿敏感类型启用
    1 = 低电平有效敏感类型启用
    2 = 高电平有效敏感类型启用
    3 = 高到低边沿敏感类型启用

4. ISA 中断控制器
----------------------------

ISA PIC 中断控制器需要 2 个单元来编码中断信息。第一个单元定义中断号。第二个单元定义感知和级别信息。

ISA PIC 中断控制器应遵循以下列出的 ISA PIC 编码：

    0 = 低电平有效敏感类型启用
    1 = 高电平有效敏感类型启用
    2 = 高到低边沿敏感类型启用
    3 = 低到高边沿敏感类型启用

# 八、指定设备电源管理信息（睡眠属性）
===================================================================

SOC 上的设备通常具有将设备置于低功耗状态的机制，这些机制与设备自身的寄存器块是分离的。有时，此信息比单元索引属性所能合理描述的要复杂。因此，以这种方式控制的每个设备可能包含一个“睡眠”属性来描述这些连接。

睡眠属性由一个或多个睡眠资源组成，每个资源由一个指向睡眠控制器的“phandle”，后跟零个或多个控制器特定的睡眠说明符单元组成。

可能的低功耗模式类型的语义由睡眠控制器定义。可能支持的低功耗模式类型的一些示例是：

 - 动态：设备可以随时被禁用或启用。
 - 系统挂起：设备可以请求在系统挂起期间被禁用或保持唤醒，但在那之前不会被禁用。
 - 永久：设备被永久禁用（直到下一次硬重置）。

一些设备可能彼此共享时钟域，因此只有当没有设备在使用时，它们才应被挂起。在合理的情况下，此类节点应放置在具有睡眠属性的虚拟总线上。如果时钟域在无法以这种方式合理分组的设备之间共享，则创建一个虚拟睡眠控制器（类似于中断中心，除了定义标准化的睡眠映射应等到其必要性得到证明）。

# 九、指定 DMA 总线信息

某些设备可能具有相对于 RAM 开头偏移的 DMA 内存范围，甚至可能位于内核 RAM 之外。例如，在 LPAE 模式下具有 4G 内存的 Keystone 2 SoC 具有：
 - RAM 范围：[0x8 0000 0000, 0x8 FFFF FFFF]
 - DMA 范围：[  0x8000 0000,   0xFFFF FFFF]
并且 DMA 范围在硬件中被映射到 RAM 的前 2G 。

在这种情况下，应在 CPU 物理地址和 DMA 地址之间执行 DMA 地址转换。“dma-ranges”属性旨在用于在 DT 中描述此类系统的配置。

此外，DMA 总线上的每个 DMA 主设备可能支持也可能不支持一致性 DMA 操作。“dma-coherent”属性旨在用于在 DT 中识别支持一致性 DMA 操作的设备。

* DMA 总线主设备
可选属性：
 - `dma-ranges`：<prop-encoded-array> 编码为任意数量的三元组（子总线地址，父总线地址，长度）。每个三元组描述了一个连续的 DMA 地址范围。
 “dma-ranges”属性用于描述内存映射总线的直接内存访问（DMA）结构，其设备树父节点可以通过来自总线的 DMA 操作访问。它提供了一种定义总线的物理地址空间与总线父节点的物理地址空间之间的映射或转换的方法。
 （有关更多信息，请参阅 ePAPR 规范）

* DMA 总线子设备
可选属性：
 - `dma-ranges`：<空> 值。如果存在 - 这意味着必须为该设备启用 DMA 地址转换。
 - `dma-coherent`：存在如果 DMA 操作是一致的

示例：
```
soc {
        compatible = "ti,keystone","simple-bus";
        ranges = <0x0 0x0 0x0 0xc0000000>;
        dma-ranges = <0x80000000 0x8 0x00000000 0x80000000>;

        [...]

        usb: usb@2680000 {
            compatible = "ti,keystone-dwc3";

            [...]
            dma-coherent;
        };
};
```

# 附录 A - MPC8540 的示例 SOC 节点
========================================

```
soc@e0000000 {
    #address-cells = <1>;
    #size-cells = <1>;
    compatible = "fsl,mpc8540-ccsr", "simple-bus";
    device_type = "soc";
    ranges = <0x00000000 0xe0000000 0x00100000>
    bus-frequency = <0>;
    interrupt-parent = <&pic>;

    ethernet@24000 {
        #address-cells = <1>;
        #size-cells = <1>;
        device_type = "network";
        model = "TSEC";
        compatible = "gianfar", "simple-bus";
        reg = <0x24000 0x1000>;
        local-mac-address = [ 0x00 0xE0 0x0C 0x00 0x73 0x00 ];
        interrupts = <0x29 2 0x30 2 0x34 2>;
        phy-handle = <&phy0>;
        sleep = <&pmc 0x00000080>;
        ranges;

        mdio@24520 {
            reg = <0x24520 0x20>;
            compatible = "fsl,gianfar-mdio";

            phy0: ethernet-phy@0 {
                interrupts = <5 1>;
                reg = <0>;
            };

            phy1: ethernet-phy@1 {
                interrupts = <5 1>;
                reg = <1>;
            };

            phy3: ethernet-phy@3 {
                interrupts = <7 1>;
                reg = <3>;
            };
        };
    };

    ethernet@25000 {
        device_type = "network";
        model = "TSEC";
        compatible = "gianfar";
        reg = <0x25000 0x1000>;
        local-mac-address = [ 0x00 0xE0 0x0C 0x00 0x73 0x01 ];
        interrupts = <0x13 2 0x14 2 0x18 2>;
        phy-handle = <&phy1>;
        sleep = <&pmc 0x00000040>;
    };

    ethernet@26000 {
        device_type = "network";
        model = "FEC";
        compatible = "gianfar";
        reg = <0x26000 0x1000>;
        local-mac-address = [ 0x00 0xE0 0x0C 0x00 0x73 0x02 ];
        interrupts = <0x41 2>;
        phy-handle = <&phy3>;
        sleep = <&pmc 0x00000020>;
    };

    serial@4500 {
        #address-cells = <1>;
        #size-cells = <1>;
        compatible = "fsl,mpc8540-duart", "simple-bus";
        sleep = <&pmc 0x00000002>;
        ranges;

        serial@4500 {
            device_type = "serial";
            compatible = "ns16550";
            reg = <0x4500 0x100>;
            clock-frequency = <0>;
            interrupts = <0x42 2>;
        };

        serial@4600 {
            device_type = "serial";
            compatible = "ns16550";
            reg = <0x4600 0x100>;
            clock-frequency = <0>;
            interrupts = <0x42 2>;
        };
    };

    pic: pic@40000 {
        interrupt-controller;
        #address-cells = <0>;
        #interrupt-cells = <2>;
        reg = <0x40000 0x40000>;
        compatible = "chrp,open-pic";
        device_type = "open-pic";
    };

    i2c@3000 {
        interrupts = <0x43 2>;
        reg = <0x3000 0x100>;
        compatible  = "fsl-i2c";
        dfsrr;
        sleep = <&pmc 0x00000004>;
    };

    pmc: power@e0070 {
        compatible = "fsl,mpc8540-pmc", "fsl,mpc8548-pmc";
        reg = <0xe0070 0x20>;
    };
};
```