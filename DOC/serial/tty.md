The Lockronomicon

您关于 tty 层古老而扭曲的锁定策略以及其背后扭曲逻辑的指南。继续阅读的各位请小心。

**注**：仍然需要确定完整的 BKL 假设集并记录下来，以便最终将其摒弃。

# 线路规范（Line Discipline）
---------------

线路规范通过 `tty_register_ldisc()` 函数进行注册，传递规范编号和 `ldisc` 结构。在注册时，规范必须准备好使用，有可能在调用返回成功之前就被使用。如果调用返回错误，就不会被调用。不要重复使用 `ldisc` 编号，因为它们是用户空间 ABI 的一部分，覆盖现有 `ldisc` 会导致电脑出问题。

注册返回后，`ldisc` 数据已被复制，您可以释放自己的结构副本。不能在已有线路规范之上重新注册，即使数据相同，否则电脑会再次出问题。

要移除线路规范，调用 `tty_unregister_ldisc()` 。过去这个操作总是有效，现在如果 `ldisc` 正在使用，函数会返回 `-EBUSY` 。由于 `ldisc` 引用代码管理模块计数，通常这不是问题。

请注意：`ldisc` 表中已注册的 `tty_ldisc` 结构副本的引用计数字段，统计使用此规范的线路数量。`tty` 中的 `tty_ldisc` 结构的引用计数，统计此刻 `ldisc` 的活跃用户数量。实际上，它统计了 `ldisc` 方法内的执行线程数量（包括即将进入和退出的，不过这个细节不重要）。

# 线路规范方法（Line Discipline Methods）
-----------------------

**TTY 侧接口**：

- `open()`：线路规范连接到终端时调用。在此操作成功完成前，不会有针对此 `tty` 的其他线路规范调用。返回错误会阻止 `ldisc` 连接。可以睡眠。
- `close()`：终端上线路规范拔出时调用。执行此操作时，不会有其他用户再进入此 `tty` 的 `ldisc` 代码。可以睡眠。
- `hangup()`：`tty` 线路挂起时调用。线路规范应停止对 `tty` 的 I/O 操作。不会再有对 `ldisc` 代码的调用。返回值被忽略。可以睡眠。
- `write()`：进程通过线路规范写数据时调用。`tty` 层会为 `ldisc` 对多个 `write` 调用进行序列化。可以睡眠。
- `flush_buffer()`：（可选）可在 `open` 和 `close` 之间的任何点调用，指示线路规范清空输入缓冲区。
- `chars_in_buffer()`：（可选）报告输入缓冲区中的字节数。
- `set_termios()`：（可选）`termios` 结构更改时调用。调用者传递旧的 `termios` 数据，当前数据在 `tty` 中。在 `termios` 信号量下调用，所以允许睡眠。仅针对自身进行序列化。
- `read()`：将数据从线路规范移动到用户。多个 `read` 调用可能并行发生，`ldisc` 必须处理序列化问题。可以睡眠。
- `poll()`：检查 `poll/select` 调用的状态。多个 `poll` 调用可能并行发生。可以睡眠。
- `ioctl()`：`tty` 层收到可能针对 `ldisc` 的 `ioctl` 时调用。多个 `ioctl` 调用可能并行发生。可以睡眠。
- `compat_ioctl()`：`tty` 层收到 32 位可能针对 `ldisc` 的 `ioctl` 时调用。多个 `ioctl` 调用可能并行发生。可以睡眠。

**驱动侧接口**：

- `receive_buf()`：将字节缓冲区从驱动传递给 `ldisc` 进行处理。语义目前比较神秘。
- `write_wakeup()`：可在 `open` 和 `close` 之间的任何点调用。`TTY_DO_WRITE_WAKEUP` 标志指示是否需要调用，但总是与调用竞争。因此，`ldisc` 必须注意设置顺序并处理意外调用。不能睡眠。
    - 禁止驱动直接从 `ldisc` 的 `->write` 调用中调用此函数，因为 `ldisc` 允许从这个函数调用驱动的写方法。在这种情况下，推迟它。
- `dcd_change()`：向 `tty` 线路报告当前 DCD 引脚状态的变化和相对时间戳。时间戳不能为 `NULL` 。

# 驱动访问（Driver Access）

线路规范方法可以通过 `tty->driver` 结构中的函数指针调用底层硬件驱动的以下方法：

- `write()`：向 `tty` 设备写入一块字符。返回接受的字符数。传递给此方法的字符缓冲区已在内核空间。
- `put_char()`：将单个字符排队写入 `tty` 设备。如果队列中没有空间，字符将被忽略。
- `flush_chars()`：（可选）如果定义，在使用 `put_char()` 排队字符后必须调用，以开始传输。
- `write_room()`：返回 `tty` 驱动可以接受排队写入的字符数。
- `ioctl()`：调用设备特定的 `ioctl` 。期望数据指针指向用户空间。对于未识别的 `ioctl` 编号，返回 `ENOIOCTLCMD` 。
- `set_termios()`：通知 `tty` 驱动设备的 `termios` 设置已更改。新设置在 `tty->termios` 中。应在“旧”参数中传递以前的设置。
    - API 定义要求驱动返回选择的实际模式。这意味着驱动函数负责修改请求中无法满足的任何位，以指示实际使用的模式。没有硬件更改能力的设备（例如 USB 加密狗或虚拟端口）可以为此方法提供 `NULL` 。
- `throttle()`：通知 `tty` 驱动线路规范的输入缓冲区接近满，应发出不再向 `tty` 发送更多字符的信号。
- `unthrottle()`：通知 `tty` 驱动现在可以向 `tty` 发送字符，而不必担心超出线路规范的输入缓冲区。
- `stop()`：要求 `tty` 驱动停止向 `tty` 设备输出字符。
- `start()`：要求 `tty` 驱动恢复向 `tty` 设备发送字符。
- `hangup()`：要求 `tty` 驱动挂起 `tty` 设备。
- `break_ctl()`：（可选）要求 `tty` 驱动打开或关闭 RS-232 端口的中断状态。如果状态为 `-1` ，则应打开中断状态；如果状态为 `0` ，则应关闭中断状态。如果未实现此例程，请使用 `ioctls` `TIOCSBRK` / `TIOCCBRK` 代替。
- `wait_until_sent()`：等待设备将其发送器 FIFO 中的所有字符都写出。
- `send_xchar()`：向设备发送高优先级的 XON/XOFF 字符。

# 标志（Flags）

线路规范方法可以访问 `tty->flags` 字段，其中包含以下有趣的标志：

- `TTY_THROTTLED`：驱动输入被节流。`ldisc` 应调用 `tty->driver->unthrottle()` 以在准备好处理更多数据时恢复接收。
- `TTY_DO_WRITE_WAKEUP`：如果设置，会导致驱动在可以接受更多数据进行传输时调用 `ldisc` 的 `write_wakeup()` 方法来恢复传输。
- `TTY_IO_ERROR`：如果设置，会导致后续所有在 `tty` 上的用户空间读/写调用失败，返回 `-EIO` 。
- `TTY_OTHER_CLOSED`：设备是 `pty` ，且另一端已关闭。
- `TTY_OTHER_DONE`：设备是 `pty` ，且另一端已关闭，所有挂起的输入处理已完成。
- `TTY_NO_WRITE_SPLIT`：防止驱动将写入拆分为较小的块。

# 锁定（Locking）

`tty` 层到线路规范函数的调用者需要获取线路规范锁。驱动侧的调用也是如此，但尚未强制实施。

现在提供了三个调用：

- `ldisc = tty_ldisc_ref(tty);`：获取 `tty` 中线路规范的句柄并返回。如果当前没有连接 `ldisc` 或 `ldisc` 正在关闭和重新打开，则返回 `NULL` 。持有此句柄时，`ldisc` 不会更改或消失。
- `tty_ldisc_deref(ldisc)`：返回 `ldisc` 引用并允许 `ldisc` 关闭。返回引用会剥夺您调用 `ldisc` 函数的权利，直到获取新的引用。
- `ldisc = tty_ldisc_ref_wait(tty);`：执行与 `tty_ldisc_ref` 相同的功能，但会等待 `ldisc` 更改完成，然后返回新 `ldisc` 的引用。

虽然这些函数比旧代码稍慢，但影响应该最小，因为大多数接收逻辑使用翻转缓冲区，并且它们仅在通过驱动推送位时才需要获取引用。

注意：`ldisc->open()` 、 `ldisc->close()` 和 `driver->set_ldisc` 函数在 `ldisc` 不可用时被调用。因此，如果在这些函数中使用 `tty_ldisc_ref` ，将会失败。在这种情况下，`ldisc` 和驱动代码调用自身函数时必须小心。

# 驱动接口（Driver Interface）
----------------

- `open()`：设备打开时调用。可以睡眠。
- `close()`：设备关闭时调用。在此调用返回时，驱动不得再进行任何类型的 `ldisc` 调用。可以睡眠。
- `write()`：向设备写入字节时调用。不能睡眠。在特殊情况下可能并行发生。由于这包括恐慌路径，驱动通常不应在此尝试进行巧妙的锁定。
- `put_char()`：将单个字符放入队列。驱动保证后续会调用 `flush_chars` 。
- `flush_chars()`：要求内核写入 `put_char` 队列。
- `write_room()`：返回可以无溢出（或更少）地放入端口缓冲区的字符数。`ldisc` 负责处理 `write_room/write` 调用的多线程智能。
- `ioctl()`：当 `ioctl` 可能针对驱动时调用。
- `set_termios()`：`termios` 更改时调用，通过信号量针对自身进行序列化。可以睡眠。
- `set_ldisc()`：规范更改的通知程序。此时规范尚不可用。现在可以睡眠（我认为）。
- `throttle()`：`ldisc` 调用以要求驱动进行流控制。包括与 `unthrottle` 的序列化是 `ldisc` 层的工作。
- `unthrottle()`：`ldisc` 调用以要求驱动停止流控制。
- `stop()`：`ldisc` 通知驱动停止输出。与 `throttle` 一样，与 `start()` 的序列化由 `ldisc` 层处理。
- `start()`：`ldisc` 通知驱动开始输出。
- `hangup()`：要求 `tty` 驱动从主机端发起挂起。[可以睡眠？？]
- `break_ctl()`：发送 RS232 中断。可以睡眠。可以并行调用，驱动必须序列化（目前），并与写调用一起。
- `wait_until_sent()`：等待驱动程序的硬件队列中的字符退出。可以睡眠。
- `send_xchar()`：发送 XON/XOFF，如果可能，使用它跳过队列以获得快速流控制响应。不能睡眠？？