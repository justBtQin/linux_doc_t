**What**：`/dev/kmsg`

**Date**：2012 年 5 月

**KernelVersion**：3.5

**Contact**：Kay Sievers <kay@vrfy.org>

**Description**：`/dev/kmsg`字符设备节点为用户空间提供了对内核`printk`缓冲区的访问。

# 注入消息：

对打开的设备节点的每次`write()`都会在内核的`printk`缓冲区中放置一个日志条目。

记录的行可以以前缀`<N>`开头，这是`syslog`前缀，包含`syslog`优先级和设施。单个十进制前缀数字由 3 个最低位组成`syslog`优先级，高位组成`syslog`设施号。

如果未给出前缀，优先级数字是内核日志的默认优先级，设施号设置为`LOG_USER`（1）。无法从用户空间注入设施号为`LOG_KERN`（0）的消息，以确保消息的来源始终可以可靠地确定。

# 访问缓冲区：

从打开的设备节点的每次`read()`都会接收内核`printk`缓冲区的一条记录。

`open()`之后的第一次`read()`总是返回缓冲区中的第一条消息；内核内部没有持久状态；多个读者可以同时打开设备并从中读取，而不会影响其他读者。

每次`read()`都会接收下一个可用的记录。如果没有更多的记录可用，`read()`将阻塞，如果使用`O_NONBLOCK`则返回`-EAGAIN`。

记录环形缓冲区中的消息作为整体被覆盖，`read()`永远不会收到部分消息。

如果在设备保持打开的情况下，循环缓冲区中的消息被覆盖，下一次`read()`将返回`-EPIPE`，并将查找位置更新到下一个可用的记录。后续的`read()`将再次返回可用的记录。

与经典的`syslog()`接口不同，64 位的记录序列号允许计算缓冲区被覆盖时丢失的消息数量。并且它们允许重新连接到缓冲区并在需要时重建读取位置，而不会将接口限制为单个读者。

该设备支持以下参数的查找：

```
`SEEK_SET`，0
	查找缓冲区中的第一条记录

`SEEK_END`，0
	查找缓冲区中的最后一条记录之后

`SEEK_DATA`，0
	查找在上次`SYSLOG_ACTION_CLEAR`发出时最后可用的记录之后
```

输出格式由包含`syslog`前缀（包括优先级和设施）的前缀、64 位消息序列号、以微秒为单位的单调时间戳和一个标志字段组成。所有字段都用“,”分隔。

未来的扩展可能会在结束的“;”之前添加更多逗号分隔的值。未知的字段和值应该被优雅地忽略。

人类可读的文本字符串直接从“;”后面开始，并以“\n”结束。来自硬件或其他设施的不可信值会被打印，因此日志消息中的所有不可打印字符和“\”本身都通过“\x00”C 风格的十六进制编码进行转义。

以“ ”开头的行是延续行，为日志消息添加键/值对，为用户空间中的可靠处理提供消息的机器可读上下文。

# 示例：

`7,160,424069,-;pci_root PNP0A03:00: host bridge window [io  0x0000-0x0cf7] (ignored)`

`SUBSYSTEM=acpi`

`DEVICE=+acpi:PNP0A03:00`

`6,339,5140900,-;NET: Registered protocol family 10`

`30,340,5690716,-;udevd[80]: starting version 181`

`DEVICE`键以下列方式唯一标识设备：

`b12:8` - 块设备`dev_t`

`c127:3` - 字符设备`dev_t`

`n8` - 网络设备索引

`+sound:card0` - 子系统:设备名

标志字段默认携带“-”。“c”表示一行的片段。所有后续的片段都标记为“+”。请注意，关于延续行的这些提示不一定正确，并且流可能与无关的消息交错，但在输出中合并行通常会产生更好的人类可读结果。在将消息打印到控制台、`/proc/kmsg`或`syslog()`系统调用时，内部使用类似的逻辑。

**Users**：`dmesg(1)`，用户空间内核日志使用者 