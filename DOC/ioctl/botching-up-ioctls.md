# (如何避免)搞砸 ioctls
=================================

来源：http://blog.ffwll.ch/2013/11/botching-up-ioctls.html

作者：Daniel Vetter，版权  2013 Intel Corporation

在过去的几年中，内核图形黑客们有了一个清晰的认识，即试图为完全不同的 GPU 提出一个统一的接口来管理执行单元和内存是徒劳的。所以现在每个驱动都有自己的一组 ioctls 来分配内存并向 GPU 提交工作。这很好，因为不再有以假通用形式出现的疯狂接口，但实际上只使用了一次。但明显的缺点是，搞砸事情的可能性更大了。

为了避免再次重复同样的错误，我写下了在为 drm/i915 驱动搞砸工作时所学到的一些教训。其中大部分只涉及技术细节，而不是像命令提交 ioctl 到底应该是什么样子这样的大局问题。每个 GPU 驱动可能都需要自己学习这些教训。

## 先决条件
-------------

首先是先决条件。没有这些，您已经失败了，因为您将需要添加一个 32 位的兼容层：

  - 只使用固定大小的整数。为了避免与用户空间中的 typedef 冲突，内核有特殊的类型，如 `__u32`、`__s64`。使用它们。

  - 将所有内容对齐到自然大小，并使用显式填充。32 位平台不一定将 64 位值对齐到 64 位边界，但 64 位平台会。所以我们总是需要填充到自然大小以确保正确。

  - 将整个结构体填充到 64 位的倍数 - 否则结构体大小在 32 位和 64 位上会有所不同。当将结构体数组传递给内核，或者内核检查结构体大小时（例如 drm 核心会这样做），结构体大小不同会造成伤害。

  - 指针是 `__u64`，在用户空间一侧从/到 `uintptr_t` 进行转换，在内核中从/到 `void __user *` 进行转换。尽量不要延迟这种转换，更不要在代码中摆弄原始的 `__u64`，因为这会削弱像 sparse 这样的检查工具所能提供的帮助。

## 基础
------

避免了编写兼容层的乐趣，我们可以看看基本的失误。忽略这些会使向前和向后的兼容性成为真正的痛苦。而且由于第一次尝试就出错是肯定的，对于任何给定的接口，您都将有第二次迭代或至少是扩展。

  - 让用户空间有一种清晰的方式来确定给定的内核是否支持您的新 ioctl 或 ioctl 扩展。如果您不能依赖旧内核拒绝新的标志/模式或 ioctls（因为过去搞砸了），那么您需要在某个地方有一个驱动特性标志或版本号。

  - 为在结构体末尾使用新标志或新字段扩展 ioctls 制定一个计划。drm 核心会检查每个 ioctl 调用传递的大小，并对内核和用户空间之间的任何不匹配进行零扩展。这有帮助，但不是一个完整的解决方案，因为较新的用户空间在较旧的内核上不会注意到末尾新添加的字段被忽略了。所以这仍然需要一个新的驱动特性标志。

  - 检查所有未使用的字段和标志以及所有填充是否为 0，如果不是，则拒绝 ioctl。否则，您为未来扩展制定的好计划将直接失败，因为有人会提交一个 ioctl 结构体，其中未使用的部分有随机的堆栈垃圾。这会导致 ABI 中这些字段永远只能用于垃圾，而不能用于其他任何用途。

  - 为上述所有内容提供简单的测试用例。

## 错误路径的乐趣
--------------------

如今，对于 drm 驱动成为整洁的小根权限漏洞，我们再也没有任何借口了。这意味着我们既需要完整的输入验证，也需要可靠的错误处理路径 - GPU 最终在最奇怪的角落情况下都会死机：

  - ioctl 必须检查数组溢出。还需要检查整数的溢出/下溢和钳位问题。常见的例子是直接输入到硬件中的精灵定位值，而硬件只有 12 位左右。在某些奇怪的显示服务器不进行钳位并且光标环绕屏幕之前，工作得很好。

  - 为 ioctl 中的每个输入验证失败情况提供简单的测试用例。检查错误代码是否符合您的预期。最后，确保在每个子测试中只测试一个错误路径，通过提交其他完全有效的数据。否则，早期的检查可能已经拒绝了 ioctl，从而掩盖了您实际想要测试的代码路径，隐藏了错误和回归。

  - 使您的所有 ioctls 可重新启动。首先，X 非常喜欢信号，其次，这将允许您通过不断用信号中断主测试套件来测试 90％的所有错误处理路径。由于 X 对信号的喜爱，对于图形驱动，您将几乎免费获得所有错误路径的出色基本覆盖。此外，对于如何处理 ioctl 重新启动要保持一致 - 例如，drm 在其用户空间库中有一个小的 `drmIoctl` 助手。i915 驱动在 `set_tiling` ioctl 中搞砸了这一点，现在我们在内核和用户空间中都永远被困在一些神秘的语义中。

  - 如果您无法使给定的代码路径可重新启动，至少使卡住的任务可杀死。GPU 会死机，如果您挂起了整个盒子（通过不可杀死的 X 进程），您的用户不会更喜欢您。如果状态恢复仍然太棘手，则在硬件出现问题的情况下，作为最后手段设置超时或挂起检查安全网。

  - 为错误恢复代码中的真正棘手的角落情况提供测试用例 - 很容易在挂起检查代码和等待者之间创建死锁。

## 时间、等待和错过
----------------------------

GPU 几乎所有的操作都是异步的，所以我们需要对操作进行计时并等待未完成的操作。这是非常棘手的业务；目前，drm/i915 支持的 ioctls 没有一个完全正确地做到这一点，这意味着这里还有很多需要学习的地方。

  - 始终使用 `CLOCK_MONOTONIC` 作为您的参考时间。这是 alsa、drm 和 v4l 现在默认使用的。但要让用户空间知道哪些时间戳来自不同的时钟域，例如您的主系统时钟（由内核提供）或其他地方的一些独立硬件计数器。如果您看得足够仔细，时钟会不匹配，但如果性能测量工具具有此信息，它们至少可以进行补偿。如果您的用户空间可以获取某些时钟的原始值（例如通过命令流中的性能计数器采样指令），也考虑暴露这些值。

  - 使用 `__s64` 秒加上 `__u64` 纳秒来指定时间。这不是最方便的时间规范，但它大多是标准的。

  - 检查输入的时间值是否标准化，如果不是，则拒绝它们。请注意，内核原生的 `ktime` 结构体对于秒和纳秒都有一个有符号整数，所以要注意这里。

  - 对于超时，使用绝对时间。如果您是个好人并且使您的 ioctl 可重新启动，相对超时往往太粗糙，并且由于每次重新启动的舍入可能无限期地延长您的等待时间。特别是如果您的参考时钟非常慢，例如显示帧计数器。从规范律师的角度来看，这不是一个错误，因为超时总是可以延长 - 但如果由于这个原因您的整洁动画开始卡顿，用户肯定会讨厌您。

  - 考虑放弃任何带有超时的同步等待 ioctls，而只是在可轮询的文件描述符上提供异步事件。它更适合事件驱动应用程序的主循环。

  - 为角落情况提供测试用例，特别是对于已经完成的事件、成功的等待和超时的等待的返回值是否都合理并且符合您的需求。

## 不泄露资源
----------------------

一个完整的 drm 驱动本质上实现了一个小的操作系统，但专门针对给定的 GPU 平台。这意味着驱动需要向用户空间暴露大量不同对象和其他资源的句柄。正确做到这一点需要注意自己的一些陷阱：

  - 始终将动态创建的资源的生命周期与文件描述符的生命周期相关联。如果您的资源需要在进程之间共享，请考虑使用 1:1 映射 - 通过 Unix 域套接字传递文件描述符也简化了用户空间的生命周期管理。

  - 始终支持 `O_CLOEXEC`。

  - 确保在不同的客户端之间有足够的隔离。默认情况下，选择每个文件描述符的私有命名空间，这强制任何共享都必须明确进行。只有当对象真正是设备唯一的时，才使用更全局的每个设备的命名空间。drm 模式集接口中的一个反例是，每个设备的模式集对象（如连接器）与帧缓冲区对象共享一个命名空间，而帧缓冲区对象大多根本不共享。对于帧缓冲区，默认情况下为私有的单独命名空间会更合适。

  - 考虑用户空间句柄的唯一性要求。例如，对于大多数 drm 驱动，在同一个命令提交 ioctl 中两次提交同一个对象是用户空间的错误。但是，如果对象是可共享的，用户空间需要知道它是否已经看到了来自不同进程的导入对象。由于缺乏新的对象类，我自己还没有尝试过这一点，但考虑使用共享文件描述符上的 inode 编号作为唯一标识符 - 这也是如何区分真正的文件的方式。不幸的是，这需要在内核中有一个完整的虚拟文件系统。

## 最后，但并非最不重要
-------------------

并非每个问题都需要一个新的 ioctl：

  - 认真思考您是否真的需要一个驱动私有接口。当然，推出一个驱动私有接口比参与冗长的讨论以获得更通用的解决方案要快得多。偶尔，为了引领一个新的概念，做一个私有接口是必要的。但最终，一旦通用接口出现，您将永远维护两个接口。

  - 考虑除 ioctls 之外的其他接口。对于每个设备的设置，或者对于生命周期相当静态的子对象（如 drm 中的输出连接器及其所有检测覆盖属性），sysfs 属性要好得多。或者也许只有您的测试套件需要这个接口，那么带有不稳定 ABI 免责声明的 debugfs 会更好。

最后，游戏的名称是在第一次尝试时就做对，因为如果您的驱动被证明是流行的，并且您的硬件平台寿命长，那么您将基本上永远被困在给定的 ioctl 中。您可以尝试在新的硬件迭代中弃用可怕的 ioctls，但通常需要数年才能实现这一点。然后又需要数年，直到最后一个能够抱怨回归的用户消失。