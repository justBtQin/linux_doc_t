# ARM Linux 2.6

============

请查看 <ftp://ftp.arm.linux.org.uk/pub/armlinux> 以获取更新。

# 内核编译

---------------------

为了编译 ARM Linux，你需要一个能够生成带有 GNU 扩展的 ARM ELF 代码的编译器。已知 GCC 3.3 是一个不错的编译器。幸运的是，你无需猜测。如果你的编译器是已知的违规者，内核将报告错误。

要本地构建 ARM Linux，你无需更改顶级 Makefile 中的`ARCH =`行。然而，如果你的系统默认未安装 ARM Linux ELF 工具，那么你应该按照下面的详细说明更改`CROSS_COMPILE`行。

如果你希望进行交叉编译，那么请更改顶级 Makefile 中的以下行：

`ARCH = <whatever>`

改为

`ARCH = arm`

以及

`CROSS_COMPILE=`

改为

`CROSS_COMPILE=<你的编译器路径（不包含 gcc）>`

例如：`CROSS_COMPILE=arm-linux-`

执行`make config`，然后执行`make Image`来构建内核（`arch/arm/boot/Image`）。要构建压缩映像，可以执行`make zImage`而不是`make Image`。

# 错误报告等

---------------

请将补丁发送到补丁系统。更多信息，请查看

http://www.arm.linux.org.uk/developer/patches/info.php 。请始终包含一些关于补丁作用和为什么需要它的解释。

错误报告应发送到`linux-arm-kernel@lists.arm.linux.org.uk`，或通过以下网页表单提交：

http://www.arm.linux.org.uk/developer/

在发送错误报告时，请确保它们包含所有相关信息，例如在问题之前/期间打印的内核消息、你正在做的事情等。

# 包含文件

-------------

在`include/asm-arm`下创建了几个新的包含目录，以减少顶级目录中的混乱。这些目录及其用途如下所示：

`arch-*`：机器/平台特定的头文件

`hardware`：驱动程序内部的 ARM 特定数据结构/定义

`mach`：通用 ARM 到特定机器接口的描述

`proc-*`：处理器相关的头文件（目前只有两个类别）

# 机器/平台支持

------------------------

ARM 树包含对许多不同机器类型的支持。为了继续支持这些差异，有必要按目录拆分机器特定部分。为此，使用机器类别来选择包含哪些目录和文件（我们将使用`$(MACHINE)`来指代该类别）。

为此，我们现在有`arch/arm/mach-$(MACHINE)`目录，这些目录旨在容纳特定机器的非驱动程序文件（例如，PCI、内存管理、架构定义等）。对于所有未来的机器，应该有一个相应的`arch/arm/mach-$(MACHINE)/include/mach`目录。

# 模块

-------

虽然支持模块化（并且对于 FP 模拟器是必需的），但在 ARM2/ARM250/ARM3 机器上加载的每个模块在加载时将占用高达下一个 32k 边界的内存，这是由于页面的大小。那么，在这些机器上进行模块化真的值得吗？

然而，ARM6 及以上的机器允许模块占用 4k 的倍数，因此 Acorn RiscPC 等使用这些处理器的架构可以很好地利用模块化。

# ADFS 映像文件

----------------

你可以通过挂载 ADFS 分区并使用回环设备驱动程序来访问 ADFS 分区上的映像文件。你必须安装`losetup`。

请注意，PCEmulator DOS 分区在开头有一个分区表，因此你必须向`losetup`提供`-o offset`。

# 对开发者的请求

---------------------

在编写包含单独汇编文件的设备驱动程序时，请将其包含在 C 文件中，而不是`arch/arm/lib`目录中。这允许驱动程序被编译为可加载模块，而无需将一半的代码编译到内核映像中。

通常，除非确实必要，否则尽量避免使用汇编。这会使驱动程序更难移植到其他硬件。

# ST506 硬盘

-----------------

ST506 硬盘控制器似乎工作正常（虽然有点慢）。目前，它们仅在 A4x0 的主板上的控制器上工作，但要在 Podule 上工作，只需要有人在源代码中添加 IRQ 掩码和 HDC 基地址。

截至 1996 年 3 月 31 日，它可以与两个驱动器一起工作（你应该将 ADFS 的`configure harddrive`设置为 2）。我有一个内部 20MB 和一个巨大的外部 5.25" FH 64MB 驱动器（谁会想要更多呢:-)）。

我从它那里得到了 240K/s（`dd with bs=128k`）；这大约是 RiscOS 得到的一半；但比我上周得到的 50K/s 好得多:-)

已知错误：驱动器数据错误可能导致挂起；包括控制器使用 ECC 修复错误的情况。（可能仅在那种情况下...嗯）。

# 1772 软盘

-----------

这似乎也工作正常，但最近没有受到太多压力。目前它没有任何用于磁盘更换检测的代码，这可能是一个问题！欢迎提供关于正确实现方法的建议。

# CONFIG_MACH_ 和 CONFIG_ARCH_

-----------------------------

2003 年对新机器的宏名称进行了更改。从历史上看，`CONFIG_ARCH_`用于真正的架构，例如 SA1100，以及架构的实现，例如 Assabet。决定将实现宏更改为`CONFIG_MACH_`以提高清晰度。此外，由于这会使补丁变得复杂，因此未进行回溯修复。

可以在网上找到以前的注册信息：

<http://www.arm.linux.org.uk/developer/machines/>

# 内核入口（head.S）

--------------------------

内核的初始入口是通过`head.S`，它使用与机器无关的代码。机器由入口时`r1`的值选择，该值必须保持唯一。

由于 Linux 的 ARM 端口提供了大量的机器，我们有一个方法来管理这一点，以确保我们不会最终复制大量的代码。

我们将机器（或平台）支持代码分组为机器类。一个类通常基于一个或多个片上系统设备，并作为实际实现的自然容器。这些类被赋予目录 - `arch/arm/mach-<class>`和`arch/arm/mach-<class>` - 其中包含支持机器类的源文件/包含`mach`。这些目录还包含任何特定于机器的支持代码。

例如，SA1100 类基于 SA1100 和 SA1110 SoC 设备，并包含支持板载和板外设备使用方式或设备设置的代码，并提供特定于机器的“个性”。

对于支持设备树（DT）的平台，机器选择在运行时通过将设备树 blob 传递给内核来控制。在编译时，必须选择机器类型的支持。这允许使用单个多平台内核构建来支持多种机器类型。

对于不使用设备树的平台，此机器选择由机器类型 ID 控制，该 ID 既用作运行时代码选择方法，也用作编译时代码选择方法。你可以通过以下网站注册新机器：

<http://www.arm.linux.org.uk/developer/machines/>

注意：请勿为仅支持设备树的平台注册机器类型。如果你的平台仅支持设备树，则不需要注册机器类型。

---

Russell King（2004 年 3 月 15 日）