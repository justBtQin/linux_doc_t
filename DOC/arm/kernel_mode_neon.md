# 内核模式 NEON

================

TL;DR 总结

-------------

* 仅使用 NEON 指令，或不依赖支持代码的 VFP 指令

* 将你的 NEON 代码隔离在一个单独的编译单元中，并使用“-mfpu=neon -mfloat-abi=softfp”进行编译

* 在调用你的 NEON 代码周围放置 kernel_neon_begin()和 kernel_neon_end()调用

* 不要在你的 NEON 代码中睡眠，并注意它将在抢占被禁用的情况下执行

# 介绍

------------

在以内核模式运行的代码中，可以使用 NEON 指令（在某些情况下，还可以使用 VFP 指令）。然而，出于性能原因，NEON/VFP 寄存器文件不会像普通寄存器文件那样在每次上下文切换或发生异常时被保存和恢复，因此需要一些手动干预。此外，对于可能睡眠的代码（即可能调用 schedule()），需要特别注意，因为出于以下概述的原因，NEON 或 VFP 指令将在不可抢占的部分执行。

# 延迟保存和恢复

-------------------------

NEON/VFP 寄存器文件使用延迟保存（在 UP 系统上）和延迟恢复（在 SMP 和 UP 系统上）进行管理。这意味着寄存器文件保持“活动”状态，仅在多个任务争用 NEON/VFP 单元时（或者在 SMP 情况下，当一个任务迁移到另一个核心时）才会被保存和恢复。延迟恢复是通过在每次上下文切换后禁用 NEON/VFP 单元来实现的，当随后发出 NEON/VFP 指令时，会导致陷阱，允许内核介入并在必要时执行恢复。

在内核模式下使用 NEON/VFP 单元不应干扰此过程，因此需要对 NEON/VFP 寄存器文件进行“急切”保存，并显式启用 NEON/VFP 单元，以确保在首次后续使用时不会生成异常。这由函数 kernel_neon_begin()处理，该函数应在发出任何内核模式 NEON 或 VFP 指令之前调用。同样，在使用后应再次禁用 NEON/VFP 单元，以确保用户模式在下次使用时会命中延迟恢复陷阱。这由函数 kernel_neon_end()处理。

# 内核模式中的中断

----------------------------

出于性能和简单性的原因，决定为内核模式 NEON/VFP 寄存器内容不提供保存/恢复机制。这意味着，只有在保证不会触及 NEON/VFP 寄存器的情况下，才允许中断内核模式 NEON 部分。因此，在内核中适用以下规则和限制：

* 中断上下文不允许使用 NEON/VFP 代码；

* NEON/VFP 代码不允许睡眠；

* NEON/VFP 代码在抢占被禁用的情况下执行。

如果对延迟有顾虑，可以在代码中没有任何 NEON 寄存器处于活动状态的地方放置连续的 kernel_neon_end()和 kernel_neon_begin()调用。（如果在此期间没有发生上下文切换，对 kernel_neon_begin()的额外调用应该相当便宜）

# VFP 和支持代码

--------------------

早期版本的 VFP（在版本 3 之前）依赖于软件支持来处理诸如 IEEE-754 兼容下溢处理等事情。当 VFP 单元需要此类软件协助时，它会通过引发未定义指令异常来通知内核。内核会通过检查 VFP 控制寄存器和当前指令及参数来响应，并在软件中模拟该指令。

目前，对于在内核模式下执行的 VFP 指令，未实现此类软件协助。如果遇到此类情况，内核将失败并生成 OOPS。

# 将 NEON 代码与普通代码分离

---------------------------------------

编译器不知道 kernel_neon_begin()和 kernel_neon_end()的特殊意义，即仅允许在对这些函数的调用之间发出 NEON/VFP 指令。此外，如果选择了-mfpu=neon，GCC 在 -O3 级别可能会生成自己的 NEON 指令，即使内核当前在 -O2 级别编译，如果不采取特殊措施，未来的更改可能会导致 NEON/VFP 指令出现在意外的位置。

因此，在内核中使用 NEON/VFP 的推荐且唯一支持的方法是遵循以下规则：

* 将 NEON 代码隔离在一个单独的编译单元中，并使用“-mfpu=neon -mfloat-abi=softfp”进行编译；

* 从未设置 GCC 标志“-mfpu=neon”的编译单元中发出对 kernel_neon_begin()、kernel_neon_end()的调用以及对包含 NEON 代码的单元的调用。

由于内核是使用“-msoft-float”编译的，上述方法将保证在任何优化级别下，NEON 和 VFP 指令都只会出现在指定的编译单元中。

# NEON 汇编器

--------------

只要遵循上述规则，就可以支持 NEON 汇编器，且没有其他限制。

# GCC 生成的 NEON 代码

--------------------------

GCC 选项 -ftree-vectorize（由 -O3 隐含）尝试利用隐式并行性，并从普通 C 源代码生成 NEON 代码。只要遵循上述规则，这就完全受支持。

# NEON 内在函数

---------------

NEON 内在函数也受支持。然而，由于使用 NEON 内在函数的代码依赖于 GCC 头文件<arm_neon.h>（它包含< stdint.h>），除了上述规则外，你还应注意以下几点：

* 使用“-ffreestanding”编译包含 NEON 内在函数的单元，以便 GCC 使用其内置版本的< stdint.h>（这是内核不提供的 C99 头文件）；

* 最后包含<arm_neon.h>，或者至少在<linux/types.h>之后包含。