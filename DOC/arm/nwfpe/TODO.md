# 待办事项清单

---------

POW{条件}<S|D|E>{P,M,Z} Fd, Fn, <Fm,#值> - 幂

RPW{条件}<S|D|E>{P,M,Z} Fd, Fn, <Fm,#值> - 反向幂

POL{条件}<S|D|E>{P,M,Z} Fd, Fn, <Fm,#值> - 极角（反正切 2）

LOG{条件}<S|D|E>{P,M,Z} Fd, <Fm,#值> - 以 10 为底的对数

LGN{条件}<S|D|E>{P,M,Z} Fd, <Fm,#值> - 以 e 为底的对数

EXP{条件}<S|D|E>{P,M,Z} Fd, <Fm,#值> - 指数

SIN{条件}<S|D|E>{P,M,Z} Fd, <Fm,#值> - 正弦

COS{条件}<S|D|E>{P,M,Z} Fd, <Fm,#值> - 余弦

TAN{条件}<S|D|E>{P,M,Z} Fd, <Fm,#值> - 正切

ASN{条件}<S|D|E>{P,M,Z} Fd, <Fm,#值> - 反正弦

ACS{条件}<S|D|E>{P,M,Z} Fd, <Fm,#值> - 反余弦

ATN{条件}<S|D|E>{P,M,Z} Fd, <Fm,#值> - 反正切

这些尚未实现。它们目前不是由编译器发出的，而是由 libc 中的例程处理的。这些不是由 FPA11 硬件实现的，而是由浮点支持代码处理的。它们应该在未来的版本中实现。

有几种方法可以实现这些。一种方法是为这些例程使用精确的表方法。我有一些来自以色列海法的 IBM 研究实验室的 S. Gal 的论文，似乎承诺了极高的精度（在 99.8%的数量级）和合理的速度。这些方法在 GLIBC 中用于一些超越函数。

另一种方法，我对此知之甚少，是 CORDIC。这代表坐标旋转数字计算机，是一种使用大部分移位和加法以及一些乘法和除法来计算超越函数的方法。ARM 在移位和加法方面表现出色，所以这种方法可能很有前途，但需要更多的研究来确定它是否可行。

舍入方法

IEEE 标准定义了 4 种舍入模式。就近舍入是默认的，但也允许舍入到正无穷或负无穷或舍入到零。许多架构允许通过修改控制寄存器中的位来指定舍入模式。但对于 ARM FPA11 架构并非如此。要更改舍入模式，必须在每个指令中指定它。

这使得移植一些基准测试变得困难。可以在模拟器中引入这种功能。FPCR 包含描述舍入模式的位。可以修改模拟器以检查一个标志，如果设置该标志，它将忽略指令中的舍入模式，并使用 FPCR 中的位指定的模式。这需要一种获取/设置标志以及 FPCR 中的位的方法。在 ArmLinux 中，这需要一个内核调用，因为 WFC/RFC 是仅在管理程序中的指令。如果有人有任何想法或意见，我希望听到它们。

[注意：从关于 ARM 浮点的一些文档中提取，特别是针对 Acorn FPE，但不限于它：

浮点控制寄存器（FPCR）可能仅在某些实现中存在：它存在于以特定于实现的方式控制硬件，例如禁用浮点系统。ARM 的用户模式不允许使用此寄存器（因为有权在实现之间更改它），并且如果在用户模式下尝试使用 WFC 和 RFC 指令，它们将陷阱。

因此，答案是可以这样做，但当硬件 FP 仿真出现时，您将面临很高的隔离风险

 - Russell]