似乎在 `exp(double)` 和我们的模拟器之间存在一个问题。我还未能追踪到它。这在 Russell King 提供的模拟器中不会发生。

我还在模拟器中发现了一个奇怪之处。我认为它并不严重，但还是会指出。ARM 调用约定要求在函数调用期间保留浮点寄存器 `f4 - f7`。编译器经常在进入函数时使用 `stfe` 指令将 `f4` 保存到堆栈中，并在返回之前使用 `ldfe` 指令恢复它。

我正在查看一些代码，它计算了一个双精度结果，将其存储在 `f4` 中，然后进行了一个函数调用。在从函数调用返回时，`f4` 中的数字在模拟器中已被转换为扩展值。

这是 `stfe` 指令的一个副作用。`f4` 中的双精度数必须转换为扩展数，然后再进行存储。如果使用了 `lfm/sfm` 组合，那么就不会发生转换。这具有性能方面的考虑。函数调用的结果和 `f4` 在乘法中被使用。如果模拟器看到一个双精度数和扩展数的乘法，它会将双精度数提升为扩展数，然后以扩展精度进行乘法。

这段代码将导致这个问题：

```c
double x, y, z;
z = log(x)/log(y);
```

`log(x)`（一个双精度数）的结果将被计算，在 `f0` 中返回，然后移动到 `f4` 中以在 `log(y)` 调用期间保留它。由于在 `log(y)` 中用于保存 `f4` 的 `stfe` 指令，除法将以扩展精度进行。

```

请注意，以上只是对代码和相关描述的翻译和格式转换，具体的代码含义和问题可能需要结合具体的编程环境和上下文来理解。