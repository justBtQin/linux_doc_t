# Linux I2C 从设备接口描述
=====================================

作者：Wolfram Sang <wsa@sang-engineering.com>（2014 - 15 年）

如果 I2C 控制器具有从设备支持，Linux 也可以作为 I2C 从设备。除了这个硬件要求，还需要一个提供实际功能的软件后端。一个例子是 `slave-eeprom` 驱动程序，它作为一个双重内存驱动程序。当总线上的另一个 I2C 主设备可以像访问常规 EEPROM 一样访问它时，Linux I2C 从设备可以通过 sysfs 访问内容，并根据需要检索/提供信息。软件后端驱动程序和 I2C 总线驱动程序通过事件进行通信。这里是一个小图表，可视化了数据流和数据传输的方式。虚线仅标记了一个示例。后端也可以使用例如字符设备、仅在内核中，或者完全不同的东西：

              e.g. sysfs        I2C slave events        I/O registers
  +-----------+   v    +---------+     v     +--------+  v  +------------+
  | Userspace +........+ Backend +-----------+ Driver +-----+ Controller |
  +-----------+        +---------+           +--------+     +------------+
                                                                | |
  ----------------------------------------------------------------+--  I2C
  --------------------------------------------------------------+----  Bus

注意：从技术上讲，后端和驱动程序之间还有 I2C 核心。然而，在撰写本文时，该层是透明的。

# 用户手册
===========

I2C 从设备后端的行为类似于标准的 I2C 客户端。因此，您可以按照“instantiating-devices”文档中所述对其进行实例化。从用户空间在总线 1 上的地址 0x64 实例化 `slave-eeprom` 驱动程序的快速示例：

```
# echo slave-24c02 0x64 > /sys/bus/i2c/devices/i2c-1/new_device
```

每个后端都应该有单独的文档来描述其特定的行为和设置。

# 开发人员手册
================

**I2C 从设备事件**
----------------

总线驱动程序使用以下函数向后端发送事件：

```c
ret = i2c_slave_event(client, event, &val)
```

`client` 描述了 I2C 从设备。`event` 是后文描述的特殊事件类型之一。`val` 保存要读/写的数据字节的 `u8` 值，因此是双向的。即使 `val` 未用于事件，也必须始终提供 `val` 的指针，即此处不要使用 `NULL`。`ret` 是后端的返回值。总线驱动程序必须提供强制事件，后端驱动程序必须检查这些事件。

事件类型：

* `I2C_SLAVE_WRITE_REQUESTED`（强制）

`val`：未使用
`ret`：始终为 0

另一个 I2C 主设备想要向我们写入数据。一旦检测到我们自己的地址和写位，就应该发送此事件。数据尚未到达，因此没有要处理或返回的内容。不过，可能需要进行唤醒或初始化。

* `I2C_SLAVE_READ_REQUESTED`（强制）

`val`：后端返回要发送的第一个字节
`ret`：始终为 0

另一个 I2C 主设备想要从我们这里读取数据。一旦检测到我们自己的地址和读位，就应该发送此事件。返回后，总线驱动程序应该传输第一个字节。

* `I2C_SLAVE_WRITE_RECEIVED`（强制）

`val`：总线驱动程序传递接收到的字节
`ret`：如果字节应该被确认，则为 0；如果字节应该被不确认，则为某个 `errno`

另一个 I2C 主设备已向我们发送了一个字节，该字节需要设置在 `val` 中。如果 `ret` 为 0，总线驱动程序应该确认此字节。如果 `ret` 为 `errno`，则该字节应该被不确认。

* `I2C_SLAVE_READ_PROCESSED`（强制）

`val`：后端返回要发送的下一个字节
`ret`：始终为 0

总线驱动程序在 `val` 中请求要发送给另一个 I2C 主设备的下一个字节。重要：这并不意味着前一个字节已被确认，它仅意味着前一个字节已移位到总线上！为了确保无缝传输，大多数硬件在前一个字节仍在移位时请求下一个字节。如果主设备发送 `NACK` 并在当前移位的字节之后停止读取，此处请求的此字节从未使用。不过，根据您的后端，很可能需要在下次 `I2C_SLAVE_READ_REQUEST` 时再次发送。

* `I2C_SLAVE_STOP`（强制）

`val`：未使用
`ret`：始终为 0

收到停止条件。这可能随时发生，后端应该重置其 I2C 传输的状态机，以便能够接收新的请求。

**软件后端**
-----------------

如果您要编写软件后端：

* 使用标准的 `i2c_driver` 及其匹配机制
* 编写处理上述从设备事件的 `slave_callback`（最好使用状态机）
* 通过 `i2c_slave_register()` 注册此回调

以 `i2c-slave-eeprom` 驱动程序为例进行检查。

**总线驱动程序支持**
------------------

如果您要向总线驱动程序添加从设备支持：

* 实现注册/注销从设备的调用，并将其添加到 `struct i2c_algorithm` 中。注册时，您可能需要设置 I2C 从设备地址并启用从设备特定的中断。如果您使用运行时电源管理，您应该使用 `pm_runtime_forbid()`，因为您的设备通常需要始终通电才能检测到其从设备地址。注销时，执行上述操作的逆操作。

* 捕获从设备中断并向后端发送适当的 `i2c_slave_events`。

以 `i2c-rcar` 驱动程序为例进行检查。

**关于 ACK/NACK**
--------------

始终确认地址阶段是良好的行为，因此主设备知道设备是否基本存在或是否神秘消失。使用 NACK 表示忙碌是有问题的。SMBus 要求始终确认地址阶段，而 I2C 规范在这方面较为宽松。大多数 I2C 控制器在检测到其从设备地址时也会自动确认，因此无法对其进行 NACK。由于这些原因，此 API 在地址阶段不支持 NACK。

目前，没有从设备事件报告主设备在从我们这里读取时是否确认或不确认了一个字节。如果需要，我们可以将其作为可选事件。然而，这种情况应该极为罕见，因为主设备在此之后预计会发送 STOP，并且我们有针对此的事件。另外，请记住并非所有 I2C 控制器都有可能报告该事件。

**关于缓冲区**
-------------

在开发此 API 期间，出现了使用缓冲区而不是仅字节的问题。这种扩展可能是可能的，但在撰写本文时其有用性尚不清楚。使用缓冲区时需要记住以下几点：

* 缓冲区应该是可选的，并且从设备驱动程序始终必须支持基于字节的事务作为最终的回退，因为这是大多数硬件的工作方式。

* 对于模拟硬件寄存器的后端，缓冲区没有帮助，因为在写入时应立即触发操作。对于读取，缓冲区中的数据可能会过时。

* 主设备可以随时发送 STOP。对于部分传输的缓冲区，这意味着需要额外的代码来处理此异常。这种代码往往容易出错。