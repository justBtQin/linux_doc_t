# 如何实例化 I2C 设备
==============================

与 PCI 或 USB 设备不同，I2C 设备不在硬件级别进行枚举。相反，软件必须知道每个 I2C 总线段上连接了哪些设备，以及这些设备使用的地址。因此，内核代码必须显式地实例化 I2C 设备。根据上下文和需求，有几种实现此目的的方法。

**方法 1a：按总线编号声明 I2C 设备**
------------------------------------------------

当 I2C 总线是系统总线（如许多嵌入式系统的情况）时，此方法适用。在这样的系统上，每个 I2C 总线都有一个预先已知的编号。因此，可以预先声明存在于该总线上的 I2C 设备。这是通过调用 `i2c_register_board_info()` 注册的 `struct i2c_board_info` 数组来完成的。

示例（来自 omap2 h4）：

```c
static struct i2c_board_info h4_i2c_board_info[] __initdata = {
    {
        I2C_BOARD_INFO("isp1301_omap", 0x2d),
       .irq        = OMAP_GPIO_IRQ(125),
    },
    {   /* EEPROM 在主板上 */
        I2C_BOARD_INFO("24c01", 0x52),
       .platform_data    = &m24c01,
    },
    {   /* EEPROM 在 CPU 卡上 */
        I2C_BOARD_INFO("24c01", 0x57),
       .platform_data    = &m24c01,
    },
};

static void __init omap_h4_init(void)
{
    (...)
    i2c_register_board_info(1, h4_i2c_board_info,
            ARRAY_SIZE(h4_i2c_board_info));
    (...)
}
```

上述代码在 I2C 总线 1 上声明了 3 个设备，包括它们各自的地址和其驱动程序所需的自定义数据。当相关的 I2C 总线注册时，I2C 设备将由 i2c-core 自动实例化。

当它们所在的 I2C 总线消失（如果有）时，设备将自动解除绑定并销毁。

**方法 1b：通过设备树声明 I2C 设备**
-------------------------------------------------

此方法与方法 1a 具有相同的含义。这里通过设备树作为主控制器的子节点来声明 I2C 设备。

示例：

```
i2c1: i2c@400a0000 {
    /*... 主属性省略... */
    clock-frequency = <100000>;

    flash@50 {
        compatible = "atmel,24c256";
        reg = <0x50>;
    };

    pca9532: gpio@60 {
        compatible = "nxp,pca9532";
        gpio-controller;
        #gpio-cells = <2>;
        reg = <0x60>;
    };
};
```

这里，两个设备以 100kHz 的速度连接到总线上。有关设置设备可能需要的其他属性，请参考其在 `Documentation/devicetree/bindings/` 中的设备树文档。

**方法 1c：通过 ACPI 声明 I2C 设备**
-------------------------------------------

ACPI 也可以描述 I2C 设备。目前相关的特殊文档位于 `Documentation/acpi/enumeration.txt`。

**方法 2：显式实例化设备**
--------------------------------------------

当较大的设备使用 I2C 总线进行内部通信时，此方法适用。典型的情况是电视适配器。这些设备可能有调谐器、视频解码器、音频解码器等，通常通过 I2C 总线连接到主芯片。您事先不知道 I2C 总线的编号，因此无法使用上述方法 1。相反，您可以显式地实例化您的 I2C 设备。这是通过填充 `struct i2c_board_info` 并调用 `i2c_new_device()` 来完成的。

示例（来自 sfe4001 网络驱动程序）：

```c
static struct i2c_board_info sfe4001_hwmon_info = {
    I2C_BOARD_INFO("max6647", 0x4e),
};

int sfe4001_init(struct efx_nic *efx)
{
    (...)
    efx->board_info.hwmon_client =
        i2c_new_device(&efx->i2c_adap, &sfe4001_hwmon_info);

    (...)
}
```

上述代码在相关网络适配器上的 I2C 总线上实例化了 1 个 I2C 设备。

一种变体是当您不确定 I2C 设备是否存在（例如对于主板的廉价变体中不存在的可选功能，但您无法区分它们），或者它在不同的主板上可能具有不同的地址（制造商在未通知的情况下更改其设计）。在这种情况下，您可以调用 `i2c_new_probed_device()` 而不是 `i2c_new_device()`。

示例（来自 nxp OHCI 驱动程序）：

```c
static const unsigned short normal_i2c[] = { 0x2c, 0x2d, I2C_CLIENT_END };

static int usb_hcd_nxp_probe(struct platform_device *pdev)
{
    (...)
    struct i2c_adapter *i2c_adap;
    struct i2c_board_info i2c_info;

    (...)
    i2c_adap = i2c_get_adapter(2);
    memset(&i2c_info, 0, sizeof(struct i2c_board_info));
    strlcpy(i2c_info.type, "isp1301_nxp", I2C_NAME_SIZE);
    isp1301_i2c_client = i2c_new_probed_device(i2c_adap, &i2c_info,
                               normal_i2c, NULL);
    i2c_put_adapter(i2c_adap);
    (...)
}
```

上述代码在相关的 OHCI 适配器上的 I2C 总线上最多实例化 1 个 I2C 设备。它首先尝试地址 0x2c，如果在那里没有找到任何东西，它尝试地址 0x2d，如果仍然没有找到，它就简单地放弃。

实例化 I2C 设备的驱动程序负责在清理时销毁它。这是通过在早期由 `i2c_new_device()` 或 `i2c_new_probed_device()` 返回的指针上调用 `i2c_unregister_device()` 来完成的。

**方法 3：为某些设备探测 I2C 总线**
----------------------------------------------

有时您没有关于 I2C 设备的足够信息，甚至无法调用 `i2c_new_probed_device()`。典型的情况是 PC 主板上的硬件监控芯片。有几十种型号，可以存在于 25 个不同的地址。鉴于存在大量的主板，几乎不可能构建正在使用的硬件监控芯片的详尽列表。幸运的是，大多数这些芯片都有制造商和设备 ID 寄存器，因此可以通过探测来识别。

在这种情况下，I2C 设备既未声明也未显式实例化。相反，一旦其驱动程序加载，i2c-core 将探测此类设备，如果找到任何设备，将自动实例化 I2C 设备。为了防止此机制的任何不当行为，适用以下限制：
* I2C 设备驱动程序必须实现 `detect()` 方法，该方法通过从任意寄存器读取来识别支持的设备。
* 只有可能具有支持设备并同意被探测的总线才会被探测。例如，这避免了在电视适配器上探测硬件监控芯片。

示例：
查看 `drivers/hwmon/lm90.c` 中的 `lm90_driver` 和 `lm90_detect()`

作为成功探测的结果而实例化的 I2C 设备将在检测到它们的驱动程序被删除时，或者在底层 I2C 总线本身被销毁时自动销毁，以先发生者为准。

熟悉 2.4 内核和早期 2.6 内核的 i2c 子系统的人会发现，此方法 3 本质上与当时的做法相似。两个显著的区别是：
* 探测现在只是实例化 I2C 设备的一种方式，而当时它是唯一的方式。在可能的情况下，应优先使用方法 1 和 2。方法 3 仅应在没有其他方法时使用，因为它可能具有不良副作用。
* I2C 总线现在必须明确说明哪些 I2C 驱动程序类可以探测它们（通过类位域），而当时默认情况下所有 I2C 总线都被探测。默认值是一个空类，这意味着不会进行探测。类位域的目的是限制上述不良副作用。

再次强调，应尽可能避免方法 3。显式设备实例化（方法 1 和 2）更受欢迎，因为它更安全、更快。

**方法 4：从用户空间实例化**
-------------------------------------

通常，内核应该知道连接了哪些 I2C 设备以及它们所在的地址。但是，在某些情况下，它不知道，因此添加了一个 sysfs 接口，让用户提供信息。此接口由在每个 I2C 总线目录中创建的 2 个属性文件组成：`new_device` 和 `delete_device`。这两个文件都是只写的，您必须向它们写入正确的参数，以分别正确地实例化或删除 I2C 设备。

文件 `new_device` 接受 2 个参数：I2C 设备的名称（字符串）和 I2C 设备的地址（数字，通常以 0x 开头的十六进制表示，但也可以用十进制表示）。

文件 `delete_device` 接受一个参数：I2C 设备的地址。由于在给定的 I2C 段上没有两个设备可以位于相同的地址，因此地址足以唯一标识要删除的设备。

示例：
```
# echo eeprom 0x50 > /sys/bus/i2c/devices/i2c-3/new_device
```

虽然此接口仅应在无法在内核中进行设备声明时使用，但在多种情况下它可能会有所帮助：
* I2C 驱动程序通常会检测设备（上述方法 3），但您的设备所在的总线段没有设置正确的类位，因此检测不会触发。
* I2C 驱动程序通常会检测设备，但您的设备位于意外的地址。
* I2C 驱动程序通常会检测设备，但您的设备未被检测到，要么是因为检测例程过于严格，要么是因为您的设备尚未得到官方支持，但您知道它是兼容的。
* 您正在测试板上开发驱动程序，您自己焊接了 I2C 设备。

此接口替代了一些 I2C 驱动程序实现的 `force_*` 模块参数。由于是在 i2c-core 中实现，而不是在每个设备驱动程序中单独实现，因此效率更高，并且还具有无需重新加载驱动程序即可更改设置的优点。您还可以在驱动程序加载甚至可用之前实例化设备，并且您不需要知道设备需要什么驱动程序。