<markdown_document>

# 7: 高级主题

到目前为止，希望你已经掌握了开发过程的工作原理。然而，还有更多的东西需要学习！本节将涵盖一些对希望成为 Linux 内核开发过程中常规部分的开发人员有帮助的主题。

## 7.1: 使用 Git 管理补丁

内核使用分布式版本控制始于 2002 年初，当时 Linus 首次开始使用专有的 BitKeeper 应用程序。虽然 BitKeeper 存在争议，但它所体现的软件版本管理方法肯定不是。分布式版本控制使内核开发项目立即加速。在当前，有几个免费的 BitKeeper 替代品。不管是好是坏，内核项目已经选择了 git 作为其首选工具。

使用 git 管理补丁可以使开发人员的生活轻松很多，特别是随着这些补丁数量的增加。Git 也有其粗糙的边缘和一定的危险；它是一个年轻而强大的工具，仍在被其开发人员驯化。本文档不会尝试教读者如何使用 git；这本身就足以写成一篇长篇文档。相反，这里的重点将特别放在 git 如何融入内核开发过程中。希望快速掌握 git 的开发人员可以在以下位置找到更多信息：

- http://git-scm.com/

- http://www.kernel.org/pub/software/scm/git/docs/user-manual.html

以及在网上找到的各种教程。

首先要做的是阅读上述网站，并在尝试使用它向他人提供补丁之前，对 git 的工作原理有一个扎实的理解。使用 git 的开发人员应该能够获取主线仓库的副本，探索修订历史，将更改提交到树中，使用分支等。理解 git 用于重写历史的工具（如 rebase）也很有用。Git 有自己的术语和概念；git 的新用户应该了解 refs、远程分支、索引、快进合并、推送和拉取、分离的头等等。一开始可能会有点吓人，但只要稍加学习，这些概念并不难掌握。

使用 git 生成补丁以供通过电子邮件提交是一个很好的练习。

当你准备好开始为他人提供 git 树以供查看时，你当然需要一个可以被拉取的服务器。如果你有一个可以访问互联网的系统，使用 git-daemon 设置这样的服务器相对简单。否则，免费的公共托管站点（例如 Github）开始出现在网络上。有经验的开发人员可以在 kernel.org 上获得一个账户，但这些账户并不容易获得；更多信息请参阅 http://kernel.org/faq/。

正常的 git 工作流程涉及使用大量的分支。每个开发线可以分离到一个单独的“主题分支”中并独立维护。Git 中的分支很便宜，没有理由不自由使用它们。而且，在任何情况下，你都不应该在你打算让他人拉取的任何分支中进行开发。应谨慎创建可公开访问的分支；当补丁处于完整形式并准备好时，将其从开发分支合并到其中 - 而不是之前。

Git 提供了一些强大的工具，可以允许你重写你的开发历史。一个不方便的补丁（例如一个破坏二分法的补丁，或者有其他某种明显的错误）可以在原地修复或从历史中完全消失。一个补丁系列可以重写，就好像它是在今天的主线之上编写的一样，即使你已经在其上工作了几个月。更改可以透明地从一个分支转移到另一个分支。等等。明智地使用 git 重写历史的能力可以帮助创建更干净的补丁集，减少问题。

然而，过度使用此功能会导致其他问题，不仅仅是对创建完美项目历史的简单痴迷。重写历史将重写该历史中包含的更改，将一个经过测试（希望如此）的内核树变成一个未经测试的树。但除此之外，如果开发人员没有对项目历史的共同看法，他们就无法轻松协作；如果你重写了其他开发人员已经拉取到他们的仓库中的历史，你将使这些开发人员的生活更加困难。因此，这里有一个简单的经验法则：已经导出给他人的历史通常应被视为此后不可变的。

因此，一旦你将一组更改推送到你的可公开访问的服务器，这些更改就不应该被重写。如果你尝试推送不会导致快进合并的更改（即不共享相同历史的更改），Git 将尝试强制执行此规则。可以覆盖此检查，并且有时可能需要重写导出的树。在 linux-next 中移动更改集以避免冲突就是一个例子。但这样的操作应该很少见。这是为什么开发应该在私有分支中进行（如果需要可以重写），并且只有在处于相当高级的状态时才移动到公共分支的原因之一。

随着主线（或一组更改所基于的其他树）的推进，很想与该树合并以保持领先地位。对于私有分支，rebase 是保持与另一棵树同步的一种简单方法，但一旦将树导出到世界，rebase 就不是一个选项。一旦发生这种情况，就必须进行完整的合并。偶尔合并是有意义的，但过于频繁的合并会不必要地使历史混乱。在这种情况下，建议的技术是不频繁地合并，并且通常只在特定的发布点（例如主线 -rc 发布）进行。如果你对特定的更改感到紧张，你可以在私有分支中随时进行测试合并。git “rerere”工具在这种情况下很有用；它会记住如何解决合并冲突，这样你就不必重复相同的工作。

关于像 git 这样的工具，最常见的抱怨之一是：大量将补丁从一个存储库移动到另一个存储库使得很容易在审查雷达之下将不明智的更改引入主线。当内核开发人员看到这种情况发生时，他们往往会不高兴；提交一个带有未经审查或偏离主题的补丁的 git 树可能会影响你在未来获取树的能力。引用 Linus 的话：

你可以给我发送补丁，但为了让我从你那里拉取一个 git 补丁，我需要知道你知道自己在做什么，并且我需要能够信任这些东西*而不必然后手动检查每个单独的更改*。

（http://lwn.net/Articles/224135/）。

为了避免这种情况，确保给定分支中的所有补丁都紧密围绕相关主题；“驱动程序修复”分支不应该对核心内存管理代码进行更改。而且，最重要的是，不要使用 git 树绕过审查过程。偶尔在相关列表中发布树的摘要，并在合适的时候请求将树包含在 linux-next 中。

如果其他人开始发送补丁以包含在你的树中，不要忘记审查它们。还要确保你维护正确的作者信息；git “am”工具在这方面做得最好，但如果补丁是通过第三方转发给你的，你可能需要添加一个“From：”行。

在请求拉取时，一定要提供所有相关信息：你的树在哪里，要拉取哪个分支，以及拉取将导致哪些更改。git “request-pull”命令在这方面很有帮助；它将以其他开发人员期望的格式格式化请求，并还将检查以确保你记得将这些更改推送到公共服务器。

## 7.2: 审查补丁

一些读者肯定会反对将本节与“高级主题”放在一起，理由是即使是初学者内核开发人员也应该审查补丁。当然，没有比查看他人发布的代码更好的方法来学习如何在内核环境中编程了。此外，审查人员永远供不应求；通过查看代码，你可以为整个过程做出重大贡献。

审查代码可能是一个令人生畏的前景，特别是对于一个新的内核开发人员来说，他可能会对在公共场合质疑那些经验更丰富的人发布的代码感到紧张。然而，即使是最有经验的开发人员编写的代码也可以改进。也许对于审查人员（所有审查人员）的最好建议是：将审查评论表述为问题而不是批评。问“在这条路径中锁是如何释放的？”总是比说“这里的锁定是错误的”效果更好。

不同的开发人员将从不同的角度审查代码。有些人主要关注编码风格以及代码行是否有尾随空白。其他人将主要关注补丁所实现的整个更改对内核是否是一件好事。还有一些人将检查有问题的锁定、过多的堆栈使用、可能的安全问题、在其他地方找到的代码重复、足够的文档、对性能的不利影响、用户空间 ABI 更改等。如果所有类型的审查都能导致更好的代码进入内核，那么它们都是受欢迎和有价值的。

</markdown_document>