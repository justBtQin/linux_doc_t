# 5: 提交补丁

迟早，你的工作准备好呈现给社区进行审查，并最终纳入主线内核的时间就会到来。不出所料，内核开发社区已经形成了一套在提交补丁时使用的约定和程序；遵循它们将使涉及的每个人的生活轻松得多。本文件将尝试合理详细地涵盖这些期望；在内核文档目录中的 SubmittingPatches、SubmittingDrivers 和 SubmitChecklist 文件中也可以找到更多信息。

## 5.1: 何时提交

在完全“准备好”之前避免提交补丁的诱惑一直存在。对于简单的补丁，这不是问题。然而，如果正在进行的工作很复杂，在工作完成之前从社区获得反馈会有很多收获。因此，你应该考虑提交进行中的工作，甚至提供一个 git 树，以便感兴趣的开发人员可以随时跟上你的工作。

当提交尚未被认为准备好纳入的代码时，在提交本身中说明这一点是个好主意。还要提及仍需完成的任何主要工作和任何已知问题。较少的人会查看已知不完整的补丁，但那些查看的人会带着可以帮助你将工作推向正确方向的想法而来。

## 5.2: 创建补丁之前

在考虑将补丁发送到开发社区之前，应该做一些事情。这些包括：

- 尽可能多地测试代码。利用内核的调试工具，确保内核可以使用所有合理的配置选项组合进行构建，使用交叉编译器为不同的体系结构构建等。

- 确保你的代码符合内核编码风格指南。

- 你的更改有性能影响吗？如果有，你应该运行基准测试，以显示你的更改的影响（或好处）；结果摘要应包含在补丁中。

- 确保你有权发布代码。如果这项工作是为雇主完成的，雇主可能对该工作拥有权利，并且必须同意在 GPL 下发布。

一般来说，在提交代码之前多花一些心思通常会很快得到回报。

## 5.3: 补丁准备

为提交准备补丁可能是一项令人惊讶的大量工作，但同样，即使在短期内，试图在这里节省时间通常也不是明智的。

补丁必须针对特定版本的内核进行准备。一般来说，补丁应该基于 Linus 的 git 树中的当前主线。基于主线时，从一个知名的发布点 - 稳定或 -rc 版本 - 开始，而不是在任意点从主线分支。

然而，可能需要针对 -mm、linux-next 或子系统树创建版本，以促进更广泛的测试和审查。根据补丁的区域和其他地方的情况，基于这些其他树的补丁可能需要大量工作来解决冲突和处理 API 更改。

只有最简单的更改应该格式化为单个补丁；其他所有内容都应该作为一系列逻辑更改进行。拆分补丁是一门艺术；一些开发人员会花费很长时间来弄清楚如何以社区期望的方式进行拆分。然而，有一些经验法则可以提供很大的帮助：

- 你提交的补丁系列几乎肯定不会是你工作的版本控制系统中找到的更改系列。相反，你所做的更改需要以其最终形式考虑，然后以有意义的方式拆分。开发人员感兴趣的是离散的、自包含的更改，而不是你到达这些更改的路径。

- 每个逻辑上独立的更改都应该格式化为一个单独的补丁。这些更改可以很小（“向此结构添加一个字段”）或很大（例如添加一个重要的新驱动程序），但它们在概念上应该很小，并且适合一行描述。每个补丁都应该进行特定的更改，这些更改可以单独进行审查并验证其是否按照说明进行操作。

- 作为上述准则的重申：不要在同一个补丁中混合不同类型的更改。如果单个补丁修复了一个关键的安全漏洞、重新排列了一些结构并重新格式化了代码，那么很有可能它会被忽略，重要的修复将丢失。

- 每个补丁都应该生成一个可以正常构建和运行的内核；如果你的补丁系列在中间中断，结果仍然应该是一个可用的内核。当使用“git bisect”工具查找回归时，部分应用补丁系列是一种常见情况；如果结果是一个损坏的内核，你将使从事追踪问题这一高尚工作的开发人员和用户的生活更加困难。

- 不过，不要做得太过。一位开发人员曾经将对单个文件的一组编辑作为 500 个单独的补丁提交 - 这一行为并没有使他成为内核邮件列表上最受欢迎的人。只要仍然包含一个单一的*逻辑*更改，单个补丁就可以相当大。

- 可能会有诱惑通过一系列补丁添加一个全新的基础设施，但在系列中的最后一个补丁启用整个事情之前，让该基础设施处于未使用状态。如果可能，应该避免这种诱惑；如果该系列添加了回归，二分法将指出最后一个补丁是导致问题的原因，即使真正的错误在其他地方。只要有可能，添加新代码的补丁应该立即使该代码处于活动状态。

创建完美的补丁系列可能是一个令人沮丧的过程，在“实际工作”完成后需要花费相当多的时间和思考。然而，当正确完成时，这是值得的时间。

## 5.4: 补丁格式和变更日志

现在你有了一个完美的提交补丁系列，但工作还没有完全完成。每个补丁都需要格式化为一条消息，以便快速而清晰地向世界其他地方传达其目的。为此，每个补丁将由以下部分组成：

- 一个可选的“From”行，命名补丁的作者。如果您通过电子邮件传递其他人的补丁，此行是必要的，但在有疑问时添加它永远不会有坏处。

- 一行描述补丁的作用。这条消息应该足以让没有其他上下文的读者弄清楚补丁的范围；它是将出现在“简短形式”变更日志中的行。这条消息通常以相关子系统名称开头，后跟补丁的目的。例如：

gpio：在 CONFIG_GPIO_SYSFS=n 时修复构建

- 一个空行，后跟补丁内容的详细描述。此描述可以根据需要尽可能长；它应该说明补丁的作用以及为什么应该将其应用于内核。

- 一个或多个标签行，至少有一个来自补丁作者的 Signed-off-by：行。下面将更详细地描述标签。

上述项目一起构成了补丁的变更日志。编写良好的变更日志是一项至关重要但经常被忽视的艺术；值得再花一点时间讨论这个问题。在编写变更日志时，你应该记住，许多不同的人将阅读你的文字。这些人包括子系统维护者和审查者，他们需要决定是否应该包含该补丁；分销商和其他维护者试图决定是否应该将补丁回溯到其他内核；错误追踪者想知道该补丁是否是他们正在追踪的问题的原因；用户想知道内核是如何变化的，等等。一个好的变更日志以最直接和简洁的方式向所有这些人传达所需的信息。

为此，总结行应该在一行限制的情况下尽可能好地描述更改的效果和动机。详细描述可以然后放大这些主题并提供任何所需的额外信息。如果补丁修复了一个错误，请在可能的情况下引用引入该错误的提交（请在引用提交时提供提交 ID 和标题）。如果问题与特定的日志或编译器输出相关，请包含该输出以帮助其他寻找相同问题解决方案的人。如果更改旨在支持后续补丁中的其他更改，请说明。如果内部 API 发生更改，请详细说明这些更改以及其他开发人员应该如何响应。一般来说，你越能站在阅读你变更日志的每个人的角度，变更日志（以及整个内核）就会越好。

不用说，变更日志应该是将更改提交到版本控制系统时使用的文本。它将后跟：

- 以统一（“-u”）补丁格式的补丁本身。使用“-p”选项进行 diff 将函数名称与更改相关联，使生成的补丁更易于其他人阅读。

你应该避免在补丁中包含对无关文件的更改（例如由构建过程生成的文件或编辑器备份文件）。Documentation 目录中的“dontdiff”文件可以在这方面提供帮助；将其与“-X”选项一起传递给 diff。

上面提到的标签用于描述各种开发人员如何与该补丁的开发相关联。它们在 SubmittingPatches 文档中有详细描述；以下是一个简要总结。每个这样的行的格式为：

tag: 全名 <电子邮件地址> 可选的其他内容

常用的标签有：

- Signed-off-by：这是开发人员的证明，表明他或她有权提交补丁以纳入内核。这是对开发者原始证书的同意，其全文可以在 Documentation/SubmittingPatches 中找到。没有适当签名的代码不能合并到主线中。

- Acked-by：表示另一个开发人员（通常是相关代码的维护者）同意该补丁适合纳入内核。

- Tested-by：声明指定的人员已经测试了该补丁并发现它可以工作。

- Reviewed-by：指定的开发人员已经审查了该补丁的正确性；有关更多详细信息，请参阅 Documentation/SubmittingPatches 中的审查者声明。

- Reported-by：命名报告由该补丁修复的问题的用户；此标签用于表彰测试我们代码并在事情不正常工作时让我们知道的（通常未被充分认可的）人员。

- Cc：指定的人员收到了该补丁的副本并有机会对其进行评论。

在补丁中添加标签时要小心：只有 Cc：在未经指定人员明确许可的情况下才适合添加。

## 5.5: 发送补丁

在发送补丁之前，你还应该注意一些其他事情：

- 你确定你的邮件客户端不会损坏补丁吗？被邮件客户端执行了不必要的空白更改或换行的补丁在另一端将无法应用，并且通常不会被详细检查。如果有任何疑问，将补丁发送给自己并确信它完整显示。

Documentation/email-clients.txt 中有一些关于使特定邮件客户端适用于发送补丁的有用提示。

- 你确定你的补丁没有愚蠢的错误吗？你应该始终通过 scripts/checkpatch.pl 运行补丁并解决它提出的问题。请记住，checkpatch.pl 虽然体现了对内核补丁应该是什么样子的大量思考，但并不比你聪明。如果修复 checkpatch.pl 的投诉会使代码更糟，不要这样做。

补丁应该始终以纯文本形式发送。请不要将它们作为附件发送；这使得审查者在回复中引用补丁的部分更加困难。相反，只需将补丁直接放入你的消息中。

发送补丁时，重要的是将副本发送给可能对此感兴趣的任何人。与其他一些项目不同，内核鼓励人们犯错，即发送过多的副本；不要假设相关人员会在邮件列表中看到你的帖子。特别是，副本应该发送给：

- 受影响子系统的维护者。如前所述，MAINTAINERS 文件是查找这些人的第一个地方。

- 在同一领域工作的其他开发人员 - 特别是那些现在可能正在那里工作的人。使用 git 查看还有谁修改了你正在处理的文件可能会有所帮助。

- 如果您正在响应错误报告或功能请求，请复制原始发布者。

- 发送副本到相关的邮件列表，或者，如果没有其他适用的，发送到 linux-kernel 列表。

- 如果您正在修复一个错误，请考虑该修复是否应该进入下一个稳定更新。如果是这样，stable@vger.kernel.org 应该收到该补丁的副本。还应在补丁本身的标签中添加“Cc: stable@vger.kernel.org”；这将导致稳定团队在你的修复进入主线时收到通知。

在选择补丁的收件人时，最好有一个想法，即你认为谁最终会接受该补丁并将其合并。虽然可以直接将补丁发送给 Linus Torvalds 并让他合并它们，但通常不会以这种方式进行。Linus 很忙，并且有子系统维护者负责内核的特定部分。通常你会希望该维护者合并你的补丁。如果没有明显的维护者，Andrew Morton 通常是最后的求助补丁目标。

补丁需要良好的主题行。补丁行的规范格式类似于：

[PATCH nn/mm] subsys: 补丁的一行描述

其中“nn”是补丁的序号，“mm”是系列中的补丁总数，“subsys”是受影响子系统的名称。显然，对于单个独立的补丁，可以省略 nn/mm。

如果有一个重要的补丁系列，通常会发送一个介绍性描述作为第 0 部分。然而，这个约定并不是普遍遵循的；如果你使用它，请记住介绍中的信息不会进入内核变更日志。因此，请确保补丁本身具有完整的变更日志信息。

一般来说，多部分补丁的第二部分及后续部分应该作为对第一部分的回复发送，以便在接收端它们都能串联在一起。

像 git 和 quilt 这样的工具具有将一系列补丁通过邮件发送出去且带有正确线程的命令。

如果有一系列的补丁，并且正在使用 git，那么请远离 --chain-reply-to 选项，以避免创建异常深的嵌套。

</markdown_document>