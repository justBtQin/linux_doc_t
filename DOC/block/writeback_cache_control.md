显式易失性回写缓存控制

=====================================

# 引言

------------

许多存储设备，特别是在消费市场，都带有易失性回写缓存。这意味着设备在数据实际写入非易失性存储之前，就向操作系统发出 I/O 完成信号。这种行为显然加快了各种工作负载，但也意味着操作系统在执行数据完整性操作（如 fsync、sync 或卸载）时，需要将数据强制写入非易失性存储。

Linux 块层提供了两种简单机制，让文件系统控制存储设备的缓存行为。这些机制是强制缓存刷新和请求的强制单元访问（FUA）标志。

# 显式缓存刷新

----------------------

可以将 REQ_FLUSH 标志或入从文件系统提交的 bio 的读写标志中，并确保在实际 I/O 操作开始之前，存储设备的易失性缓存已被刷新。这明确保证在标记的 bio 开始之前，先前完成的写请求已位于非易失性存储中。此外，可以在其他为空的 bio 结构上设置 REQ_FLUSH 标志，这只会导致显式缓存刷新，而没有任何依赖的 I/O。建议使用 blkdev_issue_flush()辅助函数进行纯缓存刷新。

# 强制单元访问

-----------------

可以将 REQ_FUA 标志或入从文件系统提交的 bio 的读写标志中，并确保此请求的 I/O 完成仅在数据提交到非易失性存储后才发出信号。

# 文件系统的实现细节

--------------------------------------

文件系统可以简单地设置 REQ_FLUSH 和 REQ_FUA 位，而不必担心底层设备是否需要任何显式缓存刷新，以及强制单元访问是如何实现的。REQ_FLUSH 和 REQ_FUA 标志可以同时设置在单个 bio 上。

#基于 make_request_fn 的块设备驱动程序的实现细节

--------------------------------------------------------------

这些驱动程序将始终看到 REQ_FLUSH 和 REQ_FUA 位，因为它们直接位于 submit_bio 接口之下。对于重新映射驱动程序，需要将 REQ_FUA 位传播到底层设备，并为设置了 REQ_FLUSH 位的 bios 实现全局刷新。对于不具有易失性缓存的实际设备驱动程序，可以简单地忽略非空 bios 上的 REQ_FLUSH 和 REQ_FUA 位，并且可以成功完成没有数据的 REQ_FLUSH 请求，而无需执行任何工作。对于具有易失性缓存的设备的驱动程序，需要自行实现对这些标志的支持，而无需块层的任何帮助。

# 基于 request_fn 的块设备驱动程序的实现细节

--------------------------------------------------------------

对于不支持易失性写缓存的设备，不需要驱动程序支持，块层在进入驱动程序之前完成空的 REQ_FLUSH 请求，并从有有效负载的请求中剥离 REQ_FLUSH 和 REQ_FUA 位。对于具有易失性写缓存的设备，驱动程序需要通过执行以下操作告诉块层它支持刷新缓存：

	blk_queue_flush(sdkp->disk->queue, REQ_FLUSH);

并在其 prep_fn/request_fn 中处理空的 REQ_FLUSH 请求。请注意，带有有效负载的 REQ_FLUSH 请求会自动转换为一个空的 REQ_FLUSH 请求，后跟块层的实际写入。对于也支持 FUA 位的设备，需要使用以下命令告诉块层传递 REQ_FUA 位：

	blk_queue_flush(sdkp->disk->queue, REQ_FLUSH | REQ_FUA);

并且驱动程序必须在 prep_fn/request_fn 中处理设置了 REQ_FUA 位的写请求。如果本机不支持 FUA 位，块层会在实际写入后将其转换为一个空的 REQ_FLUSH 请求。