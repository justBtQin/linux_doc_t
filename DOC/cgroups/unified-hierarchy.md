<markdown_document>

# Cgroup unified hierarchy

**April, 2014** Tejun Heo <tj@kernel.org>

本文档描述了统一层次结构所做的更改及其基本原理。它最终将被合并到主要的 cgroup 文档中。

# 目录

1. 背景

2. 基本操作

    2-1. 挂载

    2-2. cgroup.subtree_control

    2-3. cgroup.controllers

3. 结构约束

    3-1. 自上而下

    3-2. 无内部任务

4. 其他更改

    4-1. [未]填充通知

    4-2. 其他核心更改

    4-3. 每个控制器的更改

        4-3-1. blkio

        4-3-2. cpuset

        4-3-3. memory

5. 计划中的更改

    5-1. 用于资源控制的 CAP

# 1. 背景

cgroup 允许任意数量的层次结构，并且每个层次结构可以承载任意数量的控制器。虽然这似乎提供了高度的灵活性，但在实践中并不十分有用。例如，由于每个控制器只有一个实例，诸如 freezer 之类的实用程序类型控制器在所有层次结构中都很有用，但只能在一个层次结构中使用。更糟糕的是，一旦层次结构被填充，控制器就无法移动。另一个问题是，绑定到一个层次结构的所有控制器都被迫对该层次结构具有完全相同的视图。无法根据特定控制器更改粒度。实际上，这些问题严重限制了哪些控制器可以放在同一个层次结构上，并且大多数配置都采用将每个控制器放在自己的层次结构上的方式。只有密切相关的控制器，如 cpu 和 cpuacct 控制器，才适合放在同一个层次结构上。这通常意味着，每当需要进行层次结构管理操作时，用户空间最终会管理多个相似的层次结构，并在每个层次结构上重复相同的步骤。

不幸的是，支持多个层次结构的成本很高。cgroup 核心内部的实现非常复杂，但更重要的是，对多个层次结构的支持限制了 cgroup 的一般使用方式和控制器的功能。层次结构的数量没有限制，这意味着任务的 cgroup 成员身份无法用有限的长度来描述。键可以包含任意数量的条目，并且长度不受限制，这使得处理起来非常困难，并导致添加了仅用于标识成员身份的控制器，这反过来又加剧了原始问题。

此外，由于控制器无法对其他控制器的层次结构形状有任何期望，每个控制器都必须假设所有其他控制器都在完全正交的层次结构上运行。这使得控制器之间的合作变得不可能，或者至少非常麻烦。

在大多数使用情况下，将控制器放在彼此完全正交的层次结构上并不是必要的。通常需要的是根据特定控制器具有不同的粒度级别。换句话说，从特定控制器的角度来看，层次结构可以从叶节点向根节点折叠。例如，给定的配置可能不在乎在某个级别之上内存是如何分配的，但仍然希望控制 CPU 周期是如何分配的。

统一层次结构是 cgroup 接口的下一个版本。它旨在通过具有更多的结构来解决上述问题，同时为大多数使用情况保留足够的灵活性。在此过程中，还解决了各种其他通用和控制器特定的接口问题。

# 2. 基本操作

## 2-1. 挂载

目前，可以使用以下挂载命令挂载统一层次结构。请注意，这仍在开发中，计划很快更改。

```
mount -t cgroup -o __DEVEL__sane_behavior cgroup $MOUNT_POINT
```
所有支持统一层次结构且未绑定到其他层次结构的控制器都会自动绑定到统一层次结构，并在其根目录下显示。仅在统一层次结构的根目录中启用的控制器可以绑定到其他层次结构。这允许以完全向后兼容的方式将统一层次结构与传统的多个层次结构混合使用。

出于开发目的，以下引导参数使所有控制器都出现在统一层次结构上，无论是否支持。

```
cgroup__DEVEL__legacy_files_on_dfl
```
只有在控制器不再在其当前层次结构中被引用后，才能将控制器在层次结构之间移动。由于每个 cgroup 的控制器状态是异步销毁的，并且控制器可能有持久的引用，因此在先前层次结构的最终卸载后，控制器可能不会立即在统一层次结构中显示。类似地，应该完全禁用控制器才能将其移出统一层次结构，并且禁用的控制器可能需要一些时间才能对其他层次结构可用；此外，由于控制器之间的依赖关系，其他控制器也可能需要被禁用。

虽然对于开发和手动配置很有用，但强烈不建议在生产环境中动态地在统一层次结构和其他层次结构之间移动控制器。建议在开始使用控制器之前确定层次结构和控制器关联。

## 2-2. cgroup.subtree_control

统一层次结构上的所有 cgroup 都有一个“cgroup.subtree_control”文件，用于控制在该 cgroup 的子级上启用哪些控制器。假设存在以下层次结构：

```
root - A - B - C
               \ D
```
root 的“cgroup.subtree_control”文件决定在 A 上启用哪些控制器。A 的在 B 上。B 的在 C 和 D 上。这与直接子级上的控制器用于分配父级资源的事实相吻合。实际上，很自然地假设子级的资源控制旋钮属于其父级。在“cgroup.subtree_control”文件中启用控制器声明将控制该 cgroup 的相应资源的分配。请注意，这意味着控制器启用状态在兄弟之间共享。

读取时，该文件包含一个以空格分隔的当前启用控制器列表。写入该文件时，应包含一个以空格分隔的控制器列表，前面带有'+'或'-'（不带引号）。以'+'前缀的控制器被启用，以'-'前缀的控制器被禁用。如果一个控制器被列出多次，则最后一个条目生效。具体操作是原子执行的 - 要么全部成功，要么全部失败。

## 2-3. cgroup.controllers

只读的“cgroup.controllers”文件包含一个以空格分隔的控制器列表，这些控制器可以在 cgroup 的“cgroup.subtree_control”文件中启用。

在根 cgroup 中，此列表列出了未绑定到其他层次结构的控制器，并且随着控制器绑定到其他层次结构或从其他层次结构解绑，内容会发生变化。

在非根 cgroup 中，此文件的内容等于其父级的“cgroup.subtree_control”文件的内容，因为只能使用从父级启用的控制器在其子女中使用。

# 3. 结构约束

## 3-1. 自上而下

由于嵌套不受控制的资源的控制是没有意义的，所有非根“cgroup.subtree_control”文件只能包含在父级“cgroup.subtree_control”文件中启用的控制器。只有当父级启用了控制器时，才能启用控制器，并且如果一个或多个子级启用了控制器，则不能禁用控制器。

## 3-2. 无内部任务

cgroup 面临的一个长期问题是属于父 cgroup 及其子 cgroup 的任务之间的竞争。这本质上是很棘手的，因为两种不同类型的实体在竞争，并且没有商定的明显处理方式。不同的控制器在做不同的事情。

cpu 控制器将任务和 cgroup 视为等效，并将 nice 级别映射到 cgroup 权重。这在某些情况下有效，但当子级应分配特定比例的 CPU 周期且内部任务数量波动时就不起作用了 - 随着竞争实体数量的波动，比例不断变化。还有其他问题。从 nice 级别到权重的映射并不明显或通用，并且有各种其他旋钮对于任务不可用。

blkio 控制器隐式地为每个 cgroup 创建一个隐藏的叶节点来承载任务。隐藏的叶节点有其自己的所有带有“leaf_”前缀的旋钮的副本。虽然这允许对内部任务进行等效控制，但它有严重的缺点。它总是添加一个额外的嵌套层，这可能不是必要的，使接口混乱并显著增加实现的复杂性。

memory 控制器目前没有办法控制内部任务和子 cgroup 之间发生的事情，并且行为没有明确定义。已经尝试添加临时行为和旋钮来根据特定工作负载调整行为。继续这个方向将导致长期难以解决的问题。

多个控制器都在努力处理内部任务，并提出了不同的处理方式；不幸的是，现在使用的所有方法都存在严重缺陷，而且广泛不同的行为使 cgroup 整体高度不一致。

很明显，这是需要从 cgroup 核心本身以统一的方式解决的问题，以便控制器不需要担心它，并且 cgroup 整体显示出一致和逻辑的行为。为了实现这一点，统一层次结构强制执行以下结构约束：

除了根之外，只有不包含任何任务的 cgroup 才能在其“cgroup.subtree_control”文件中启用控制器。

结合其他属性，这保证了当控制器查看启用了它的层次结构部分时，任务始终只在叶节点上。这排除了子 cgroup 与父级内部任务竞争的情况。

有两点需要注意。首先，根 cgroup 不受此限制。根包含任务和匿名资源消耗，这些消耗无法与任何其他 cgroup 相关联，并且需要大多数控制器的特殊处理。根 cgroup 中的资源消耗如何管理由每个控制器决定。其次，如果 cgroup 的“cgroup.subtree_control”文件中没有启用的控制器，则此限制不生效。这很重要，因为否则将无法创建已填充 cgroup 的子级。要控制 cgroup 的资源分配，cgroup 必须在其“cgroup.subtree_control”文件中启用控制器之前创建子级并将其所有任务转移到子级。

# 4. 其他更改

## 4-1. [未]填充通知

cgroup 用户经常需要一种方法来确定 cgroup 的子层次结构何时变为空，以便可以对其进行清理。cgroup 目前为此提供了 release_agent；不幸的是，此机制存在很多问题。

- 它通过分叉并执行指定为 release_agent 的用户空间二进制文件来传递事件。这是一种早已弃用的通知传递方法。它非常笨重、缓慢且难以与更大的基础架构集成。

- 在根目录处只有一个监控点。无法委托子树的管理。

- 事件不是递归的。当 cgroup 没有任何任务或子 cgroup 时触发事件。内部节点的事件仅在所有子节点被删除后才触发。这再次使得委托子树的管理变得不可能。

- 事件是从内核侧过滤的。使用“notify_on_release”文件来订阅或抑制释放事件。这不必要地复杂，可能是因为事件传递本身很昂贵。

统一层次结构实现了一个接口文件“cgroup.populated”，可用于监控 cgroup 的子层次结构中是否有任务。如果 cgroup 及其后代中没有任务，则其值为 0；否则为 1。当值更改时，会触发 poll 和 [id]notify 事件。

这要轻得多、简单得多，并且可以轻松地委托子层次结构的管理 - 子层次结构监控可以通过将自身或另一个进程放入子层次结构中并从那里监控感兴趣的事件来简单地阻止进一步的传播，而不会干扰树中较高位置的监控。

在统一层次结构中，不再支持 release_agent 机制，并且接口文件“release_agent”和“notify_on_release”不存在。

## 4-2. 其他核心更改

- 不允许使用任何挂载选项。

- 不允许重新挂载。

- 不允许使用 rename(2)。

- 删除了“tasks”文件。所有内容都应该在进程粒度上。使用“cgroup.procs”文件代替。

- “cgroup.procs”文件未排序。pids 将是唯一的，除非在读取之间被回收。

- 删除了“cgroup.clone_children”文件。

## 4-3. 每个控制器的更改

### 4-3-1. blkio

- blk-throttle 变得真正具有层次结构。

### 4-3-2. cpuset

- 热插拔后，任务保留在空的 cpuset 中，并采用最近非空祖先的掩码，而不是将其移动到其中。

- 可以将任务移动到空的 cpuset 中，并且再次采用最近非空祖先的掩码。

### 4-3-3. memory

- 默认启用 use_hierarchy，并且不会创建该标志的 cgroup 文件。

- 原始下限，即软限制，被定义为默认未设置的限制。结果，全局回收优先选择的 cgroup 集合是可选的，而不是可选的。优化这些大多为负的查找的成本非常高，以至于尽管实现规模很大，但甚至没有提供基本的期望行为。首先，软限制没有层次结构意义。所有配置的组都组织在一个全局红黑树中，并被视为平等的对等体，无论它们在层次结构中的位置如何。这使得子树委托变得不可能。其次，软限制回收过程非常激进，它不仅会在系统中引入高分配延迟，还会由于过度回收而影响系统性能，以至于该功能变得适得其反。

另一方面，memory.low 边界是自上而下分配的保留。当 cgroup 及其所有祖先都低于其低边界时，它享受回收保护，这使得子树委托成为可能。其次，新的 cgroup 默认没有保留，并且在常见情况下，大多数 cgroup 都有资格进行首选回收过程。这允许仅通过对通用回收代码进行少量添加来有效地实现新的低边界，而无需带外数据结构和回收过程。

因为通用回收代码会考虑除了在首选的首次回收过程中内存使用率较低的 cgroup 之外的所有 cgroup，所以单个组的过度回收也被消除了，从而导致整体工作负载性能好得多。

- 原始的高边界（硬限制）被定义为一个严格的限制，即使必须调用 OOM 杀手，也不能改变。但这通常与充分利用可用内存的目标相矛盾。工作负载的内存消耗在运行时会有所变化，这就需要用户进行过度承诺。但是，使用严格的上限进行这样的操作需要对工作集大小进行相当准确的预测，或者在限制中添加空闲空间。由于工作集大小估计很困难且容易出错，并且估计错误会导致 OOM 杀死，所以大多数用户倾向于在较宽松的限制方面犯错，最终浪费宝贵的资源。

另一方面，memory.high 边界可以设置得更加保守。当达到该边界时，它会通过强制分配进入直接回收来处理多余的内存，但它永远不会调用 OOM 杀手。因此，选择得过于激进的高边界不会终止进程，而是会导致性能逐渐下降。用户可以监控这一点并进行纠正，直到找到仍然提供可接受性能的最小内存占用。

在极端情况下，由于许多并发分配以及组内回收进度的完全崩溃，可能会超过高边界。但即使在这种情况下，通常最好从其他组或系统的剩余空闲空间中满足分配，而不是杀死该组。否则，memory.max 存在的目的是限制这种溢出并最终包含有错误甚至恶意的应用程序。

- 原始的控制文件名称在许多方面都很笨拙且不一致。例如，上限命中计数在 memory.failcnt 文件中导出，但 OOM 事件计数必须通过监听 memory.oom_control 事件来手动计数，而下限/软限制事件必须通过首先为该值设置阈值，然后计数这些事件来计数。此外，usage 和 limit 文件在文件名中编码了它们的单位。这使得文件名非常长，即使这不是用户每次输入这些名称时都需要被提醒的信息。

为了解决这些命名问题，并清楚地表明新接口带有新的配置模型，其中的命名约定必然与旧接口不同。

- 原始的限制文件使用一个非常高的数字来表示未设置限制的状态，并且可以通过将 -1 回显到这些文件中来取消配置的限制。但是，那个非常高的数字是实现和体系结构相关的，并且不是很有描述性。虽然 -1 可以理解为溢出到可能的最大值，但 -2 或 -10M 等不起作用，所以它不是一致的。

memory.low、memory.high 和 memory.max 将使用字符串“max”来表示和设置可能的最大值。

# 5. 计划的更改

## 5-1. 资源控制的 CAP

统一的层次结构将需要一种能力（7），尚未确定，用于所有与资源控制相关的旋钮。进程组织操作 - 创建子 cgroup 和在子层次结构中迁移进程 - 可以通过更改 cgroup 目录和“cgroup.procs”接口文件的所有权和/或权限来委托；然而，所有影响资源控制的操作 - 写入“cgroup.subtree_control”文件或任何特定于控制器的旋钮 - 将需要显式的 CAP 权限。

这部分是为了防止 cgroup 接口被无意中提升为非特权二进制文件使用的可编程 API。cgroup 以一种未正确抽象以供常规程序直接使用的方式公开系统的各个方面。这是一个更接近 sysctl 旋钮而不是系统调用的管理接口。即使是基于文件系统路径的基本访问模型，也不适合直接使用。没有办法以无竞争的方式访问“我的 cgroup”，或者对迁移到另一个 cgroup 进行多个操作的原子性。

另一方面，无论好坏，cgroup 接口比用于非特权用户空间的常规接口受到的审查要少得多。好处是，cgroup 能够暴露一些在合理时间框架内不适合一般消费的有用功能。它在内部细节和用户空间可见接口之间提供了一个相对较短的路径。当然，这种捷径带来了很高的风险。我们经历我们所经历的是有充分理由的，对于一般的内核 API 也是如此。它可能最终以一种可能通过将内核锁定到无法以合理方式维护的合同中来施加重大痛苦的方式泄露内部细节。

此外，由于其特定的性质，cgroup 及其控制器往往不会吸引广泛范围的开发人员的注意。cgroup 的短暂历史已经充满了设计严重错误的接口、对内部细节的不必要承诺和暴露、各种功能的破碎和危险实现。

将 cgroup 保持为管理接口对于其角色是有利的，并且鉴于其性质是必要的。cgroup 的一些功能对于非特权访问可能是有意义的。如果被认为是合理的，这些必须进一步抽象并作为不同的接口实现，无论是系统调用还是进程私有文件系统，并通过任何一般消费接口所需的审查。

需要 CAP 不是一个完整的解决方案，但应该作为对在非特权程序中滥用 cgroup 使用的重要威慑。

</markdown_document>