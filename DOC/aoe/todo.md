当为需要写入 aoe 存储的数据分配`struct sk_buff`时，存在死锁的可能性。如果数据是从脏页写入以释放该页，并且没有其他可用页，那么在`sk_buff`分配需要空闲页时可能会发生死锁。这种情况尚未被观察到，但在内存压力下消除任何潜在的死锁是很好的。

由于以太网上的 ATA 不会被内核的 IP 代码分片，`struct sk_buff`的析构函数成员可用于 aoe 驱动程序。通过使用内存池来分配除前几个`sk_buff`之外的所有`sk_buff`，并注册一个析构函数，我们应该能够有效地分配`sk_buff`，而不会引入任何潜在的死锁。