<markdown_document>

以下是 descore.shar 包的原始 README 文件。

------------------------------------------------------------------------------

des - 快速且可移植的 DES 加密和解密。

版权 (C) 1992  Dana L. How

本程序是自由软件；您可以重新分发和/或修改它

根据 GNU 库通用公共许可证的条款发布，由

自由软件基金会；要么是第 2 版许可证，要么

（根据您的选择）任何更高版本。

本程序以希望它会有用的方式分发，

但没有任何保证；甚至没有暗示的保证

适销性或特定用途的适用性。  请参阅

GNU 库通用公共许可证以获取更多详细信息。

您应该已经收到了一份 GNU 库通用公共许可证的副本

与本程序一起；如果没有，请写信给自由软件

基金会， Inc.， 675 Mass Ave， Cambridge， MA 02139， USA。

作者的地址：how@isl.stanford.edu

$Id: README,v 1.15 1992/05/20 00:25:32 how E $

==>> 解压/解包后进行编译，只需 `make' <<==

本包的设计目标如下：

1. 最高的加密/解密性能。

2. 可移植到任何具有 32 位无符号 C 类型的字节可寻址主机

3. 与 KERBEROS 的低级例程兼容的替代品。

本次发布包含了一些针对寄存器不足的机器的性能增强。  我与 Richard Outerbridge 的讨论，

71755.204@compuserve.com，引发了许多这些增强。

为了更快速地理解本包中的代码，在处理 desCode.h 之前检查 desSmallFips.i

（通过输入 `make' 创建）。  后者是以参数化的方式设置的，因此可以轻松地由速度守护进程修改

黑客追求那最后的微秒。  您会发现更有启发性的是检查一个特定的实现，

然后牢记这一点，继续进行通用的抽象框架。

与我可以在 SPARCStation 1 上编译的其他可用 des 代码的性能比较（cc -O4，gcc -O2）：

此代码（与字节顺序无关）：

   每次加密 30 微秒（选项：64k 表，无 IP/FP）

   每次加密 33 微秒（选项：64k 表，FIPS 标准位序）

   每次加密 45 微秒（选项：2k 表，无 IP/FP）

   每次加密 48 微秒（选项：2k 表，FIPS 标准位序）

  275 微秒设置新密钥（使用 1k 密钥表）

这是我见过的最快的加密/解密例程。  因为我对快速的 des 过滤器而不是 crypt(3)

和密码破解感兴趣，所以我还没有真正费心去加速

密钥设置例程。  此外，我对重新实现

MIT Kerberos des 库中的所有其他垃圾不感兴趣，所以我只是

为我的例程提供了小的存根接口，以便它们可以

用作 MIT 代码或以下任何 MIT 兼容包的即插即用替代品。 （请注意，上述前两个时间高度可变，因为缓存影响）。

来自澳大利亚的 Kerberos des 替代品（版本 1.95）：

   每次加密 53 微秒（使用 2k 表）

   设置新密钥 96 微秒（使用 2.25k 密钥表）

因此，尽管作者包含了我向他建议的一些性能

增强功能，但此包的

加密/解密在 sparc 和 68000 上仍然较慢。  更具体地说，在 68020 上慢 19-40％，在 sparc 上慢 11-35％，

具体取决于编译器；

详细信息（ALT_ECB 是 libdes 的变体）：

编译器    机器    desCore    libdes    ALT_ECB    慢了

gcc 2.1 -O2    Sun 3/110    304 微秒    369.5 微秒    461.8 微秒    22％

cc      -O1    Sun 3/110    336 微秒    436.6 微秒    399.3 微秒    19％

cc      -O2    Sun 3/110    360 微秒    532.4 微秒    505.1 微秒    40％

cc      -O4    Sun 3/110    365 微秒    532.3 微秒    505.3 微秒    38％

gcc 2.1 -O2    Sun 4/50    48 微秒    53.4 微秒    57.5 微秒    11％

cc      -O2    Sun 4/50    48 微秒    64.6 微秒    64.7 微秒    35％

cc      -O4    Sun 4/50    48 微秒    64.7 微秒    64.9 微秒    35％

（我的时间测量不如他的准确）。  我在版本 1.92 的 desCore 首次发布中的评论：

   每次加密 68 微秒（使用 2k 表）

   设置新密钥 96 微秒（使用 2.25k 密钥表）

这是一个非常好的包，它实现了我在加密例程中所做的最重要的

优化。  它在常见的低级优化方面有点薄弱，这就是为什么

它慢 39％-106％。  因为他对快速的 crypt(3)和

密码破解应用程序感兴趣，他还使用相同的想法来

加速密钥设置例程，取得了令人印象深刻的结果。  （在某个时候，我可能会在我的包中做同样的事情）。 他还实现了

MIT des 库的其余部分。  （来自 eay@psych.psy.uq.oz.au 通过 comp.sources.misc 获得的代码）

来自丹麦的快速 crypt(3)包：

这里的 des 例程被埋在一个循环中以执行

加密功能，我不想将其取出并测量

性能。他的代码需要 26 个 sparc 指令来计算一个

des 迭代；以上，Quick（64k）需要 21 个，Small（2k）需要 37 个。  他声称使用 280k 表，但迭代计算似乎

只使用 128k。  他的表和代码与机器无关。  （来自 glad@daimi.aau.dk 通过 alt.sources 或 comp.sources.misc 获得的代码）

瑞典对 Kerberos des 库的重新实现

  每次加密 108 微秒（使用 34k 表）

  设置新密钥 134 微秒（使用 32k 密钥表以获得此速度！）

使用的表似乎与机器无关；

他似乎包含了很多特殊情况代码

例如，当机器的体系结构允许时，可以使用 `long' 加载而不是 4 个 `char' 加载。  （从 chalmers.se:pub/des 获得的代码）

来自英国的 crack 3.3c 包：

与上面的 crypt 一样，des 例程被埋在一个循环中。它也

经过了大量修改以用于加密。他的迭代代码使用 16k

表并且似乎很慢。  （从 aem@aber.ac.uk 通过 alt.sources 或 comp.sources.misc 获得的代码）

“高度优化”和调整后的 Kerberos/Athena 代码（与字节顺序有关）：

  每次加密 165 微秒（使用 6k 表）

  设置新密钥 478 微秒（使用 <1k 密钥表）

因此，尽管此代码中有注释，但仍有可能获得

更快的代码和更小的表，以及使表

与机器无关。  （从 prep.ai.mit.edu 获得的代码）

UC Berkeley 代码（取决于机器的字节序）：

  每次加密 226 微秒

设置新密钥 10848 微秒

表大小不清楚，但它们看起来不是很小

（从 wuarchive.wustl.edu 获得的代码）

动机和历史

不久前，我想要一些 des 例程，而 sun 的手册页上记录的例程要么不存在，要么导致核心转储。  我听说过 Kerberos，

并且知道它使用 des，所以我认为我会使用它的例程。  但是一旦

我得到它并查看了代码，它真的引起了很多不满 -

它太复杂了，代码是在没有利用操作的常规结构的情况下编写的，例如 IP、E 和 FP

（即作者在编码之前没有坐下来思考），

它太慢了，作者试图通过添加更多语句来澄清代码，以使数据移动更“一致”

而不是简化他的实现并减少所有数据

移动（特别是他对 L1、R1、L2、R2 的使用），并且它充满了

对于特定机器的愚蠢“调整”，这些调整未能提供显著的

加速，但确实使一切变得模糊。  所以我使用他的验证程序中的测试数据并重写了其他所有内容。

过了一段时间，我遇到了上面提到的伟大的 crypt(3) 包。  这个人正在计算每个表查找的 2 个 s 盒，而不是一个

（并且在这个过程中使用了一个大得多的表），这使我有勇气做同样的事情 - 这是一个微不足道的变化，我之前因为表大小较大而不敢尝试。  在他的情况下，他没有意识到你不需要将工作数据保持在两种形式中，一种用于轻松使用 s 盒的一半进行索引，另一种用于轻松使用另一半；相反，你可以将其保持在用于前一半的形式中，并使用简单的旋转来获得另一半。  这意味着我有（几乎）一半的数据操作和一半的表大小。  不过，公平地说，他可能在他的表中编码了 crypt(3) 的某些特定内容 - 我没有检查。

我很高兴我以我所做的方式实现了它，因为这个 C 版本是

可移植的（ifdef 是性能增强），并且它比在 sparc 中用汇编语言编写的版本更快！

移植注意事项

我不想做的一件事是编写一个巨大的混乱

它依赖于字节序和其他机器怪癖，

并且必然会为不同的机器生成不同的代码和不同的查找表。  请参阅 kerberos 代码以了解我不想做的事情；他们所有的字节序特定“优化”

使代码变得模糊，最终比更简单的机器

独立方法更慢。  然而，总是有一些可移植性

考虑的某种类型，我已经包括了一些选项

用于不同数量的寄存器变量。  也许有些人仍然会认为结果是一团糟！

1) 我假设一切都是字节可寻址的，尽管我实际上

   不依赖于字节顺序，并且字节是 8 位。

    我假设可以自由地将字指针转换为 char 指针和从 char 指针转换。

    请注意，99％的 C 程序都做出了这些假设。

    如果高位可能被设置，我总是使用无符号 char。

2) 类型定义“word”表示 32 位无符号整型。

    如果“unsigned long”不是 32 位，请在 desCore.h 中更改类型定义。

   我假设 sizeof(word) == 4 无处不在。

我不进行字节序特定优化的（最坏情况）成本

在围绕键迭代的数据加载和存储代码中

小于 12％。  此外，还有一个额外的好处

输入和输出工作区不需要字对齐。

可选的性能优化

1) 您应该定义“i386”、“vax”、“mc68000”或“sparc”之一，

   哪个最接近您机器的功能。

    请参阅 desCode.h 的开头以确切了解此选择的含义。

    请注意，如果您选择了错误的选项，des 代码仍将工作；

   这些只是性能调整。

2) 对于具有功能性“asm”关键字的人：如果您有，您应该将

   ROR 和 ROL 宏更改为使用机器旋转指令。

    这将每次节省 2 条指令和一个临时变量，

    或每次加密/解密约 32 到 40 条指令。

    请注意，gcc 足够智能，可以将 ROL/R 宏转换为

   机器旋转！

这些优化都相当挑剔，但有了它们，您应该能够获得与汇编编码相当的性能，除了：

1) 由于 C 中缺少位旋转运算符，旋转必须从移位合成。  因此，如果您的机器有旋转，访问“asm”将加快速度，如上面（3）中所述（如果您使用 gcc，则不需要）。

2) 如果您的机器少于 12 个 32 位寄存器，我怀疑您的编译器将生成良好的代码。

    “i386”尝试通过仅声明 3 个寄存器来为 386 配置代码

    （似乎 gcc 可以使用 ebx、esi 和 edi 来保存寄存器变量）。

    但是，如果您喜欢汇编编码，386 确实有 7 个 32 位寄存器，

    并且如果您使用所有这些寄存器，使用“按 8 缩放”地址模式和位移

    和其他技巧，您可以获得合理的 DesQuickCore 例程...

    每个例程约有 250 条指令。  对于 DesSmall...，重新排列

    des_keymap 会有所帮助，即现在 s 盒 # 是索引的高部分，

    6 位数据是低部分；交换这些会有所帮助。

    由于我无法方便地测试它，所以我没有提供我的

    强行适应的 386 版本。  请注意，使用此版本的 desCore，gcc 能够

    将所有内容放入寄存器中（！），并且每个 DesQuickCore...例程生成约 370 条指令！

编码注意事项

加密/解密例程每个都使用 6 个必要的寄存器变量，

在内部迭代期间，一次最多使用 4 个。如果您没有 4 个寄存器变量，请更换一台新机器。最多 8 个更多的寄存器用于在某些配置中保存常量。

我假设使用常量比使用寄存器更昂贵：

a) 此外，我尝试将较大的常量放入寄存器中。

    注册优先级如下：

	任何超过 12 位（对 RISC 和 CISC 不利）

	大于 127 的值（在 CISC 上不能使用 movq 或字节立即数）

	9-127（可能无法使用 CISC 移位立即数或快速加减），

	1-8 从未注册，是最便宜的常量。

b) 编译器可能太愚蠢而无法意识到表和表+256 应该

   分配给不同的常量寄存器，而是重复地

   进行算术运算，所以在可能和有帮助的情况下，我将这些分配给显式的“m”寄存器变量。

我假设索引比自动递增/递减更便宜或等效，

其中索引是 7 位无符号或更小。对于 68k 和 vax，此假设相反。

我假设可以从两个寄存器或从一个寄存器和一个小常量中廉价地形成地址。对于 68000，“两个寄存器和小偏移”形式使用得很少。所有索引缩放都是显式完成的 - 没有隐藏的 log2(sizeof) 移位。

代码的编写方式使得即使是愚蠢的编译器

也应该永远不需要超过一个隐藏的临时变量，

增加了所有内容都适合寄存器的机会。如果您重写任何内容，请牢记这一更微妙的要点。（实际上，现在有一些代码片段确实需要两个临时变量，

但修复它要么会破坏宏的结构，要么

需要声明另一个临时变量）。

特殊高效数据格式

在大多数时间（S7 S5 S3 S1）中，按以下方式操作位：

	003130292827xxxx242322212019xxxx161514131211xxxx080706050403xxxx

（x 位仍然存在，我只是强调 s 盒的位置）。在计算 S6 S4 S2 S0 时，位向左旋转 4：

	282726252423xxxx201918171615xxxx121110090807xxxx040302010031xxxx

通常清除最右边的两位，以便较低的字节可以用作

s 盒映射表的索引。接下来的两个 x 位被设置

为各种值以访问表的不同部分。

如何使用例程

数据类型：

	指向 8 字节 DesData 类型区域的指针

	用于保存 des 的密钥和输入/输出块。

	指向 128 字节 DesKeys 类型区域的指针

	用于保存完整的 768 位密钥。  必须<markdown_document>

如果使用 DesMethod，

你提供一个标准的 56 位密钥；然而，如果你自己填充 m，你将获得一个 768 位密钥 - 但它将不是标准的。它是 768 位而不是 1024 位，因为每个字节的最低有效两位未被使用。请注意，这两位将被设置为魔术常量，这在某些机器上可以加快加密/解密速度。并且，是的，每个字节在特定的迭代中控制一个特定的 S 盒。你真的不应该直接使用 768 位格式；我应该提供一个例程，将 128 个 6 位字节（按照 S 盒映射顺序或其他方式指定）转换为适合你的正确格式。这将需要一些字节连接和旋转。

Des{小|快}{Fips|核心}{加密|解密}(d, m, s)

对 s 处的 8 个字节执行 des 操作，将结果放入 d 处的 8 个字节中。(d,s: char *)。如上所述，使用 m 作为 768 位密钥。加密|解密的选择是显而易见的。Fips|核心决定是否进行完全标准的 FIPS 初始和最终置换；如果不是，那么数据将以非标准的位顺序加载和存储（无 IP/FP 的 FIPS）。Fips 使快速版本的速度降低 10%，使小版本的速度降低 9%。小|快决定你是使用正常例程还是疯狂的快速例程，该例程会消耗 64k 更多的内存。小版本比快速版本慢 50%，但快速版本需要 32 倍的内存。快速版本包含在仅执行 DES 的程序中，例如加密过滤器等。

在你的机器上使其编译

代码中没有机器依赖项（见移植），

除了 desTest.c 中的`now()`宏可能除外。

所有生成的表都是机器独立的。你应该使用适当的优化标志编辑 Makefile

（最大优化）以适用于你的编译器。

加快 kerberos（和/或其 des 库）

请注意，我在 desUtil.c 中通过函数 des_key_sched()和 des_ecb_encrypt()包含了一个与 kerberos 兼容的接口。要将这些与 kerberos 或 kerberos 兼容的代码一起使用，请在链接器的命令行上将 desCore.a 放在 kerberos 兼容库的前面。你不需要包含 desCore.h；只需包含 kerberos 库提供的头文件。

其他用途

desCode.h 中的宏对于在更复杂的加密例程中放入内联 des 函数非常有用。

</markdown_document>