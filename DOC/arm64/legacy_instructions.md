The arm64 版本的 Linux 内核提供了基础设施，以支持模拟在该架构中已弃用或过时的指令。基础设施代码使用未定义指令钩子来支持模拟。在可用的情况下，它还允许在硬件中打开指令执行。

模拟模式可以通过写入 sysctl 节点（/proc/sys/abi）来控制。以下解释了不同的执行行为以及 sysctl 节点的相应值 -

* Undef

  值：0

  生成未定义指令异常。对于在架构中已过时的指令，例如 SWP，这是默认值。

* Emulate

  值：1

  使用软件模拟。为了帮助软件迁移，在这种模式下，模拟指令的使用会被跟踪，并且会发出速率限制的警告。对于已弃用的指令，例如 CP15 屏障，这是默认值。

* Hardware Execution

  值：2

  尽管被标记为已弃用，但某些实现可能支持启用/禁用这些指令的硬件支持。使用硬件执行通常提供更好的性能，但会损失收集关于已弃用指令使用情况的运行时统计信息的能力。

默认模式取决于架构中指令的状态。已弃用的指令应默认为模拟，而过时的指令必须默认未定义。

注意：在所有情况下，指令模拟可能都不可行。有关更多信息，请参阅各个指令的说明。

# 支持的遗留指令

-----------------------------

* SWP{B}

节点：/proc/sys/abi/swp

状态：过时

默认：Undef（0）

* CP15 屏障

节点：/proc/sys/abi/cp15_barrier

状态：已弃用

默认：Emulate（1）

* SETEND

节点：/proc/sys/abi/setend

状态：已弃用

默认：Emulate（1）*

注意：对于此功能要启用，系统上的所有 CPU 在 EL0 处都必须具有混合字节序支持。如果在启用此功能后热插拔了不支持混合字节序的新 CPU，则应用程序中可能会出现意外结果。