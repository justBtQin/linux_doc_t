# 启动 AArch64 Linux

=====================

作者：Will Deacon <will.deacon@arm.com>

日期：2012 年 9 月 7 日

本文档基于 Russell King 的 ARM 启动文档，适用于 AArch64 Linux 内核的所有公共版本。

AArch64 异常模型由多个异常级别（EL0 - EL3）组成，EL0 和 EL1 具有安全和非安全对应部分。EL2 是 hypervisor 级别，仅存在于非安全模式中。EL3 是最高优先级级别，仅存在于安全模式中。

在本文档中，我们将使用“引导加载程序”一词来简单定义在控制转移到 Linux 内核之前在 CPU 上执行的所有软件。这可能包括安全监视器和 hypervisor 代码，也可能只是用于准备最小启动环境的少量指令。

本质上，引导加载程序应提供（至少）以下内容：

# 1. 设置并初始化 RAM

---------------------------

要求：强制

引导加载程序应找到并初始化内核在系统中用于易失性数据存储的所有 RAM。它以与机器相关的方式执行此操作。（它可以使用内部算法自动定位和确定所有 RAM 的大小，或者它可以使用机器中 RAM 的知识，或者引导加载程序设计者认为合适的任何其他方法。）

# 2. 设置设备树

-------------------------

要求：强制

设备树 blob（dtb）必须放置在内核映像开始后的前 512 兆字节内的 8 字节边界上，并且不得跨越 2 兆字节边界。这是为了允许内核在初始页表中使用单个段映射来映射 blob。

# 3. 解压缩内核映像

------------------------------

要求：可选

AArch64 内核当前不提供解压缩程序，因此如果使用压缩的 Image 目标（例如 Image.gz），则需要引导加载程序执行解压缩（gzip 等）。对于不满足此要求的引导加载程序，可使用未压缩的 Image 目标。

# 4. 调用内核映像

------------------------

要求：强制

解压缩的内核映像包含一个 64 字节的头，如下所示：

```
  u32 code0;  /* 可执行代码 */
  u32 code1;  /* 可执行代码 */
  u64 text_offset;  /* 映像加载偏移量，小端序 */
  u64 image_size;  /* 有效映像大小，小端序 */
  u64 flags;  /* 内核标志，小端序 */
  u64 res2 = 0;  /* 保留 */
  u64 res3 = 0;  /* 保留 */
  u64 res4 = 0;  /* 保留 */
  u32 magic = 0x644d5241;  /* 魔术数，小端序，"ARM\x64" */
  u32 res5;  /* 保留（用于 PE COFF 偏移量） */
```

头注释:

- 从 v3.17 开始，除非另有说明，否则所有字段均为小端序。

- code0/code1 负责分支到 stext。

- 通过 EFI 启动时，最初会跳过 code0/code1。res5 是 PE 头的偏移量，PE 头具有 EFI 入口点（efi_stub_entry）。当存根完成其工作后，它会跳转到 code0 以恢复正常的启动过程。

- 在 v3.17 之前，未指定 text_offset 的字节序。在这些情况下，image_size 为零，text_offset 在内核的字节序中为 0x80000。如果 image_size 非零，则 image_size 为小端序，必须予以尊重。如果 image_size 为零，则可以假定 text_offset 为 0x80000。

- flags 字段（在 v3.17 中引入）是一个小端序 64 位字段，组成如下：

  位 0：内核字节序。1 表示大端序，0 表示小端序。

  位 1-63：保留。

- 当 image_size 为零时，引导加载程序应尝试在内核映像结束后尽可能多地保留内存供内核使用。所需的空间量将因所选功能而异，并且实际上是无限制的。

映像必须放置在距离 2MB 对齐的基地址 text_offset 字节处，靠近可用系统 RAM 的开始位置，并在那里调用。低于该基地址的内存当前对 Linux 不可用，因此强烈建议此位置是系统 RAM 的开始。映像开始处至少应有 image_size 字节的空闲空间供内核使用。

向内核描述的任何内存（即使是低于 2MB 对齐的基地址的内存），如果未从内核标记为保留（例如，在设备树中使用 memreserve 区域），将被视为可供内核使用。

在跳入内核之前，必须满足以下条件：

- 使所有支持 DMA 的设备安静，以防止内存被虚假的网络数据包或磁盘数据损坏。这将为你节省大量的调试时间。

- 主 CPU 通用寄存器设置

  x0 = 系统 RAM 中设备树 blob（dtb）的物理地址。

  x1 = 0（预留供将来使用）

  x2 = 0（预留供将来使用）

  x3 = 0（预留供将来使用）

- CPU 模式

  必须在 PSTATE.DAIF（调试、SError、IRQ 和 FIQ）中屏蔽所有形式的中断。

  CPU 必须处于 EL2（建议为了能够访问虚拟化扩展）或非安全 EL1 中。

- 缓存、MMU

  MMU 必须关闭。

  指令缓存可以打开或关闭。

  与加载的内核映像对应的地址范围必须清理到 PoC。在存在系统缓存或其他启用缓存的一致性主设备的情况下，通常需要通过 VA 进行缓存维护，而不是通过设置/方式操作。

  必须配置尊重通过 VA 进行架构缓存维护的系统缓存，并且可以启用它们。

  不尊重通过 VA 进行架构缓存维护的系统缓存（不建议）必须进行配置并禁用。

- 架构计时器

  必须使用计时器频率对 CNTFRQ 进行编程，并且必须在所有 CPU 上对 CNTVOFF 进行编程，使其具有一致的值。如果在 EL1 进入内核，则如果可用，必须将 CNTHCTL_EL2 的 EL1PCTEN（位 0）设置为 1。

- 一致性

  要由内核启动的所有 CPU 必须在进入内核时属于同一一致性域。这可能需要实现定义的初始化，以在每个 CPU 上启用维护操作的接收。

- 系统寄存器

  在将进入内核的异常级别上，所有可写的架构系统寄存器必须由更高异常级别的软件进行初始化，以防止在未知状态下执行。

  对于具有 GICv3 中断控制器的系统：

  - 如果存在 EL3：

    ICC_SRE_EL3.Enable（位 3）必须初始化为 0b1。

    ICC_SRE_EL3.SRE（位 0）必须初始化为 0b1。

  - 如果在 EL1 进入内核：

    ICC.SRE_EL2.Enable（位 3）必须初始化为 0b1。

    ICC_SRE_EL2.SRE（位 0）必须初始化为 0b1。

上述关于 CPU 模式、缓存、MMU、架构计时器、一致性和系统寄存器的要求适用于所有 CPU。所有 CPU 必须以相同的异常级别进入内核。

引导加载程序应以下列方式在每个 CPU 上进入内核：

- 主 CPU 必须直接跳转到内核映像的第一条指令。此 CPU 传递的设备树 blob 必须包含每个 cpu 节点的“enable-method”属性。支持的 enable-methods 如下所述。

  预计引导加载程序将生成这些设备树属性，并在进入内核之前将它们插入到 blob 中。

- 具有“spin-table”enable-method 的 CPU 必须在其 cpu 节点中具有“cpu-release-addr”属性。此属性标识一个自然对齐的 64 位零初始化内存位置。这些 CPU 应该在内存的预留区域（通过设备树中的`/memreserve/`区域告知内核）中在内核之外自旋，轮询它们的`cpu-release-addr`位置，该位置必须包含在预留区域中。可以插入`wfe`指令以减少忙循环的开销，并且主 CPU 将发出`sev`。当对`cpu-release-addr`指向的位置的读取返回非零值时，CPU 必须跳转到该值。该值将作为单个 64 位小端值写入，因此 CPU 在跳转到它之前必须将读取的值转换为本机字节序。

- 具有“psci”使能方法的 CPU 应保持在内核之外（即，在内存节点中告知内核的内存区域之外，或在设备树中的`/memreserve/`区域告知内核的内存预留区域中）。内核将按照 ARM 文档编号 ARM DEN 0022A（“ARM 处理器上的电源状态协调接口系统软件”）中所述发出`CPU_ON`调用，以将 CPU 带入内核。设备树应包含一个`psci`节点，如`Documentation/devicetree/bindings/arm/psci.txt`中所述。

- 辅助 CPU 通用寄存器设置

  x0 = 0（预留用于将来使用）

  x1 = 0（预留用于将来使用）

  x2 = 0（预留用于将来使用）

  x3 = 0（预留用于将来使用）