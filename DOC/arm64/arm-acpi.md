# ACPI on ARMv8 Servers

ACPI 可用于遵循 ARM SBSA（服务器基础系统架构）[0]和 SBBR（服务器基础启动要求）[1]规范设计的 ARMv8 通用服务器。请注意，可通过访问[1]简单检索 SBBR，但由于 ARM IP 许可问题，目前仅对拥有 ARM 登录的人员提供 SBSA。

ARMv8 内核实现了 ACPI 版本 5.1 或更高版本的精简硬件模型。规范及其引用的所有外部文档的链接由 UEFI 论坛管理。规范可在 http://www.uefi.org/specifications 获得，规范引用的文档可通过 http://www.uefi.org/acpi 找到。

如果 ARMv8 系统不符合 SBSA 和 SBBR 的要求，或者无法使用所需 ACPI 规范中定义的机制进行描述，那么 ACPI 可能不适合该硬件。

虽然上述文档规定了构建行业标准 ARMv8 服务器的要求，但它们也适用于多个操作系统。本文档的目的是仅描述 ACPI 与 Linux 在 ARMv8 系统上的交互 - 即 Linux 对 ACPI 的期望以及 ACPI 对 Linux 的期望。

# Why ACPI on ARM?

在研究 ACPI 与 Linux 之间的接口细节之前，了解为什么使用 ACPI 是有用的。毕竟，Linux 中已经存在几种用于描述不可枚举硬件的技术。在本节中，我们总结了 Grant Likely 的一篇博客文章[2]，该文章概述了在 ARMv8 服务器上使用 ACPI 的背后原因。实际上，诚实地说，我们几乎直接窃取了大部分总结文本。

ARM 上使用 ACPI 的基本原理是：

- ACPI 的字节码（AML）允许平台编码硬件行为，而 DT 明确不支持此功能。对于硬件供应商而言，能够编码行为是在新硬件上支持操作系统版本的关键工具。

- ACPI 的 OSPM 定义了一个电源管理模型，该模型将平台允许执行的操作限制为特定模型，同时仍在硬件设计中提供灵活性。

- 在企业服务器环境中，ACPI 已建立绑定（例如用于 RAS），目前在生产系统中使用。DT 则没有。这样的绑定可以在 DT 中的某个时候定义，但这样做意味着 ARM 和 x86 在固件和内核中最终将使用完全不同的代码路径。

- 选择单个接口来描述平台与操作系统之间的抽象很重要。如果硬件供应商希望支持多个操作系统，则无需同时实现 DT 和 ACPI。而且，就总体而言，就单个接口达成一致而不是分散到每个操作系统的接口中会带来更好的互操作性。

- 新的 ACPI 治理流程运行良好，Linux 现在与硬件供应商和其他操作系统供应商处于同一平台。实际上，再也没有理由认为 ACPI 仅属于 Windows 或 Linux 在该领域中次于 Microsoft。ACPI 治理进入 UEFI 论坛已大大开放了规范开发过程，目前，对 ACPI 所做的大部分更改是由 Linux 驱动的。

ACPI 的使用关键在于支持模型。对于一般服务器，硬件行为的责任不能仅由内核承担，而必须在平台和内核之间分配，以允许随时间进行有序更改。ACPI 使操作系统无需了解硬件的所有细微细节，因此操作系统无需针对每个设备单独进行移植。它允许硬件供应商负责电源管理行为，而无需依赖不受其控制的操作系统发布周期。

ACPI 也很重要，因为硬件和操作系统供应商已经制定了支持通用计算生态系统的机制。基础架构已到位，绑定已到位，流程已到位。DT 在处理垂直集成设备时完全满足 Linux 的需求，但没有支持服务器供应商需求的良好流程。Linux 可能会通过 DT 实现这一点，但这样做实际上只是复制了已经有效的东西。ACPI 已经满足了硬件供应商的需求，Microsoft 不会在 DT 上进行协作，并且硬件供应商最终仍将提供两个完全独立的固件接口 - 一个用于 Linux，一个用于 Windows。

# Kernel Compatibility

ACPI 的主要动机之一是标准化，并利用它为 Linux 内核提供向后兼容性。在服务器市场中，软件和硬件通常使用很长时间。ACPI 允许内核和固件就一致的抽象达成一致，即使硬件或软件发生变化，也可以随时间保持不变。只要支持抽象，就可以更新系统，而不必一定更换内核。

当首次使用 ACPI 实现 Linux 驱动程序或子系统时，根据定义，它最终需要特定版本的 ACPI 规范 - 这是其基线。ACPI 固件必须继续工作，即使对于首次提供对该基线版本 ACPI 支持的最早内核版本，它可能不是最佳的。可能需要额外的驱动程序，但添加新功能（例如，CPU 电源管理）不应破坏旧的内核版本。此外，ACPI 固件还必须与最新版本的内核一起工作。

# Relationship with Device Tree

ARMv8 驱动程序和子系统中的 ACPI 支持在编译时绝不应与 DT 支持互斥。

在引导时，内核将仅根据从引导加载程序（包括内核引导参数）传递的参数使用一种描述方法。

无论使用 DT 还是 ACPI，内核在编译时启用两种方案的情况下必须始终能够使用任一方案启动。

# Booting using ACPI tables

在 ARMv8 上，将 ACPI 表传递给内核的唯一定义方法是通过 UEFI 系统配置表。明确地说，这意味着 ACPI 仅在通过 UEFI 引导的平台上受支持。

当 ARMv8 系统引导时，它可以具有 DT 信息、ACPI 表，或者在极少数情况下，两者都有。如果未使用命令行参数，内核将尝试使用 DT 进行设备枚举；如果不存在 DT，内核将尝试使用 ACPI 表，但前提是它们存在。如果两者都不存在，内核将无法引导。如果在命令行上使用 acpi=force，内核将首先尝试使用 ACPI 表，但如果不存在 ACPI 表，则回退到 DT。基本思想是，除非绝对没有其他选择，否则内核不会无法引导。

可以通过在内核命令行上传递 acpi=off 来禁用 ACPI 表的处理；这是默认行为。

为了使内核能够加载和使用 ACPI 表，UEFI 实现必须将 ACPI_20_TABLE_GUID 设置为指向 RSDP 表（具有 ACPI 签名“RSD PTR”的表）。如果此指针不正确且使用了 acpi=force，则内核将禁用 ACPI 并尝试使用 DT 代替引导；实际上，内核已确定此时不存在 ACPI 表。

如果指向 RSDP 表的指针正确，该表将由 ACPI 核心使用 UEFI 提供的地址映射到内核中。ACPI 核心随后将通过使用 RSDP 表中的地址来定位和映射系统固件提供的所有其他 ACPI 表，以找到 XSDT（扩展系统描述表）。XSDT 又提供了系统固件提供的所有其他 ACPI 表的地址；ACPI 核心随后将遍历此表并映射列出的表。

ACPI 核心将忽略任何提供的 RSDT（根系统描述表）。RSDT 已被弃用，并且在 arm64 上被忽略，因为它们仅允许 32 位地址。

此外，ACPI 核心将仅使用 FADT（固定 ACPI 描述表）中的 64 位地址字段。FADT 中的任何 32 位地址字段在 arm64 上都将被忽略。

硬件精简模式（请参阅 ACPI 5.1 规范的第 4.1 节）将由 ACPI 核心在 arm64 上强制执行。这样做允许 ACPI 核心运行更简单的代码，因为它不再需要为其他架构的遗留硬件提供支持。任何不用于硬件精简模式的字段都必须设置为零。

为了使 ACPI 核心正常运行，并进而提供内核配置设备所需的信息，它期望找到以下表（所有章节编号均指 ACPI 5.1 规范）：

- -- RSDP（根系统描述指针），第 5.2.5 节

- -- XSDT（扩展系统描述表），第 5.2.8 节

- -- FADT（固定 ACPI 描述表），第 5.2.9 节

- -- DSDT（差异化系统描述表），第 5.2.11.1 节

- -- MADT（多个 APIC 描述表），第 5.2.12 节

- -- GTDT（通用定时器描述表），第 5.2.24 节

- -- 如果支持 PCI，则为 MCFG（内存映射配置表），第 5.2.6 节，特别是表 5-31。

如果上述表不全存在，内核可能能够正常启动，也可能无法正常启动，因为它可能无法配置所有可用的设备。

# ACPI 检测

--------------

驱动程序应通过检查 ACPI_HANDLE 的空值、检查.of_node 或设备结构中的其他信息来确定其探测()类型。这在“驱动程序建议”部分中有更详细的说明。

在非驱动程序代码中，如果需要在运行时检测 ACPI 的存在，则检查 acpi_disabled 的值。如果未设置 CONFIG_ACPI，则 acpi_disabled 始终为 1。

# 设备枚举

------------------

ACPI 中的设备描述应使用标准的公认 ACPI 接口。这些描述可能比同一设备的设备树描述提供的信息少。这也是 ACPI 有用的原因之一——驱动程序考虑到它可能对设备的信息了解较少，并使用合理的默认值。如果在驱动程序中正确完成，硬件可以随着时间的推移而变化和改进，而驱动程序无需进行任何更改。

时钟提供了一个很好的例子。在设备树中，需要指定时钟，并且驱动程序需要考虑它们。在 ACPI 中，假设 UEFI 将使设备处于合理的默认状态，包括任何时钟设置。如果由于某种原因驱动程序需要更改时钟值，可以在 ACPI 方法中完成；驱动程序只需调用该方法，而不必关心该方法需要做什么来更改时钟。然后，可以随着时间的推移通过更改 ACPI 方法的内容来更改硬件，而无需更改驱动程序。

在设备树中，驱动程序设置时钟所需的参数如上述示例中称为“绑定”；在 ACPI 中，这些称为“设备属性”，并通过 _DSD 对象提供给驱动程序。

ACPI 表使用一种称为 ASL 的正式语言进行描述，即 ACPI 源语言（规范的第 19 节）。这意味着总是有多种方式来描述同一件事——包括设备属性。例如，设备属性可以使用如下 ASL 结构：Name(KEY0, "value0")。然后，ACPI 设备驱动程序可以通过评估 KEY0 对象来检索属性的值。然而，以这种方式使用 Name()存在多个问题：(1) ACPI 将名称（“KEY0”）限制为四个字符，不像设备树；(2) 没有行业范围的注册表来维护名称列表，从而最小化了重用；(3) 也没有属性值（“value0”）的注册表，再次使得重用困难；(4) 随着新硬件的出现，如何保持向后兼容性？_DSD 方法就是为了解决这些问题而创建的；Linux 驱动程序应该始终使用 _DSD 方法来获取设备属性，而不使用其他方法。

_DSM 对象（ACPI 第 9.14.1 节）也可用于将设备属性传递给驱动程序。Linux 驱动程序仅应在 _DSD 无法表示所需数据且无法为 _DSD 对象创建新 UUID 的情况下才使用它。请注意，对 _DSM 的使用甚至比 _DSD 更少受到监管。依赖 _DSM 对象内容的驱动程序由于这个原因将更难维护；截至本文撰写时，_DSM 的使用是导致相当多固件问题的原因，不建议使用。

驱动程序应仅在 _DSD 对象中查找设备属性；_DSD 对象在 ACPI 规范的第 6.2.5 节中进行了描述，但这仅描述了如何定义通过 _DSD 返回的对象的结构，以及特定数据结构如何由特定 UUID 定义。Linux 应仅使用 _DSD 设备属性 UUID [5]：

   -- UUID: daffd814-6eba-4d8c-8a91-bc9bbf4aa301

   -- http://www.uefi.org/sites/default/files/resources/_DSD-device-properties-UUID.pdf

UEFI 论坛提供了一种注册设备属性的机制[4]，以便它们可以在支持 ACPI 的所有操作系统中使用。未在 UEFI 论坛注册的设备属性不应使用。

在创建新的设备属性之前，请务必检查它们之前是否已定义，并且要么在 Linux 内核文档中注册为设备树绑定，要么在 UEFI 论坛中注册为设备属性。虽然我们不想简单地将所有设备树绑定都移到 ACPI 设备属性中，但我们可以从之前定义的内容中学习。

如果需要定义新的设备属性，或者将绑定的定义合成以便可以在任何固件中使用，设备树绑定和 ACPI 设备属性都有审查流程。请同时使用它们。当驱动程序本身提交给 Linux 邮件列表进行审查时，所需的设备属性定义必须同时提交。一个支持 ACPI 并使用设备属性的驱动程序，如果没有其定义，将不被视为完整的。一旦设备属性被 Linux 社区接受，必须在 UEFI 论坛[4]中注册，该论坛将再次审查其在注册表中的一致性。这可能需要迭代。然而，UEFI 论坛将始终是设备属性定义的权威站点。

通知 UEFI 论坛有意注册之前未使用的设备属性名称可能是有意义的，这是为以后使用保留名称的一种方式。其他操作系统供应商也将提交注册请求，这可能有助于简化流程。

一旦注册和审查完成，内核提供了一种独立于使用设备树还是 ACPI 的方式来查找设备属性的接口。应使用此 API[6]；它可以消除驱动程序探测函数中一些代码路径的重复，并防止设备树绑定和 ACPI 设备属性之间的分歧。

# 可编程电源控制资源

------------------------------------

可编程电源控制资源包括电压/电流提供器（调节器）和时钟源等资源。使用 ACPI 时，根本不期望使用内核时钟和调节器框架。

内核假定这些资源的电源控制由电源资源对象（ACPI 第 7.1 节）表示。然后，ACPI 核心将在需要时正确处理启用和禁用资源。为了使其正常工作，ACPI 假定每个设备都定义了 D 状态，并且可以通过可选的 ACPI 方法 _PS0、_PS1、_PS2 和 _PS3 进行控制；在 ACPI 中，_PS0 是用于将设备完全打开的方法，而 _PS3 用于将设备完全关闭。

使用这些电源资源有两种选择。它们可以：

-- 在进入电源状态 Dx 时调用的 _PSx 方法中进行管理。

-- 作为具有自己的 _ON 和 _OFF 方法的电源资源单独声明。然后，通过 _PRx 将它们与特定设备的 D 状态绑定，_PRx 指定设备在 Dx 状态下需要打开的电源资源。然后，内核跟踪使用电源资源的设备数量，并在需要时调用 _ON/_OFF。

内核 ACPI 代码还将假定 _PSx 方法遵循此类方法的正常 ACPI 规则：

-- 如果实现了 _PS0 或 _PS3，则必须实现另一个方法。

-- 如果设备在开启时需要使用或设置电源资源，ASL 应组织使用 _PS0 方法分配/启用它。

-- 在 _PS0 方法中分配或启用的资源应在 _PS3 方法中禁用或取消分配。

-- 固件将在将控制权移交给内核之前将资源置于合理状态。

_PSx 方法中的此类代码当然非常特定于平台。但是，这允许驱动程序抽象出操作设备的接口，并避免必须从 ACPI 表中读取特殊的非标准值。此外，抽象使用这些资源允许硬件随时间变化，而无需更新驱动程序。

# 时钟

------

ACPI 假设在将控制权移交给内核之前，固件（在这种情况下为 UEFI）已将时钟初始化为某个工作值。这对 UART 等设备或 SoC 驱动的 LCD 显示器等有影响。

当内核启动时，假定时钟已设置为合理的工作值。如果由于某种原因频率需要更改 - 例如，为了电源管理而进行节流 - 设备驱动程序应期望该过程被抽象为可以调用的一些 ACPI 方法（有关预期的标准方法的更多建议，请参阅 ACPI 规范）。此规则的唯一例外是 CPU 时钟，其中 CPPC 提供比 ACPI 方法丰富得多的接口。如果时钟未设置，Linux 无法直接控制它们。

如果 SoC 供应商希望提供对系统时钟的细粒度控制，他们可以通过提供 Linux 驱动程序可以调用的 ACPI 方法来实现。但是，不建议这样做，并且 Linux 驱动程序不应使用此类方法，即使提供了此类方法。此类方法目前在 ACPI 规范中未标准化，使用它们可能会将内核绑定到非常特定的 SoC，或者将 SoC 绑定到非常特定的内核版本，这两者都是我们试图避免的。

# 驱动程序建议

----------------------

在为驱动程序添加 ACPI 支持时，不要删除任何 DT 处理。同一设备可能在许多不同的系统上使用。

尝试将驱动程序结构化为数据驱动型。也就是说，根据默认值和驱动程序探测函数必须发现的其他内容，设置一个包含内部每个设备状态的结构体。然后，让驱动程序的其余部分根据该结构体的内容进行操作。这样做应允许将 ACPI 和 DT 功能之间的大多数差异保持在探测函数内部，而不是分散在整个驱动程序中。例如：

```
static int device_probe_dt(struct platform_device *pdev)
{
       /* DT 特定功能 */
      ... }
static int device_probe_acpi(struct platform_device *pdev)
{
       /* ACPI 特定功能 */
      ... }
static int device_probe(struct platform_device *pdev)
{
      ...        struct device_node node = pdev->dev.of_node;
      ... 
       if (node)
               ret = device_probe_dt(pdev);
       else if (ACPI_HANDLE(&pdev->dev))
               ret = device_probe_acpi(pdev);
       else
               /* 其他初始化 */
              ...        /* 继续进行任何通用探测操作 */
      ... }
```
	  
将 MODULE_DEVICE_TABLE 条目一起放在驱动程序中，以清楚地表明驱动程序从 DT 和 ACPI 探测的不同名称：

```
static struct of_device_id virtio_mmio_match[] = {
        {.compatible = "virtio,mmio", },
        { }
};
MODULE_DEVICE_TABLE(of, virtio_mmio_match);
static const struct acpi_device_id virtio_mmio_acpi_match[] = {
        { "LNRO0005", },
        { }
};
MODULE_DEVICE_TABLE(acpi, virtio_mmio_acpi_match);
```

# ASWG

----

ACPI 规范经常更改。例如，在 2014 年，发布了版本 5.1，版本 6.0 基本完成，大部分更改是由 ARM 特定要求驱动的。提议的更改在 ASWG（ACPI 规范工作组）中提出和讨论，ASWG 是 UEFI 论坛的一部分。

所有 UEFI 成员都可以参与该小组。有关小组成员资格的详细信息，请参阅 http://www.uefi.org/workinggroup。

ARMv8 ACPI 内核代码的意图是尽可能紧密地遵循 ACPI 规范，并仅实现符合 UEFI ASWG 发布标准的功能。实际上，可能会有供应商提供错误的 ACPI 表或以某种方式违反标准。如果是由于错误，可能需要进行怪癖和修复，但应尽可能避免。如果 ACPI 中缺少某些功能，导致无法在平台上使用它，应向 ASWG 提交 ECR（工程变更请求）并经过正常的批准过程；对于那些不是 UEFI 成员的人，Linux 社区的许多其他成员是成员，并且可能愿意协助提交 ECR。

# Linux 代码

----------

ARM 上的 Linux 特有的项目，包含在 Linux 源代码中，如下所示：

ACPI_OS_NAME           此宏定义在 ACPI 方法调用 _OS 方法时要返回的字符串。在 ARM64 系统上，此宏默认将为 "Linux"。命令行参数 acpi_os=<string> 可用于将其设置为其他值。其他架构的默认值例如为 "Microsoft Windows NT"。

# ACPI 对象

------------

ACPI 表和对象的详细期望在文件 Documentation/arm64/acpi_object_usage.txt 中列出。

# 参考

----------

[0] http://silver.arm.com -- 文档 ARM-DEN-0029 或更新版本

    "Server Base System Architecture"，版本 2.3，日期为 2014 年 3 月 27 日

[1] http://infocenter.arm.com/help/topic/com.arm.doc.den0044a/Server_Base_Boot_Requirements.pdf

    文档 ARM-DEN-0044A 或更新版本："Server Base Boot Requirements, System Software on ARM Platforms"，日期为 2014 年 8 月 16 日

[2] http://www.secretlab.ca/archives/151, 2015 年 1 月 10 日，版权所有 (c) 2015，Linaro Ltd.，由 Grant Likely 撰写。逐字文本的副本（除格式外）也在 Documentation/arm64/why_use_acpi.txt 中。[3] AMD 西雅图平台 ACPI 文档：

    http://amd-dev.wpengine.netdna-cdn.com/wordpress/media/2012/10/Seattle_ACPI_Guide.pdf

[4] http://www.uefi.org/acpi -- 请查看该链接以获取“ACPI _DSD 设备属性注册表说明”

[5] http://www.uefi.org/acpi -- 请查看该链接以获取“_DSD（设备特定数据）实施指南”

[6] 统一设备属性接口的内核代码可在 include/linux/property.h 和 drivers/base/property.c 中找到。

作者

-------

Al Stone <al.stone@linaro.org>

Graeme Gregory <graeme.gregory@linaro.org>

Hanjun Guo <hanjun.guo@linaro.org>

Grant Likely <grant.likely@linaro.org>，负责“为什么在 ARM 上使用 ACPI？”部分